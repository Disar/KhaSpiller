<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed acoordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurense of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurense of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/lib/haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There is some extra functions available in the `DateTools` class.

	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/EReg.hx">
		<match public="1" set="method" line="59">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="74">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<new public="1" set="method" line="48">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	http://haxe.org/manual/std-regex.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="42" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.

		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<has public="1" params="A" set="method" line="98" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains `elt`.

		This function returns true as soon as an element is found which is equal
		to `elt` according to the `==` operator.

		If no such element is found, the result is false.</haxe_doc>
		</has>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="49">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><t path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</t></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"><e>K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta><m n=":deprecated"/></meta>
	</typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, π. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.

		@php In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with `NaN` on Windows,
		see [https://bugs.php.net/bug.php?id=42143]</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.

		If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is
		`POSITIVE_INFINITY`.

		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		exp(1.0) is approximately 2.718281828459.

		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" get="inline" set="null" line="260" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" get="inline" set="null" line="264" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" get="inline" set="null" line="268" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/Reflect.hx" extern="1">
		<hasField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.

		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- Class<T>
		- Enum<T>

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is unspecified.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method">
	<f a="f">
		<f a="">
			<c path="Array"><d/></c>
			<x path="Void"/>
		</f>
		<d/>
	</f>
	<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
</makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/Std.hx" extern="1">
		<is public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.</haxe_doc>
		</is>
		<instance public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<haxe_doc>Checks if object `value` is an instance of class `c`.

		Compiles only if the class specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the class specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with interfaces or core types such
		as `String`, `Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</instance>
		<string public="1" set="method" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.

	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.

	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.

	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.

	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.

		This method is not required to check `hasNext` first. A call to this
		method while `hasNext` is false yields unspecified behavior.

		On the other hand iterators should not require a call to `hasNext`
		before the first call to `next` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, null is returned.

		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String "", the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the string literal syntax "string value".

	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<b><c path="String"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<new public="1" get="inline" set="null" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<isSpace public="1" set="method" line="183" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String "", or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="200" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="225" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="247" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for ltrim(rtrim(s)).</haxe_doc>
		</trim>
		<replace public="1" set="method" line="312" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String "", `by` is inserted after each character
		of `s`. If `by` is also the empty String "", `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="334" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its length equals `digits`.</haxe_doc>
		</hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Sys" params="" file="/usr/lib/haxe/std/Sys.hx" extern="1">
		<print public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline</haxe_doc>
		</println>
		<args public="1" set="method" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed by the commandline.</haxe_doc>
		</args>
		<getEnv public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<environment public="1" set="method" static="1">
			<f a=""><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></f>
			<haxe_doc>Returns the whole environement variables.</haxe_doc>
		</environment>
		<sleep public="1" set="method" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Change the current time locale, which will affect [DateTools.format] date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<command public="1" set="method" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Run the given command with the list of arguments. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).
		Read the [sys.io.Process] api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<getChar public="1" set="method" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input (without blocking) and returns it. Setting [echo] to true will also display it on the output.</haxe_doc>
		</getChar>
		<stdin public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See [getChar] for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in [sys] sub packages for more system APIs.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>sys</e></m>
		</meta>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<haxe_doc>The diffent possible runtime types of a value.</haxe_doc>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/Type.hx" extern="1">
		<getClass public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.

		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.

		If `o` is null, null is returned.

		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`.

		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array [] if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="UInt" params="" file="/usr/lib/haxe/std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned Int type is only defined for Flash and C#.
	Simulate it for other platforms.</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="/usr/lib/haxe/std/UInt.hx" private="1" module="UInt"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Function" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1"><meta><m n=":keep"/></meta></class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is null, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array [] if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
		<match public="1" set="method" static="1">
			<f a="e:pattern">
				<x path="EnumValue"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning true if
		matching succeeded and false otherwise.

		Example usage:

		```
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
		</match>
	</class>
	<abstract path="haxe.Int32" params="" file="/usr/lib/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
 	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/usr/lib/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/usr/lib/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/usr/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/usr/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>* This typedef will fool @:coreApi into thinking that we are using
  * the same underlying type, even though it might be different on
  * specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<t path="Null"><c path="Array"><d/></c></t>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Serializer" params="" file="/usr/lib/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="55" static="1">
			<x path="Bool"/>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set USE_CACHE to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of Serializer by
		setting their useCache field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="67" static="1">
			<x path="Bool"/>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of Serializer by
		setting their useEnumIndex field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="69" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="544" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

		This is a convenience function for creating a new instance of
		Serializer, serialize `v` into it and obtain the result through a call
		to toString().</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See USE_CACHE for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See USE_ENUM_INDEX for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="115">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		http://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="152"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="171"><f a="v">
	<unknown/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="208"><f a="v">
	<unknown/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="226">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

		All haxe-defined values and objects with the exception of functions can
		be serialized. Serialization of external/native objects is not
		guaranteed to work.

		The values of `this.useCache` and `this.useEnumIndex` may affect
		serialization output.</haxe_doc>
		</serialize>
		<new public="1" set="method" line="100">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each Serializer instance maintains its own cache if this.useCache` is
		true.</haxe_doc>
		</new>
		<haxe_doc>The Serializer class can be used to encode values and objects into a String,
	from which the Unserializer class can recreate the original representation.

	This class can be used in two ways:

	- create a new Serializer() instance, call its serialize() method with
		any argument and finally retrieve the String representation from
		toString()
	- call Serializer.run() to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	`http://haxe.org/manual/serialization/format`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Timer" params="" file="/usr/lib/haxe/std/haxe/Timer.hx">
		<stamp public="1" set="method" line="156" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a timestamp, in seconds with fractions.

		The value itself might differ depending on platforms, only differences
		between two values make sense.</haxe_doc>
		</stamp>
		<haxe_doc>The Timer class allows you to create asynchronous timers on platforms that
	support events.

	The intended usage is to create an instance of the Timer class with a given
	interval, set its run() method to a custom function to be invoked and
	eventually call stop() to stop the Timer.

	Note that a running Timer may or may not prevent the program to exit
	automatically when main() returns.

	It is also possible to extend this class and override its run() method in
	the child class.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Unserializer" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="60" static="1">
			<t path="haxe.TypeResolver"/>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a Class or Enum instance from a given String. By
		default, the haxe Type Api is used.

		A type resolver must provide two methods:

		1. resolveClass(name:String):Class<Dynamic> is called to determine a
				Class from a class name
		2. resolveEnum(name:String):Enum<Dynamic> is called to determine an
				Enum from an enum name

		This value is applied when a new Unserializer instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 line="62" static="1"><c path="String"/></BASE64>
		<CODES line="65" static="1"><c path="Array"><x path="Int"/></c></CODES>
		<initCodes set="method" line="67" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="459" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its unserialize() method
		once.</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" set="method" line="124">
			<f a="r">
				<t path="haxe.TypeResolver"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the type resolver of `this` Unserializer instance to `r`.

		If `r` is null, a special resolver is used which returns null for all
		input values.

		See DEFAULT_RESOLVER for more information on type resolvers.</haxe_doc>
		</setResolver>
		<readDigits set="method" line="147"><f a=""><x path="Int"/></f></readDigits>
		<readFloat set="method" line="172"><f a=""><x path="Float"/></f></readFloat>
		<unserializeObject set="method" line="185"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="200"><f a="edecl:tag">
	<x path="Enum"><unknown/></x>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="232">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from Type.createEmptyInstance, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="99">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc>The Unserializer class is the complement to the Serializer class. It parses
	a serialization String and creates objects from the contained data.

	This class can be used in two ways:

	- create a new Unserializer() instance with a given serialization
		String, then call its unserialize() method until all values are
		extracted
	- call Unserializer.run() to unserialize a single value from a given
		String</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="/usr/lib/haxe/std/haxe/ds/IntMap.hx" extern="1">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/ObjectMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/haxe/ds/StringMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="/usr/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="/usr/lib/haxe/std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.format.JsonParser" params="" file="/usr/lib/haxe/std/haxe/format/JsonParser.hx">
		<str><c path="String"/></str>
		<pos><x path="Int"/></pos>
		<parseRec set="method" line="54"><f a=""><d/></f></parseRec>
		<parseString set="method" line="136"><f a=""><c path="String"/></f></parseString>
		<invalidChar set="method" line="247"><f a=""><x path="Void"/></f></invalidChar>
		<invalidNumber set="method" line="252"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidNumber>
		<new set="method" line="49"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON parser in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.ArrayBufferViewData" params="" file="/usr/lib/haxe/std/haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView"><c path="haxe.io.ArrayBufferViewImpl"/></typedef>
	<class path="haxe.io.ArrayBufferViewImpl" params="" file="/usr/lib/haxe/std/haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView">
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<byteLength public="1"><x path="Int"/></byteLength>
		<new public="1" set="method" line="9"><f a="bytes:pos:length">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.io.ArrayBufferView" params="" file="/usr/lib/haxe/std/haxe/io/ArrayBufferView.hx">
		<this><t path="haxe.io.ArrayBufferViewData"/></this>
		<impl><class path="haxe.io._ArrayBufferView.ArrayBufferView_Impl_" params="" file="/usr/lib/haxe/std/haxe/io/ArrayBufferView.hx" private="1" module="haxe.io.ArrayBufferView">
	<EMULATED public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<haxe_doc>On some platforms configurations (for instance JS with no TypedArray support as in IE8-), Haxe will
		try to emulate the array buffers API. However in that case memory sharing will not be supported :
		each typed array or will copy its own data set. This flag allows users to detect if we are doing such emulation.
		At the moment only JavaScript is concerned.</haxe_doc>
	</EMULATED>
	<buffer public="1" get="accessor" set="null" static="1">
		<c path="haxe.io.Bytes"/>
		<meta><m n=":impl"/></meta>
	</buffer>
	<byteOffset public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</byteOffset>
	<byteLength public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</byteLength>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="455" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="482" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<sub public="1" set="method" line="133"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<getFloat public="1" set="method" line="232">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE single precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getFloat>
		<setFloat public="1" set="method" line="275">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the IEEE single precision value at given position in low endian encoding.
		Result is unspecified if writing outside of the bounds.</haxe_doc>
		</setFloat>
		<getString public="1" set="method" line="357"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<toString public="1" set="method" line="416"><f a=""><c path="String"/></f></toString>
		<new set="method" line="33"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<b><c path="Array"><x path="Int"/></c></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<getBytes public="1" set="method" line="191">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<bigEndian public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when reading numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<readByte public="1" set="method" line="46">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="61">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<readFullBytes public="1" set="method" line="130">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Unlike `readBytes`, this method tries to read the exact `len` amount of bytes.</haxe_doc>
		</readFullBytes>
		<read public="1" set="method" line="141">
			<f a="nbytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return `nbytes` bytes.</haxe_doc>
		</read>
		<readInt32 public="1" set="method" line="275">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt32>
		<readString public="1" set="method" line="294">
			<f a="len">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read and `len` bytes as a string.</haxe_doc>
		</readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesInput" params="" file="/usr/lib/haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<position public="1" get="null" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<set_position set="method" line="79"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></set_position>
		<readByte public="1" set="method" line="90" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="111" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="38"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/lib/haxe/std/haxe/io/Output.hx">
		<bigEndian public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when writing numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<write public="1" set="method" line="104">
			<f a="s">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write all bytes stored in `s`.</haxe_doc>
		</write>
		<writeInt16 public="1" set="method" line="167">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt16>
		<writeUInt16 public="1" set="method" line="177">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeUInt16>
		<writeInt32 public="1" set="method" line="221">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt32>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeByte] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="/usr/lib/haxe/std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<writeByte public="1" set="method" line="51" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="59" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<getBytes public="1" set="method" line="125"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.FPHelper" params="" file="/usr/lib/haxe/std/haxe/io/FPHelper.hx">
		<i32ToFloat public="1" set="method" line="62" static="1"><f a="i">
	<x path="Int"/>
	<x path="Float"/>
</f></i32ToFloat>
		<floatToI32 public="1" set="method" line="109" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></floatToI32>
		<haxe_doc>Helper that converts between floating point and binary representation.
	Always works in low-endian encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.Float32ArrayData" params="" file="/usr/lib/haxe/std/haxe/io/Float32Array.hx" module="haxe.io.Float32Array"><t path="haxe.io.ArrayBufferViewData"/></typedef>
	<abstract path="haxe.io.Float32Array" params="" file="/usr/lib/haxe/std/haxe/io/Float32Array.hx">
		<this><t path="haxe.io.Float32ArrayData"/></this>
		<impl><class path="haxe.io._Float32Array.Float32Array_Impl_" params="" file="/usr/lib/haxe/std/haxe/io/Float32Array.hx" private="1" module="haxe.io.Float32Array">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<view public="1" get="accessor" set="null" static="1">
		<x path="haxe.io.ArrayBufferView"/>
		<meta><m n=":impl"/></meta>
	</view>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<typedef path="haxe.macro.Position" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><x path="Int"/></min>
	<max><x path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<typedef path="haxe.macro.Expr" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<typedef path="haxe.macro.Case" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<guard>
		<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
		<meta><m n=":optional"/></meta>
	</guard>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Var" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Catch" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></typedef>
	<typedef path="haxe.macro.TypePath" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub>
		<t path="Null"><t path="Null"><c path="String"/></t></t>
		<meta><m n=":optional"/></meta>
	</sub>
	<params>
		<t path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<name><c path="String"/></name>
	<constraints>
		<t path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></t>
		<meta><m n=":optional"/></meta>
	</constraints>
</a></typedef>
	<typedef path="haxe.macro.Function" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value>
		<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
		<meta><m n=":optional"/></meta>
	</value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><t path="haxe.macro.MetadataEntry"/></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta>
		<t path="Null"><t path="haxe.macro.Metadata"/></t>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc>
		<t path="Null"><t path="Null"><c path="String"/></t></t>
		<meta><m n=":optional"/></meta>
	</doc>
	<access>
		<t path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></t>
		<meta><m n=":optional"/></meta>
	</access>
</a></typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta>
		<t path="Null"><t path="haxe.macro.Metadata"/></t>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<path><c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c></path>
	<mode><e path="haxe.macro.ImportMode"/></mode>
</a></typedef>
	<typedef path="haxe.macro.TExprTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools">
		<c path="haxe.macro.ExprTools"/>
		<haxe_doc>This class can be added via 'using haxe.macro.Tools' in order to enable
	'using' functionality on all macro tool classes listed below.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TComplexTypeTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools"><c path="haxe.macro.ComplexTypeTools"/></typedef>
	<typedef path="haxe.macro.TTypeTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools"><c path="haxe.macro.TypeTools"/></typedef>
	<typedef path="haxe.macro.TMacroStringTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools"><c path="haxe.macro.MacroStringTools"/></typedef>
	<typedef path="haxe.macro.TTypedExprTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools"><c path="haxe.macro.TypedExprTools"/></typedef>
	<typedef path="haxe.macro.TPositionTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools"><c path="haxe.macro.PositionTools"/></typedef>
	<typedef path="haxe.macro.Ref" params="T" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<toString set="method"><f a=""><c path="String"/></f></toString>
	<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
</a></typedef>
	<typedef path="haxe.macro.AnonType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<status><e path="haxe.macro.AnonStatus"/></status>
	<fields><c path="Array"><t path="haxe.macro.ClassField"/></c></fields>
</a></typedef>
	<typedef path="haxe.macro.TypeParameter" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.BaseType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.ClassField" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.FieldKind"/></kind>
	<isPublic><x path="Bool"/></isPublic>
	<expr set="method"><f a=""><t path="Null"><t path="haxe.macro.TypedExpr"/></t></f></expr>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.ClassType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<superClass><t path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></t></superClass>
	<statics><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></statics>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<overrides><c path="Array"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></c></overrides>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.ClassKind"/></kind>
	<isPrivate><x path="Bool"/></isPrivate>
	<isInterface><x path="Bool"/></isInterface>
	<isExtern><x path="Bool"/></isExtern>
	<interfaces><c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c></interfaces>
	<init><t path="Null"><t path="haxe.macro.TypedExpr"/></t></init>
	<fields><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></fields>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructor><t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></t></constructor>
</a></typedef>
	<typedef path="haxe.macro.EnumField" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<index><x path="Int"/></index>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.EnumType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<names><c path="Array"><c path="String"/></c></names>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructs><x path="Map">
	<c path="String"/>
	<t path="haxe.macro.EnumField"/>
</x></constructs>
</a></typedef>
	<typedef path="haxe.macro.DefType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.AbstractType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<unops><c path="Array"><a>
	<postFix><x path="Bool"/></postFix>
	<op><e path="haxe.macro.Unop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c></unops>
	<type><e path="haxe.macro.Type"/></type>
	<to><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><t path="Null"><t path="haxe.macro.ClassField"/></t></field>
</a></c></to>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<impl><t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t></impl>
	<from><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><t path="Null"><t path="haxe.macro.ClassField"/></t></field>
</a></c></from>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<binops><c path="Array"><a>
	<op><e path="haxe.macro.Binop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c></binops>
	<array><c path="Array"><t path="haxe.macro.ClassField"/></c></array>
</a></typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<remove set="method">
				<f a="name">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Removes all `name` metadata entries from the origin of `this`
		MetaAccess.

		This method might clear several metadata entries of the same name.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `remove` has no effect on that array.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</remove>
			<has set="method">
				<f a="name">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>Tells if the origin of `this` MetaAccess has a `name` metadata entry.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</has>
			<get set="method">
				<f a=""><t path="haxe.macro.Metadata"/></f>
				<haxe_doc>Return the wrapped `Metadata` array.

		Modifying this array has no effect on the origin of `this` MetaAccess.
		The `add` and `remove` methods can be used for that.</haxe_doc>
			</get>
			<extract set="method">
				<f a="name">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
				</f>
				<haxe_doc>Extract metadata entries by given `name`.

		If there's no metadata with such name, empty array is returned.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</extract>
			<add set="method">
				<f a="name:params:pos">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.Expr"/></c>
					<t path="haxe.macro.Position"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Adds the metadata specified by `name`, `params` and `pos` to the origin
		of `this` MetaAccess.

		Metadata names are not unique during compilation, so this method never
		overwrites a previous metadata.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `add` has no effect on that array.

		If any argument is null, compilation fails with an error.</haxe_doc>
			</add>
		</a>
		<haxe_doc>MetaAccess is a wrapper for the `Metadata` array. It can be used to add
	metadata to and remove metadata from its origin.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TVar" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t set="null"><e path="haxe.macro.Type"/></t>
	<name set="null"><c path="String"/></name>
	<id set="null"><x path="Int"/></id>
	<extra set="null"><t path="Null"><a>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<expr><t path="Null"><t path="haxe.macro.TypedExpr"/></t></expr>
</a></t></extra>
	<capture set="null"><x path="Bool"/></capture>
</a></typedef>
	<typedef path="haxe.macro.TFunc" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t><e path="haxe.macro.Type"/></t>
	<expr><t path="haxe.macro.TypedExpr"/></expr>
	<args><c path="Array"><a>
	<value><t path="Null"><e path="haxe.macro.TConstant"/></t></value>
	<v><t path="haxe.macro.TVar"/></v>
</a></c></args>
</a></typedef>
	<typedef path="haxe.macro.TypedExpr" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t><e path="haxe.macro.Type"/></t>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.TypedExprDef"/></expr>
</a></typedef>
	<class path="kha.Blob" params="" file="Kha/Backends/Kore/kha/Blob.hx">
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<position public="1"><x path="Int"/></position>
		<toBytes public="1" set="method" line="19"><f a=""><c path="haxe.io.Bytes"/></f></toBytes>
		<length public="1" set="method" line="23"><f a=""><x path="Int"/></f></length>
		<reset public="1" set="method" line="27"><f a=""><x path="Void"/></f></reset>
		<seek public="1" set="method" line="31"><f a="pos">
	<x path="Int"/>
	<x path="Void"/>
</f></seek>
		<readS8 public="1" set="method" line="40">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::s8 i = *(Kore::s8*)&bytes->b->Pointer()[position];\r\n\t\tposition += 1;\r\n\t\treturn i;\r\n\t"]]></e></m></meta>
		</readS8>
		<readU8 public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::u8 i = *(Kore::u8*)&bytes->b->Pointer()[position];\r\n\t\tposition += 1;\r\n\t\treturn i;\r\n\t"]]></e></m></meta>
		</readU8>
		<readS16LE public="1" set="method" line="59">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::u8* data = (Kore::u8*)&bytes->b->Pointer()[position];\r\n\t\tKore::s16 i = (data[0] << 0) | (data[1] << 8);\r\n\t\tposition += 2;\r\n\t\treturn i;\r\n\t"]]></e></m></meta>
		</readS16LE>
		<readS16BE public="1" set="method" line="69">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::u8* data = (Kore::u8*)&bytes->b->Pointer()[position];\r\n\t\tKore::s16 i = (data[1] << 0) | (data[0] << 8);\r\n\t\tposition += 2;\r\n\t\treturn i;\r\n\t"]]></e></m></meta>
		</readS16BE>
		<readU16LE public="1" set="method" line="79">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::u8* data = (Kore::u8*)&bytes->b->Pointer()[position];\r\n\t\tKore::u16 i = (data[0] << 0) | (data[1] << 8);\r\n\t\tposition += 2;\r\n\t\treturn i;\r\n\t"]]></e></m></meta>
		</readU16LE>
		<readU16BE public="1" set="method" line="89">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::u8* data = (Kore::u8*)&bytes->b->Pointer()[position];\r\n\t\tKore::u16 i = (data[1] << 0) | (data[0] << 8);\r\n\t\tposition += 2;\r\n\t\treturn i;\r\n\t"]]></e></m></meta>
		</readU16BE>
		<readS32LE public="1" set="method" line="99">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::u8* data = (Kore::u8*)&bytes->b->Pointer()[position];\r\n\t\tint i = (data[0] << 0) | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\r\n\t\tposition += 4;\r\n\t\treturn i;\r\n\t"]]></e></m></meta>
		</readS32LE>
		<readS32BE public="1" set="method" line="109">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::u8* data = (Kore::u8*)&bytes->b->Pointer()[position];\r\n\t\tint i = (data[3] << 0) | (data[2] << 8) | (data[1] << 16) | (data[0] << 24);\r\n\t\tposition += 4;\r\n\t\treturn i;\r\n\t"]]></e></m></meta>
		</readS32BE>
		<readF32LE public="1" set="method" line="119">
			<f a=""><x path="Float"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::u8* data = (Kore::u8*)&bytes->b->Pointer()[position];\r\n\t\tint i = (data[0] << 0) | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\r\n\t\tposition += 4;\r\n\t\treturn *(float*)&i;\r\n\t"]]></e></m></meta>
		</readF32LE>
		<readF32BE public="1" set="method" line="129">
			<f a=""><x path="Float"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::u8* data = (Kore::u8*)&bytes->b->Pointer()[position];\r\n\t\tint i = (data[3] << 0) | (data[2] << 8) | (data[1] << 16) | (data[0] << 24);\r\n\t\tposition += 4;\r\n\t\treturn *(float*)&i;\r\n\t"]]></e></m></meta>
		</readF32BE>
		<readF64LE public="1" set="method" line="133"><f a=""><x path="Float"/></f></readF64LE>
		<readF64BE public="1" set="method" line="137"><f a=""><x path="Float"/></f></readF64BE>
		<toString public="1" set="method" line="141"><f a=""><c path="String"/></f></toString>
		<unload public="1" set="method" line="146"><f a=""><x path="Void"/></f></unload>
		<new public="1" set="method" line="14"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n"]]></e></m>
		</meta>
	</class>
	<enum path="kha.Button" params="" file="Kha/Sources/kha/Button.hx">
		<NONE/>
		<UP/>
		<RIGHT/>
		<DOWN/>
		<LEFT/>
		<BUTTON_1/>
		<BUTTON_2/>
		<haxe_doc>* List of gamepad buttons.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.Canvas" params="" file="Kha/Sources/kha/Canvas.hx" interface="1">
		<get_width public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_width>
		<get_height public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_height>
		<get_g1 public="1" set="method">
			<f a=""><c path="kha.graphics1.Graphics"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_g1>
		<get_g2 public="1" set="method">
			<f a=""><c path="kha.graphics2.Graphics"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_g2>
		<get_g4 public="1" set="method">
			<f a=""><c path="kha.graphics4.Graphics"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_g4>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The width of the canvas in pixels.</haxe_doc>
		</width>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The height of the canvas in pixels.</haxe_doc>
		</height>
		<g1 public="1" get="accessor" set="null">
			<c path="kha.graphics1.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics1 interface object.<br>
	 * Basic setPixel operation.]]></haxe_doc>
		</g1>
		<g2 public="1" get="accessor" set="null">
			<c path="kha.graphics2.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics2 interface object.<br>
	 * Use this for 2D operations.]]></haxe_doc>
		</g2>
		<g4 public="1" get="accessor" set="null">
			<c path="kha.graphics4.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics4 interface object.<br>
	 * Use this for 3D operations.]]></haxe_doc>
		</g4>
		<haxe_doc><![CDATA[* Interface for a generic Canvas with different APIs,<br>
 * that can be used to draw graphics.]]></haxe_doc>
		<meta><m n=":allow"><e>kha.Starter</e></m></meta>
	</class>
	<abstract path="kha.Color" params="" file="Kha/Sources/kha/Color.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Class representing a color, based on Int.
 * Provides a variety of methods for creating and converting colors.
 * 
 * Color's can be written as Ints. This means you can pass a hex value such as
 * 0xff123456 to a function expecting a Color, and it will automatically become a Color object.
 * Similarly, Colors may be treated as Ints.</haxe_doc>
		<meta><m n=":expose"/></meta>
		<impl><class path="kha._Color.Color_Impl_" params="" file="Kha/Sources/kha/Color.hx" private="1" module="kha.Color">
	<Black public="1" line="13" static="1"><x path="kha.Color"/></Black>
	<White public="1" line="14" static="1"><x path="kha.Color"/></White>
	<Red public="1" line="15" static="1"><x path="kha.Color"/></Red>
	<Blue public="1" line="16" static="1"><x path="kha.Color"/></Blue>
	<Green public="1" line="17" static="1"><x path="kha.Color"/></Green>
	<Magenta public="1" line="18" static="1"><x path="kha.Color"/></Magenta>
	<Yellow public="1" line="19" static="1"><x path="kha.Color"/></Yellow>
	<Cyan public="1" line="20" static="1"><x path="kha.Color"/></Cyan>
	<Purple public="1" line="21" static="1"><x path="kha.Color"/></Purple>
	<Pink public="1" line="22" static="1"><x path="kha.Color"/></Pink>
	<Orange public="1" line="23" static="1"><x path="kha.Color"/></Orange>
	<fromValue public="1" get="inline" set="null" line="28" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="kha.Color"/>
		</f>
		<haxe_doc>* Creates a new Color object from a packed 32 bit ARGB value.</haxe_doc>
	</fromValue>
	<fromBytes public="1" set="method" line="35" static="1">
		<f a="r:g:b:?a">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="kha.Color"/>
		</f>
		<haxe_doc>* Creates a new Color object from components in the range 0 - 255.</haxe_doc>
	</fromBytes>
	<fromFloats public="1" set="method" line="42" static="1">
		<f a="r:g:b:?a">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="kha.Color"/>
		</f>
		<haxe_doc>* Creates a new Color object from components in the range 0 - 1.</haxe_doc>
	</fromFloats>
	<fromString public="1" set="method" line="49" static="1">
		<f a="value">
			<c path="String"/>
			<x path="kha.Color"/>
		</f>
		<haxe_doc>* Creates a new Color object from #AARRGGBB string.</haxe_doc>
	</fromString>
	<Rb public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a byte representing the red color component.</haxe_doc>
	</Rb>
	<Gb public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a byte representing the green color component.</haxe_doc>
	</Gb>
	<Bb public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a byte representing the blue color component.</haxe_doc>
	</Bb>
	<Ab public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a byte representing the alpha color component (more exactly the opacity component - a value of 0 is fully transparent).</haxe_doc>
	</Ab>
	<R public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a float representing the red color component.</haxe_doc>
	</R>
	<G public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a float representing the green color component.</haxe_doc>
	</G>
	<B public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a float representing the blue color component.</haxe_doc>
	</B>
	<A public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a float representing the alpha color component (more exactly the opacity component - a value of 0 is fully transparent).</haxe_doc>
	</A>
	<_new set="method" line="95" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="kha.Color"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<value public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Return this Color instance as Int.</haxe_doc>
	</value>
	<get_value get="inline" set="null" line="104" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_value>
	<set_value get="inline" set="null" line="108" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_value>
	<get_Rb set="method" line="113" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_Rb>
	<get_Gb set="method" line="117" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_Gb>
	<get_Bb set="method" line="121" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_Bb>
	<get_Ab set="method" line="125" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_Ab>
	<set_Rb get="inline" set="null" line="129" static="1">
		<f a="this:i">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_Rb>
	<set_Gb get="inline" set="null" line="134" static="1">
		<f a="this:i">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_Gb>
	<set_Bb get="inline" set="null" line="139" static="1">
		<f a="this:i">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_Bb>
	<set_Ab get="inline" set="null" line="144" static="1">
		<f a="this:i">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_Ab>
	<get_R get="inline" set="null" line="149" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_R>
	<get_G get="inline" set="null" line="153" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_G>
	<get_B get="inline" set="null" line="157" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_B>
	<get_A get="inline" set="null" line="161" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_A>
	<set_R get="inline" set="null" line="165" static="1">
		<f a="this:f">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_R>
	<set_G get="inline" set="null" line="170" static="1">
		<f a="this:f">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_G>
	<set_B get="inline" set="null" line="175" static="1">
		<f a="this:f">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_B>
	<set_A get="inline" set="null" line="180" static="1">
		<f a="this:f">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_A>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="kha._Color.Color_Impl_" params="" file="Kha/Sources/kha/Color.hx" private="1" module="kha.Color">
		<Black public="1" line="13" static="1"><x path="kha.Color"/></Black>
		<White public="1" line="14" static="1"><x path="kha.Color"/></White>
		<Red public="1" line="15" static="1"><x path="kha.Color"/></Red>
		<Blue public="1" line="16" static="1"><x path="kha.Color"/></Blue>
		<Green public="1" line="17" static="1"><x path="kha.Color"/></Green>
		<Magenta public="1" line="18" static="1"><x path="kha.Color"/></Magenta>
		<Yellow public="1" line="19" static="1"><x path="kha.Color"/></Yellow>
		<Cyan public="1" line="20" static="1"><x path="kha.Color"/></Cyan>
		<Purple public="1" line="21" static="1"><x path="kha.Color"/></Purple>
		<Pink public="1" line="22" static="1"><x path="kha.Color"/></Pink>
		<Orange public="1" line="23" static="1"><x path="kha.Color"/></Orange>
		<fromValue public="1" get="inline" set="null" line="28" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="kha.Color"/>
			</f>
			<haxe_doc>* Creates a new Color object from a packed 32 bit ARGB value.</haxe_doc>
		</fromValue>
		<fromBytes public="1" set="method" line="35" static="1">
			<f a="r:g:b:?a">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="kha.Color"/>
			</f>
			<haxe_doc>* Creates a new Color object from components in the range 0 - 255.</haxe_doc>
		</fromBytes>
		<fromFloats public="1" set="method" line="42" static="1">
			<f a="r:g:b:?a">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="kha.Color"/>
			</f>
			<haxe_doc>* Creates a new Color object from components in the range 0 - 1.</haxe_doc>
		</fromFloats>
		<fromString public="1" set="method" line="49" static="1">
			<f a="value">
				<c path="String"/>
				<x path="kha.Color"/>
			</f>
			<haxe_doc>* Creates a new Color object from #AARRGGBB string.</haxe_doc>
		</fromString>
		<Rb public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a byte representing the red color component.</haxe_doc>
		</Rb>
		<Gb public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a byte representing the green color component.</haxe_doc>
		</Gb>
		<Bb public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a byte representing the blue color component.</haxe_doc>
		</Bb>
		<Ab public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a byte representing the alpha color component (more exactly the opacity component - a value of 0 is fully transparent).</haxe_doc>
		</Ab>
		<R public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a float representing the red color component.</haxe_doc>
		</R>
		<G public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a float representing the green color component.</haxe_doc>
		</G>
		<B public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a float representing the blue color component.</haxe_doc>
		</B>
		<A public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a float representing the alpha color component (more exactly the opacity component - a value of 0 is fully transparent).</haxe_doc>
		</A>
		<_new set="method" line="95" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="kha.Color"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<value public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Return this Color instance as Int.</haxe_doc>
		</value>
		<get_value get="inline" set="null" line="104" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_value>
		<set_value get="inline" set="null" line="108" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_value>
		<get_Rb set="method" line="113" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_Rb>
		<get_Gb set="method" line="117" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_Gb>
		<get_Bb set="method" line="121" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_Bb>
		<get_Ab set="method" line="125" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_Ab>
		<set_Rb get="inline" set="null" line="129" static="1">
			<f a="this:i">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_Rb>
		<set_Gb get="inline" set="null" line="134" static="1">
			<f a="this:i">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_Gb>
		<set_Bb get="inline" set="null" line="139" static="1">
			<f a="this:i">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_Bb>
		<set_Ab get="inline" set="null" line="144" static="1">
			<f a="this:i">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_Ab>
		<get_R get="inline" set="null" line="149" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_R>
		<get_G get="inline" set="null" line="153" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_G>
		<get_B get="inline" set="null" line="157" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_B>
		<get_A get="inline" set="null" line="161" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_A>
		<set_R get="inline" set="null" line="165" static="1">
			<f a="this:f">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_R>
		<set_G get="inline" set="null" line="170" static="1">
			<f a="this:f">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_G>
		<set_B get="inline" set="null" line="175" static="1">
			<f a="this:f">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_B>
		<set_A get="inline" set="null" line="180" static="1">
			<f a="this:f">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_A>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Configuration" params="" file="Kha/Sources/kha/Configuration.hx">
		<theScreen static="1">
			<c path="kha.Game"/>
			<haxe_doc>* The game instance.</haxe_doc>
		</theScreen>
		<id line="14" static="1">
			<x path="Int"/>
			<haxe_doc>* ID of the time task.</haxe_doc>
		</id>
		<screen public="1" get="inline" set="null" line="19" static="1">
			<f a=""><c path="kha.Game"/></f>
			<haxe_doc>* Return the game instance.</haxe_doc>
		</screen>
		<schedulerInitialized set="method" line="27" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>kha.Scheduler</e></m></meta>
			<haxe_doc>* Call this to let the system know the scheduler has been initialized.</haxe_doc>
		</schedulerInitialized>
		<setScreen public="1" set="method" line="34" static="1">
			<f a="screen">
				<c path="kha.Game"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the game instance.</haxe_doc>
		</setScreen>
		<update set="method" line="45" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update the game.</haxe_doc>
		</update>
		<haxe_doc>* This class handles updating the game instance.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Cursor" params="" file="Kha/Sources/kha/Cursor.hx" interface="1">
		<get_clickX public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_clickX>
		<get_clickY public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_clickY>
		<get_width public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_width>
		<get_height public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_height>
		<clickX public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The X position.</haxe_doc>
		</clickX>
		<clickY public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The Y position.</haxe_doc>
		</clickY>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The cursor width.</haxe_doc>
		</width>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The cursor height.</haxe_doc>
		</height>
		<render public="1" set="method">
			<f a="g:x:y">
				<c path="kha.graphics2.Graphics"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Render the cursor on screen.
	 * 
	 * @param g		The graphics2 instance to render.
	 * @param x		The X position of the cursor.
	 * @param y		The Y position of the cursor.</haxe_doc>
		</render>
		<update public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Update the cursor.
	 * 
	 * @param x		The X position of the cursor.
	 * @param y		The Y position of the cursor.</haxe_doc>
		</update>
		<haxe_doc>* A generic interface for a Cursor.</haxe_doc>
	</class>
	<class path="kha.Game" params="" file="Kha/Sources/kha/Game.hx">
		<FPS public="1" line="17" static="1">
			<x path="Int"/>
			<haxe_doc>* The current FPS.</haxe_doc>
		</FPS>
		<the public="1" set="null" static="1">
			<c path="kha.Game"/>
			<haxe_doc>* Static instance.</haxe_doc>
		</the>
		<name>
			<c path="String"/>
			<haxe_doc>* ID name.</haxe_doc>
		</name>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>* Defined width.</haxe_doc>
		</width>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>* Defined height.</haxe_doc>
		</height>
		<highscores public="1" set="null">
			<c path="kha.HighscoreList"/>
			<haxe_doc>* The high scores list.</haxe_doc>
		</highscores>
		<setInstance public="1" set="method" line="52">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Set the static instance.</haxe_doc>
		</setInstance>
		<loadFinished public="1" set="method" line="61">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Callback from when the loaded finished.
	 * This updates the game width and height values 
	 * and also call init().</haxe_doc>
		</loadFinished>
		<init public="1" set="method" line="73">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom init behavior.
	 * Called after the loading process.</haxe_doc>
		</init>
		<update public="1" set="method" line="79">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom update behavior.
	 * Called per frame or various times per frame.</haxe_doc>
		</update>
		<startRender set="method" line="88">
			<f a="frame">
				<c path="kha.Framebuffer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Start render mode for the passed frame.
	 * 
	 * @param frame		The frame buffer we will be rendering on.</haxe_doc>
		</startRender>
		<endRender set="method" line="99">
			<f a="frame">
				<c path="kha.Framebuffer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Finish render mode for the passed frame.
	 * 
	 * @param frame		The frame buffer we will be rendering on.</haxe_doc>
		</endRender>
		<render public="1" set="method" line="110">
			<f a="frame">
				<c path="kha.Framebuffer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this to get your own custom render behavior.
	 * Called per frame.</haxe_doc>
		</render>
		<getHighscores public="1" set="method" line="123">
			<f a=""><c path="kha.HighscoreList"/></f>
			<haxe_doc>* Return the high score list.</haxe_doc>
		</getHighscores>
		<deprecatedImage><c path="kha.Image"/></deprecatedImage>
		<initDeprecatedImage set="method" line="129"><f a=""><x path="Void"/></f></initDeprecatedImage>
		<painterTransformMouseX public="1" set="method" line="135">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":deprecated"><e>"kha.Game.painterTransformMouseX(x, y) is deprecated, use kha.Scaler.transformX instead."</e></m></meta>
		</painterTransformMouseX>
		<painterTransformMouseY public="1" set="method" line="141">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":deprecated"><e>"kha.Game.painterTransformMouseY(x, y) is deprecated, use kha.Scaler.transformY instead."</e></m></meta>
		</painterTransformMouseY>
		<buttonDown public="1" set="method" line="147"><f a="button">
	<e path="kha.Button"/>
	<x path="Void"/>
</f></buttonDown>
		<buttonUp public="1" set="method" line="149"><f a="button">
	<e path="kha.Button"/>
	<x path="Void"/>
</f></buttonUp>
		<keyDown public="1" set="method" line="152"><f a="key:char">
	<e path="kha.Key"/>
	<c path="String"/>
	<x path="Void"/>
</f></keyDown>
		<keyUp public="1" set="method" line="154"><f a="key:char">
	<e path="kha.Key"/>
	<c path="String"/>
	<x path="Void"/>
</f></keyUp>
		<mouseDown public="1" set="method" line="157"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseDown>
		<mouseUp public="1" set="method" line="159"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseUp>
		<rightMouseDown public="1" set="method" line="161"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rightMouseDown>
		<rightMouseUp public="1" set="method" line="163"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rightMouseUp>
		<middleMouseDown public="1" set="method" line="165"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></middleMouseDown>
		<middleMouseUp public="1" set="method" line="167"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></middleMouseUp>
		<mouseMove public="1" set="method" line="169"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseMove>
		<mouseWheel public="1" set="method" line="171"><f a="delta">
	<x path="Int"/>
	<x path="Void"/>
</f></mouseWheel>
		<onForeground public="1" set="method" line="177">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom foreground behavior.
	 * Called when this application frame is moved from background of the screen to the top.</haxe_doc>
		</onForeground>
		<onResume public="1" set="method" line="182">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom resume behavior.
	 * Called when resuming the application from pause.</haxe_doc>
		</onResume>
		<onPause public="1" set="method" line="187">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom shutdown behavior.
	 * Called when pausing the application.</haxe_doc>
		</onPause>
		<onBackground public="1" set="method" line="192">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom background behavior.
	 * Called when this app frame is moved from top of the screen to the background.</haxe_doc>
		</onBackground>
		<onShutdown public="1" set="method" line="197">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom shutdown behavior.
	 * Called when shutting down the system.</haxe_doc>
		</onShutdown>
		<new public="1" set="method" line="41">
			<f a="name:?hasHighscores">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new game object.
	 * 
	 * @param name				The ID name.
	 * @param hasHighscores		If it has high scores or not.</haxe_doc>
		</new>
		<haxe_doc>* Main Kha class.
 * Inherit from this in your game or application.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.EmptyScreen" params="" file="Kha/Sources/kha/EmptyScreen.hx">
		<extends path="kha.Game"/>
		<color>
			<x path="kha.Color"/>
			<haxe_doc>* The color of the screen.</haxe_doc>
		</color>
		<render public="1" set="method" line="24" override="1">
			<f a="frame">
				<c path="kha.Framebuffer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Render the screen.</haxe_doc>
		</render>
		<update public="1" set="method" line="37" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom update behavior.
	 * Called per frame or various times per frame.</haxe_doc>
		</update>
		<new public="1" set="method" line="16">
			<f a="color">
				<x path="kha.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialize a new screen.</haxe_doc>
		</new>
		<haxe_doc>* An empty screen.
 * This will be the default screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Font" params="" file="Kha/Sources/kha/Font.hx" interface="1">
		<get_name public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_name>
		<get_style public="1" set="method">
			<f a=""><c path="kha.FontStyle"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_style>
		<get_size public="1" set="method">
			<f a=""><x path="Float"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_size>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>* The font name.</haxe_doc>
		</name>
		<style public="1" get="accessor" set="null">
			<c path="kha.FontStyle"/>
			<haxe_doc>* Font style (bold, italic, ect).</haxe_doc>
		</style>
		<size public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Font size</haxe_doc>
		</size>
		<getHeight public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Font height</haxe_doc>
		</getHeight>
		<charWidth public="1" set="method">
			<f a="ch">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* With of a character in this font
	 * 
 	 * @param ch		The character.</haxe_doc>
		</charWidth>
		<charsWidth public="1" set="method">
			<f a="ch:offset:length">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* With of a group character in this font.
	 *
	 * @param ch		The characters.
	 * @param offset	The offset before get the 1st character.
	 * @param length	The length to get.</haxe_doc>
		</charsWidth>
		<stringWidth public="1" set="method">
			<f a="str">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Width of a string with this font.
	 *
	 * @param str		The string to measure.</haxe_doc>
		</stringWidth>
		<getBaselinePosition public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The base line position.</haxe_doc>
		</getBaselinePosition>
		<haxe_doc>* This represents a text font.</haxe_doc>
	</class>
	<class path="kha.FontStyle" params="" file="Kha/Sources/kha/FontStyle.hx">
		<Default public="1" set="null" line="10" static="1">
			<c path="kha.FontStyle"/>
			<haxe_doc>* The default style.</haxe_doc>
		</Default>
		<bold>
			<x path="Bool"/>
			<haxe_doc>* If the font is bold.</haxe_doc>
		</bold>
		<italic>
			<x path="Bool"/>
			<haxe_doc>* If the font is italic.</haxe_doc>
		</italic>
		<underlined>
			<x path="Bool"/>
			<haxe_doc>* If the font is underlined.</haxe_doc>
		</underlined>
		<getBold public="1" set="method" line="40">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns true if the font is bold.</haxe_doc>
		</getBold>
		<getItalic public="1" set="method" line="47">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns true if the font is italic.</haxe_doc>
		</getItalic>
		<getUnderlined public="1" set="method" line="54">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns true if the font is underlined.</haxe_doc>
		</getUnderlined>
		<new public="1" set="method" line="31">
			<f a="bold:italic:underlined">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialize a new font style.
	 * 
	 * @param bold				If the font is bold, default = false.
	 * @param italic			If the font is italic, default = false.
 	 * @param underlined		If the font is underlined, default = false.</haxe_doc>
		</new>
		<haxe_doc>* The font style (bold, italic, ect).</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Framebuffer" params="" file="Kha/Sources/kha/Framebuffer.hx">
		<implements path="kha.Canvas"/>
		<graphics1>
			<c path="kha.graphics1.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics1 interface object.<br>
	 * Basic setPixel operation.]]></haxe_doc>
		</graphics1>
		<graphics2>
			<c path="kha.graphics2.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics2 interface object.<br>
	 * Use this for 2D operations.]]></haxe_doc>
		</graphics2>
		<graphics4>
			<c path="kha.graphics4.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics4 interface object.<br>
	 * Use this for 3D operations.]]></haxe_doc>
		</graphics4>
		<init public="1" set="method" line="46">
			<f a="g1:g2:g4">
				<c path="kha.graphics1.Graphics"/>
				<c path="kha.graphics2.Graphics"/>
				<c path="kha.graphics4.Graphics"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialize a new frame buffer object instance.
	 * 
	 * @param g1		The Graphics1 object.
 	 * @param g2		The Graphics2 object.
	 * @param g4		The Graphics4 object.</haxe_doc>
		</init>
		<g1 public="1" get="accessor" set="null">
			<c path="kha.graphics1.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics1 interface object.<br>
	 * Basic setPixel operation.]]></haxe_doc>
		</g1>
		<get_g1 set="method" line="62">
			<f a=""><c path="kha.graphics1.Graphics"/></f>
			<haxe_doc><![CDATA[* Return the Graphics1 interface object.<br>
	 * Basic setPixel operation.]]></haxe_doc>
		</get_g1>
		<g2 public="1" get="accessor" set="null">
			<c path="kha.graphics2.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics2 interface object.<br>
	 * Use this for 2D operations.]]></haxe_doc>
		</g2>
		<get_g2 set="method" line="76">
			<f a=""><c path="kha.graphics2.Graphics"/></f>
			<haxe_doc><![CDATA[* Return the Graphics2 interface object.<br>
	 * Use this for 2D operations.]]></haxe_doc>
		</get_g2>
		<g4 public="1" get="accessor" set="null">
			<c path="kha.graphics4.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics4 interface object.<br>
	 * Use this for 3D operations.]]></haxe_doc>
		</g4>
		<get_g4 set="method" line="90">
			<f a=""><c path="kha.graphics4.Graphics"/></f>
			<haxe_doc><![CDATA[* Return the Graphics4 interface object.<br>
	 * Use this for 3D operations.]]></haxe_doc>
		</get_g4>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The width of the buffer in pixels.</haxe_doc>
		</width>
		<get_width set="method" line="102">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Return the width of the buffer in pixels.</haxe_doc>
		</get_width>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The height of the buffer in pixels.</haxe_doc>
		</height>
		<get_height set="method" line="114">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Return the height of the buffer in pixels.</haxe_doc>
		</get_height>
		<new public="1" set="method" line="33">
			<f a="g1:g2:g4">
				<c path="kha.graphics1.Graphics"/>
				<c path="kha.graphics2.Graphics"/>
				<c path="kha.graphics4.Graphics"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new frame buffer object instance.
	 * 
	 * @param g1		The Graphics1 object.
 	 * @param g2		The Graphics2 object.
	 * @param g4		The Graphics4 object.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The FrameBuffer represents the current graphical status of the application,<br>
 * you can get references to different graphical APIs,<br>
 * that can be used to draw graphics.]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>kha.Starter</e></m>
		</meta>
	</class>
	<class path="kha.HighscoreList" params="" file="Kha/Sources/kha/HighscoreList.hx">
		<scores><c path="Array"><c path="kha.Score"/></c></scores>
		<getScores public="1" set="method" line="26"><f a=""><c path="Array"><c path="kha.Score"/></c></f></getScores>
		<addScore public="1" set="method" line="30"><f a="name:score">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addScore>
		<load public="1" set="method" line="42"><f a="file">
	<c path="kha.StorageFile"/>
	<x path="Void"/>
</f></load>
		<save public="1" set="method" line="53"><f a="file">
	<c path="kha.StorageFile"/>
	<x path="Void"/>
</f></save>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Resource" params="" file="Kha/Sources/kha/Resource.hx" interface="1">
		<unload public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unload the resource from memory.</haxe_doc>
		</unload>
		<haxe_doc>* Interface representing a generic application resource.
 * It can go from images, to sound or music, videos or blobs.</haxe_doc>
	</class>
	<class path="kha.Image" params="" file="Kha/Backends/Kore/kha/Image.hx">
		<implements path="kha.Resource"/>
		<implements path="kha.Canvas"/>
		<createFromVideo public="1" set="method" line="22" static="1"><f a="video">
	<c path="kha.Video"/>
	<c path="kha.Image"/>
</f></createFromVideo>
		<create public="1" set="method" line="29" static="1"><f a="width:height:?format:?usage:?levels">
	<x path="Int"/>
	<x path="Int"/>
	<e path="kha.graphics4.TextureFormat"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Int"/>
	<c path="kha.Image"/>
</f></create>
		<createRenderTarget public="1" set="method" line="33" static="1"><f a="width:height:?format:?depthStencil:?antiAliasingSamples">
	<x path="Int"/>
	<x path="Int"/>
	<e path="kha.graphics4.TextureFormat"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="kha.Image"/>
</f></createRenderTarget>
		<create2 public="1" set="method" line="41" static="1"><f a="width:height:format:readable:renderTarget:depthBuffer">
	<x path="Int"/>
	<x path="Int"/>
	<e path="kha.graphics4.TextureFormat"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="kha.Image"/>
</f></create2>
		<fromFile public="1" set="method" line="64" static="1"><f a="filename:readable">
	<c path="String"/>
	<x path="Bool"/>
	<c path="kha.Image"/>
</f></fromFile>
		<maxSize public="1" get="accessor" set="null" static="1"><x path="Int"/></maxSize>
		<get_maxSize public="1" set="method" line="105" static="1"><f a=""><x path="Int"/></f></get_maxSize>
		<nonPow2Supported public="1" get="accessor" set="null" static="1"><x path="Bool"/></nonPow2Supported>
		<get_nonPow2Supported public="1" set="method" line="112" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":functionCode"><e>"return Kore::Graphics::nonPow2TexturesSupported();"</e></m></meta>
		</get_nonPow2Supported>
		<format><e path="kha.graphics4.TextureFormat"/></format>
		<readable><x path="Bool"/></readable>
		<graphics1><c path="kha.graphics1.Graphics"/></graphics1>
		<graphics2><c path="kha.graphics2.Graphics"/></graphics2>
		<graphics4><c path="kha.graphics4.Graphics"/></graphics4>
		<initRenderTarget set="method" line="50">
			<f a="width:height:format:depthBuffer">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"renderTarget = new Kore::RenderTarget(width, height, depthBuffer, false, Kore::Target32Bit); texture = nullptr;"</e></m></meta>
		</initRenderTarget>
		<init set="method" line="55">
			<f a="width:height:format">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"texture = new Kore::Texture(width, height, (Kore::Image::Format)format, readable); renderTarget = nullptr;"</e></m></meta>
		</init>
		<initVideo set="method" line="60">
			<f a="video">
				<c path="kha.kore.Video"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["texture = video->video->currentImage(); renderTarget = nullptr;"]]></e></m></meta>
		</initVideo>
		<initFromFile set="method" line="72">
			<f a="filename">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"texture = new Kore::Texture(filename.c_str(), readable);"</e></m></meta>
		</initFromFile>
		<g1 public="1" get="accessor" set="null"><c path="kha.graphics1.Graphics"/></g1>
		<get_g1 set="method" line="78"><f a=""><c path="kha.graphics1.Graphics"/></f></get_g1>
		<g2 public="1" get="accessor" set="null"><c path="kha.graphics2.Graphics"/></g2>
		<get_g2 set="method" line="87"><f a=""><c path="kha.graphics2.Graphics"/></f></get_g2>
		<g4 public="1" get="accessor" set="null"><c path="kha.graphics4.Graphics"/></g4>
		<get_g4 set="method" line="96"><f a=""><c path="kha.graphics4.Graphics"/></f></get_g4>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<get_width public="1" set="method" line="120">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["if (texture != nullptr) return texture->width; else return renderTarget->width;"]]></e></m></meta>
		</get_width>
		<get_height public="1" set="method" line="125">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["if (texture != nullptr) return texture->height; else return renderTarget->height;"]]></e></m></meta>
		</get_height>
		<realWidth public="1" get="accessor" set="null"><x path="Int"/></realWidth>
		<realHeight public="1" get="accessor" set="null"><x path="Int"/></realHeight>
		<get_realWidth public="1" set="method" line="133">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["if (texture != nullptr) return texture->texWidth; else return renderTarget->texWidth;"]]></e></m></meta>
		</get_realWidth>
		<get_realHeight public="1" set="method" line="138">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["if (texture != nullptr) return texture->texHeight; else return renderTarget->texHeight;"]]></e></m></meta>
		</get_realHeight>
		<set public="1" set="method" line="146">
			<f a="unit">
				<c path="kha.kore.graphics4.TextureUnit"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tif (texture != nullptr) texture-> set(unit->unit);\r\n\t\telse renderTarget->useColorAsTexture(unit->unit);\r\n\t"]]></e></m></meta>
		</set>
		<isOpaque public="1" set="method" line="151">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["return texture->at(x, y) & 0xff != 0;"]]></e></m></meta>
		</isOpaque>
		<unload public="1" set="method" line="156">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"delete texture; texture = nullptr; delete renderTarget; renderTarget = nullptr;"</e></m></meta>
		</unload>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<lock public="1" set="method" line="162"><f a="?level">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></lock>
		<unlock public="1" set="method" line="173">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::u8* b = bytes->b->Pointer();\r\n\t\tKore::u8* tex = texture->lock();\r\n\t\tfor (int i = 0; i < ((texture->format == Kore::Image::RGBA32) ? (4 * texture->width * texture->height) : (texture->width * texture->height)); ++i) tex[i] = b[i];\r\n\t\ttexture->unlock();\r\n\t"]]></e></m></meta>
		</unlock>
		<new set="method" line="37"><f a="readable">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Graphics/Graphics.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"Kore::Texture* texture; Kore::RenderTarget* renderTarget;"</e></m>
		</meta>
	</class>
	<enum path="kha.Key" params="" file="Kha/Sources/kha/Key.hx">
		<BACKSPACE/>
		<TAB/>
		<ENTER/>
		<SHIFT/>
		<CTRL/>
		<ALT/>
		<CHAR/>
		<ESC/>
		<DEL/>
		<UP/>
		<DOWN/>
		<LEFT/>
		<RIGHT/>
		<haxe_doc>* List of special Keyboard keys.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.BakedChar" params="" file="Kha/Sources/kha/Kravur.hx" module="kha.Kravur">
		<x0 public="1"><x path="Int"/></x0>
		<y0 public="1"><x path="Int"/></y0>
		<x1 public="1"><x path="Int"/></x1>
		<y1 public="1"><x path="Int"/></y1>
		<xoff public="1"><x path="Float"/></xoff>
		<yoff public="1"><x path="Float"/></yoff>
		<xadvance public="1"><x path="Float"/></xadvance>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.AlignedQuad" params="" file="Kha/Sources/kha/Kravur.hx" module="kha.Kravur">
		<x0 public="1"><x path="Float"/></x0>
		<y0 public="1"><x path="Float"/></y0>
		<s0 public="1"><x path="Float"/></s0>
		<t0 public="1"><x path="Float"/></t0>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<s1 public="1"><x path="Float"/></s1>
		<t1 public="1"><x path="Float"/></t1>
		<xadvance public="1"><x path="Float"/></xadvance>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Kravur" params="" file="Kha/Sources/kha/Kravur.hx">
		<implements path="kha.Font"/>
		<fontCache line="49" static="1"><x path="Map">
	<c path="String"/>
	<c path="kha.Kravur"/>
</x></fontCache>
		<get public="1" set="method" line="53" static="1">
			<f a="name:style:size">
				<c path="String"/>
				<c path="kha.FontStyle"/>
				<x path="Float"/>
				<c path="kha.Kravur"/>
			</f>
			<haxe_doc>Returns the cached Kravur for name, style and size or loads it.</haxe_doc>
		</get>
		<myName><c path="String"/></myName>
		<myStyle><c path="kha.FontStyle"/></myStyle>
		<mySize><x path="Float"/></mySize>
		<chars><c path="Array"><c path="kha.BakedChar"/></c></chars>
		<texture><c path="kha.Image"/></texture>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<baseline><x path="Float"/></baseline>
		<getTexture public="1" set="method" line="121"><f a=""><c path="kha.Image"/></f></getTexture>
		<getBakedQuad public="1" set="method" line="125"><f a="char_index:xpos:ypos">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.AlignedQuad"/>
</f></getBakedQuad>
		<getCharWidth set="method" line="150"><f a="charIndex">
	<x path="Int"/>
	<x path="Float"/>
</f></getCharWidth>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<style public="1" get="accessor" set="null"><c path="kha.FontStyle"/></style>
		<size public="1" get="accessor" set="null"><x path="Float"/></size>
		<get_name public="1" set="method" line="160"><f a=""><c path="String"/></f></get_name>
		<get_style public="1" set="method" line="164"><f a=""><c path="kha.FontStyle"/></f></get_style>
		<get_size public="1" set="method" line="168"><f a=""><x path="Float"/></f></get_size>
		<getHeight public="1" set="method" line="172"><f a=""><x path="Float"/></f></getHeight>
		<charWidth public="1" set="method" line="176"><f a="ch">
	<c path="String"/>
	<x path="Float"/>
</f></charWidth>
		<charsWidth public="1" set="method" line="180"><f a="ch:offset:length">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></charsWidth>
		<stringWidth public="1" set="method" line="184"><f a="string">
	<c path="String"/>
	<x path="Float"/>
</f></stringWidth>
		<getBaselinePosition public="1" set="method" line="198"><f a=""><x path="Float"/></f></getBaselinePosition>
		<new set="method" line="78"><f a="blob">
	<c path="kha.Blob"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Loader" params="" file="Kha/Sources/kha/Loader.hx">
		<the public="1" set="null" static="1"><c path="kha.Loader"/></the>
		<init public="1" set="method" line="49" static="1"><f a="loader">
	<c path="kha.Loader"/>
	<x path="Void"/>
</f></init>
		<containsAsset public="1" set="method" line="121" static="1"><f a="assetName:assetType:map">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Bool"/>
</f></containsAsset>
		<blobs><x path="Map">
	<c path="String"/>
	<c path="kha.Blob"/>
</x></blobs>
		<images><x path="Map">
	<c path="String"/>
	<c path="kha.Image"/>
</x></images>
		<sounds><x path="Map">
	<c path="String"/>
	<c path="kha.Sound"/>
</x></sounds>
		<musics><x path="Map">
	<c path="String"/>
	<c path="kha.Music"/>
</x></musics>
		<videos><x path="Map">
	<c path="String"/>
	<c path="kha.Video"/>
</x></videos>
		<shaders><x path="Map">
	<c path="String"/>
	<c path="kha.Blob"/>
</x></shaders>
		<loadcount><x path="Int"/></loadcount>
		<numberOfFiles><x path="Int"/></numberOfFiles>
		<assets><x path="Map">
	<c path="String"/>
	<d/>
</x></assets>
		<rooms><x path="Map">
	<c path="String"/>
	<c path="kha.loader.Room"/>
</x></rooms>
		<isQuitable public="1">
			<x path="Bool"/>
			<haxe_doc>* Some backends dont support quitting, for example if the game is embedded in a web page.</haxe_doc>
		</isQuitable>
		<autoCleanupAssets public="1"><x path="Bool"/></autoCleanupAssets>
		<basePath public="1"><c path="String"/></basePath>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<name public="1" set="null"><c path="String"/></name>
		<antiAliasingSamples public="1" set="null"><x path="Int"/></antiAliasingSamples>
		<getLoadPercentage public="1" set="method" line="53"><f a=""><x path="Int"/></f></getLoadPercentage>
		<getBlob public="1" set="method" line="57"><f a="name">
	<c path="String"/>
	<c path="kha.Blob"/>
</f></getBlob>
		<getImage public="1" set="method" line="61"><f a="name">
	<c path="String"/>
	<c path="kha.Image"/>
</f></getImage>
		<getMusic public="1" set="method" line="68"><f a="name">
	<c path="String"/>
	<c path="kha.Music"/>
</f></getMusic>
		<getSound public="1" set="method" line="72"><f a="name">
	<c path="String"/>
	<c path="kha.Sound"/>
</f></getSound>
		<getVideo public="1" set="method" line="79"><f a="name">
	<c path="String"/>
	<c path="kha.Video"/>
</f></getVideo>
		<getShader public="1" set="method" line="83"><f a="name">
	<c path="String"/>
	<c path="kha.Blob"/>
</f></getShader>
		<getAvailableBlobs public="1" set="method" line="87"><f a=""><t path="Iterator"><c path="String"/></t></f></getAvailableBlobs>
		<isBlobAvailable public="1" get="inline" set="null" line="90"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></isBlobAvailable>
		<getAvailableImages public="1" set="method" line="92"><f a=""><t path="Iterator"><c path="String"/></t></f></getAvailableImages>
		<isImageAvailable public="1" get="inline" set="null" line="95"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></isImageAvailable>
		<getAvailableMusic public="1" set="method" line="97"><f a=""><t path="Iterator"><c path="String"/></t></f></getAvailableMusic>
		<isMusicAvailable public="1" get="inline" set="null" line="100"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></isMusicAvailable>
		<getAvailableSounds public="1" set="method" line="102"><f a=""><t path="Iterator"><c path="String"/></t></f></getAvailableSounds>
		<isSoundAvailable public="1" get="inline" set="null" line="105"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></isSoundAvailable>
		<getAvailableVideos public="1" set="method" line="107"><f a=""><t path="Iterator"><c path="String"/></t></f></getAvailableVideos>
		<isVideoAvailable public="1" get="inline" set="null" line="110"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></isVideoAvailable>
		<enqueued><c path="Array"><d/></c></enqueued>
		<loadFinished public="1"><f a=""><x path="Void"/></f></loadFinished>
		<enqueue public="1" set="method" line="115"><f a="asset">
	<d/>
	<x path="Void"/>
</f></enqueue>
		<removeImage set="method" line="128"><f a="resources:resourceName">
	<x path="Map">
		<c path="String"/>
		<c path="kha.Image"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></removeImage>
		<removeBlob set="method" line="134"><f a="resources:resourceName">
	<x path="Map">
		<c path="String"/>
		<c path="kha.Blob"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></removeBlob>
		<removeMusic set="method" line="140"><f a="resources:resourceName">
	<x path="Map">
		<c path="String"/>
		<c path="kha.Music"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></removeMusic>
		<removeSound set="method" line="146"><f a="resources:resourceName">
	<x path="Map">
		<c path="String"/>
		<c path="kha.Sound"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></removeSound>
		<removeVideo set="method" line="152"><f a="resources:resourceName">
	<x path="Map">
		<c path="String"/>
		<c path="kha.Video"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></removeVideo>
		<cleanup public="1" set="method" line="158"><f a=""><x path="Void"/></f></cleanup>
		<loadFiles public="1" set="method" line="168"><f a="call:autoCleanup">
	<f a=""><x path="Void"/></f>
	<x path="Bool"/>
	<x path="Void"/>
</f></loadFiles>
		<loadProject public="1" set="method" line="275"><f a="call">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></loadProject>
		<loadShaders set="method" line="280"><f a="call">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></loadShaders>
		<loadRoomAssets set="method" line="309"><f a="room">
	<c path="kha.loader.Room"/>
	<x path="Void"/>
</f></loadRoomAssets>
		<loadRoom public="1" set="method" line="316"><f a="name:call">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></loadRoom>
		<unloadedImage public="1" set="method" line="322"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></unloadedImage>
		<initProject public="1" set="method" line="328"><f a=""><x path="Void"/></f></initProject>
		<parseProject set="method" line="365"><f a=""><d/></f></parseProject>
		<checkComplete set="method" line="369"><f a=""><x path="Void"/></f></checkComplete>
		<loadDummyFile set="method" line="384"><f a=""><x path="Void"/></f></loadDummyFile>
		<loadStarted set="method" line="389"><f a="numberOfFiles">
	<x path="Int"/>
	<x path="Void"/>
</f></loadStarted>
		<loadImage public="1" set="method" line="399"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Image"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadImage>
		<loadBlob public="1" set="method" line="400"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Blob"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBlob>
		<loadSound public="1" set="method" line="401"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadSound>
		<loadMusic public="1" set="method" line="402"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Music"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadMusic>
		<loadVideo public="1" set="method" line="403"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Video"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadVideo>
		<loadFont public="1" set="method" line="405"><f a="name:style:size">
	<c path="String"/>
	<c path="kha.FontStyle"/>
	<x path="Float"/>
	<c path="kha.Font"/>
</f></loadFont>
		<loadURL public="1" set="method" line="407"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></loadURL>
		<setNormalCursor public="1" set="method" line="409"><f a=""><x path="Void"/></f></setNormalCursor>
		<setHandCursor public="1" set="method" line="410"><f a=""><x path="Void"/></f></setHandCursor>
		<setCursorBusy public="1" set="method" line="411"><f a="busy">
	<x path="Bool"/>
	<x path="Void"/>
</f></setCursorBusy>
		<showKeyboard public="1" set="method" line="413"><f a=""><x path="Void"/></f></showKeyboard>
		<hideKeyboard public="1" set="method" line="414"><f a=""><x path="Void"/></f></hideKeyboard>
		<quit public="1" set="method" line="416"><f a=""><x path="Void"/></f></quit>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":expose"/>
		</meta>
	</class>
	<class path="kha.Media" params="" file="Kha/Sources/kha/Media.hx">
		<implements path="kha.Resource"/>
		<play public="1" set="method" line="16">
			<f a="?loop">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Play / resume the media element.
	 * 
	 * @param loop		If playing it looped, default = false.</haxe_doc>
		</play>
		<pause public="1" set="method" line="20">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pause the media element.</haxe_doc>
		</pause>
		<stop public="1" set="method" line="24">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pause the stop element.</haxe_doc>
		</stop>
		<getLength public="1" set="method" line="29">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Return the media length, in milliseconds.</haxe_doc>
		</getLength>
		<getCurrentPos public="1" set="method" line="34">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Return the media position, in milliseconds.</haxe_doc>
		</getCurrentPos>
		<getVolume public="1" set="method" line="39">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Return the media volume, between 0 and 1.</haxe_doc>
		</getVolume>
		<setVolume public="1" set="method" line="46">
			<f a="volume">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the media volume, between 0 and 1.
	 *
	 * @param volume	The new volume, between 0 and 1.</haxe_doc>
		</setVolume>
		<isFinished public="1" set="method" line="51">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* If the media has finished or not.</haxe_doc>
		</isFinished>
		<unload public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unload the resource from memory.</haxe_doc>
		</unload>
		<new public="1" set="method" line="10">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Create a new media object instance.</haxe_doc>
		</new>
		<haxe_doc>* This class is used for dynamic media like sounds or videos</haxe_doc>
	</class>
	<class path="kha.Mouse" params="" file="Kha/Sources/kha/Mouse.hx">
		<hidden><x path="Bool"/></hidden>
		<forceSystem><x path="Bool"/></forceSystem>
		<cursors><c path="Array"><c path="kha.Cursor"/></c></cursors>
		<cursorIndex><x path="Int"/></cursorIndex>
		<show public="1" set="method" line="20"><f a=""><x path="Void"/></f></show>
		<hide public="1" set="method" line="25"><f a=""><x path="Void"/></f></hide>
		<hideSystemCursor set="method" line="30"><f a=""><x path="Void"/></f></hideSystemCursor>
		<showSystemCursor set="method" line="34"><f a=""><x path="Void"/></f></showSystemCursor>
		<forceSystemCursor public="1" set="method" line="38"><f a="force">
	<x path="Bool"/>
	<x path="Void"/>
</f></forceSystemCursor>
		<pushCursor public="1" set="method" line="47"><f a="cursorImage">
	<c path="kha.Cursor"/>
	<x path="Void"/>
</f></pushCursor>
		<popCursor public="1" set="method" line="53"><f a=""><x path="Void"/></f></popCursor>
		<render public="1" set="method" line="63"><f a="g">
	<c path="kha.graphics2.Graphics"/>
	<x path="Void"/>
</f></render>
		<update public="1" set="method" line="67"><f a=""><x path="Void"/></f></update>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="kha.Music" params="" file="Kha/Sources/kha/Music.hx">
		<extends path="kha.Media"/>
		<data public="1">
			<c path="haxe.io.Bytes"/>
			<haxe_doc>* The music file in a bytes.</haxe_doc>
		</data>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This represents a Music file.</haxe_doc>
	</class>
	<class path="kha.Rectangle" params="" file="Kha/Sources/kha/Rectangle.hx">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X coordinate of the point.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y coordinate of the point.</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the rectangle.</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the rectangle.</haxe_doc>
		</height>
		<setPos public="1" set="method" line="42">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the rectangle position.</haxe_doc>
		</setPos>
		<moveX public="1" set="method" line="52">
			<f a="xdelta">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move the rectangle in the X axis.
	 *
	 * @param xdelta		The amount to move.</haxe_doc>
		</moveX>
		<moveY public="1" set="method" line="61">
			<f a="ydelta">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move the rectangle in the Y axis.
	 *
	 * @param ydelta		The ammount to move.</haxe_doc>
		</moveY>
		<collision public="1" set="method" line="72">
			<f a="r">
				<c path="kha.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if some Rectangle object overlaps this Rectangle object.
	 * 
	 * @param	r	The rectangle being tested.
	 * 
	 * @return	Whether or not the two rectangles overlap.</haxe_doc>
		</collision>
		<new public="1" set="method" line="32">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new rectangle.
	 * 
	 * @param	x		The X-coordinate of the rectangle in space.
	 * @param	y		The Y-coordinate of the rectangle in space.
	 * @param	width	Desired width of the rectangle.
	 * @param	height	Desired height of the rectangle.</haxe_doc>
		</new>
		<haxe_doc>* Stores a rectangle.</haxe_doc>
	</class>
	<class path="kha.TargetRectangle" params="" file="Kha/Sources/kha/Scaler.hx" module="kha.Scaler">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<scaleFactor public="1"><x path="Float"/></scaleFactor>
		<rotation public="1"><e path="kha.ScreenRotation"/></rotation>
		<new public="1" set="method" line="20"><f a="x:y:w:h:s:r">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<e path="kha.ScreenRotation"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Scaler" params="" file="Kha/Sources/kha/Scaler.hx">
		<targetRect public="1" set="method" line="31" static="1"><f a="width:height:destination:rotation">
	<x path="Int"/>
	<x path="Int"/>
	<c path="kha.Canvas"/>
	<e path="kha.ScreenRotation"/>
	<c path="kha.TargetRectangle"/>
</f></targetRect>
		<transformX public="1" set="method" line="102" static="1"><f a="x:y:source:destination:rotation">
	<x path="Int"/>
	<x path="Int"/>
	<c path="kha.Image"/>
	<c path="kha.Canvas"/>
	<e path="kha.ScreenRotation"/>
	<x path="Int"/>
</f></transformX>
		<transformY public="1" set="method" line="116" static="1"><f a="x:y:source:destination:rotation">
	<x path="Int"/>
	<x path="Int"/>
	<c path="kha.Image"/>
	<c path="kha.Canvas"/>
	<e path="kha.ScreenRotation"/>
	<x path="Int"/>
</f></transformY>
		<scale public="1" set="method" line="130" static="1"><f a="source:destination:rotation">
	<c path="kha.Image"/>
	<c path="kha.Canvas"/>
	<e path="kha.ScreenRotation"/>
	<x path="Void"/>
</f></scale>
		<getScaledTransformation public="1" set="method" line="138" static="1"><f a="width:height:destination:rotation">
	<x path="Int"/>
	<x path="Int"/>
	<c path="kha.Canvas"/>
	<e path="kha.ScreenRotation"/>
	<c path="kha.math.Matrix3"/>
</f></getScaledTransformation>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.TimeTask" params="" file="Kha/Sources/kha/Scheduler.hx" module="kha.Scheduler">
		<task public="1"><f a=""><x path="Bool"/></f></task>
		<start public="1"><x path="Float"/></start>
		<period public="1"><x path="Float"/></period>
		<duration public="1"><x path="Float"/></duration>
		<next public="1"><x path="Float"/></next>
		<id public="1"><x path="Int"/></id>
		<groupId public="1"><x path="Int"/></groupId>
		<active public="1"><x path="Bool"/></active>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.FrameTask" params="" file="Kha/Sources/kha/Scheduler.hx" module="kha.Scheduler">
		<task public="1"><f a=""><x path="Bool"/></f></task>
		<priority public="1"><x path="Int"/></priority>
		<id public="1"><x path="Int"/></id>
		<active public="1"><x path="Bool"/></active>
		<new public="1" set="method" line="26"><f a="task:priority:id">
	<f a=""><x path="Bool"/></f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Scheduler" params="" file="Kha/Sources/kha/Scheduler.hx">
		<timeTasks static="1"><c path="Array"><c path="kha.TimeTask"/></c></timeTasks>
		<frameTasks static="1"><c path="Array"><c path="kha.FrameTask"/></c></frameTasks>
		<current static="1"><x path="Float"/></current>
		<lastTime static="1"><x path="Float"/></lastTime>
		<frame_tasks_sorted static="1"><x path="Bool"/></frame_tasks_sorted>
		<stopped static="1"><x path="Bool"/></stopped>
		<vsync static="1"><x path="Bool"/></vsync>
		<onedifhz static="1"><x path="Float"/></onedifhz>
		<currentFrameTaskId static="1"><x path="Int"/></currentFrameTaskId>
		<currentTimeTaskId static="1"><x path="Int"/></currentTimeTaskId>
		<currentGroupId static="1"><x path="Int"/></currentGroupId>
		<halted_count static="1"><x path="Int"/></halted_count>
		<DIF_COUNT line="53" static="1"><x path="Int"/></DIF_COUNT>
		<maxframetime line="54" static="1"><x path="Float"/></maxframetime>
		<deltas static="1"><c path="Array"><x path="Float"/></c></deltas>
		<dScale line="59" static="1"><x path="Float"/></dScale>
		<startTime line="61" static="1"><x path="Float"/></startTime>
		<lastNow line="63" static="1"><x path="Float"/></lastNow>
		<init public="1" set="method" line="65" static="1"><f a=""><x path="Void"/></f></init>
		<start public="1" set="method" line="84" static="1"><f a=""><x path="Void"/></f></start>
		<stop public="1" set="method" line="96" static="1"><f a=""><x path="Void"/></f></stop>
		<isStopped public="1" set="method" line="100" static="1"><f a=""><x path="Bool"/></f></isStopped>
		<back public="1" set="method" line="104" static="1"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></back>
		<executeFrame public="1" set="method" line="119" static="1"><f a=""><x path="Void"/></f></executeFrame>
		<time public="1" set="method" line="243" static="1"><f a=""><x path="Float"/></f></time>
		<realTime public="1" set="method" line="247" static="1"><f a=""><x path="Float"/></f></realTime>
		<resetTime public="1" set="method" line="251" static="1"><f a=""><x path="Void"/></f></resetTime>
		<addBreakableFrameTask public="1" set="method" line="265" static="1"><f a="task:priority">
	<f a=""><x path="Bool"/></f>
	<x path="Int"/>
	<x path="Int"/>
</f></addBreakableFrameTask>
		<addFrameTask public="1" set="method" line="271" static="1"><f a="task:priority">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<x path="Int"/>
</f></addFrameTask>
		<removeFrameTask public="1" set="method" line="275" static="1"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></removeFrameTask>
		<generateGroupId public="1" set="method" line="285" static="1"><f a=""><x path="Int"/></f></generateGroupId>
		<addBreakableTimeTaskToGroup public="1" set="method" line="289" static="1"><f a="groupId:task:start:?period:?duration">
	<x path="Int"/>
	<f a=""><x path="Bool"/></f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></addBreakableTimeTaskToGroup>
		<addTimeTaskToGroup public="1" set="method" line="308" static="1"><f a="groupId:task:start:?period:?duration">
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></addTimeTaskToGroup>
		<addBreakableTimeTask public="1" set="method" line="312" static="1"><f a="task:start:?period:?duration">
	<f a=""><x path="Bool"/></f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></addBreakableTimeTask>
		<addTimeTask public="1" set="method" line="316" static="1"><f a="task:start:?period:?duration">
	<f a=""><x path="Void"/></f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></addTimeTask>
		<getTimeTask set="method" line="320" static="1"><f a="id">
	<x path="Int"/>
	<c path="kha.TimeTask"/>
</f></getTimeTask>
		<removeTimeTask public="1" set="method" line="329" static="1"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></removeTimeTask>
		<removeTimeTasks public="1" set="method" line="337" static="1"><f a="groupId">
	<x path="Int"/>
	<x path="Void"/>
</f></removeTimeTasks>
		<numTasksInSchedule public="1" set="method" line="350" static="1"><f a=""><x path="Int"/></f></numTasksInSchedule>
		<insertSorted set="method" line="354" static="1"><f a="list:task">
	<c path="Array"><c path="kha.TimeTask"/></c>
	<c path="kha.TimeTask"/>
	<x path="Void"/>
</f></insertSorted>
		<sortFrameTasks set="method" line="364" static="1"><f a=""><x path="Void"/></f></sortFrameTasks>
		<get_deltaScale set="method" line="378" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Delta time between frames</haxe_doc>
		</get_deltaScale>
		<set_deltaScale set="method" line="383" static="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_deltaScale>
		<deltaScale public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>Multiplier for delta time</haxe_doc>
		</deltaScale>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Score" params="" file="Kha/Sources/kha/Score.hx">
		<name><c path="String"/></name>
		<score><x path="Int"/></score>
		<getName public="1" set="method" line="12"><f a=""><c path="String"/></f></getName>
		<getScore public="1" set="method" line="16"><f a=""><x path="Int"/></f></getScore>
		<increase public="1" set="method" line="20"><f a="amount">
	<x path="Int"/>
	<x path="Void"/>
</f></increase>
		<new public="1" set="method" line="7"><f a="name:score">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.ScreenCanvas" params="" file="Kha/Sources/kha/ScreenCanvas.hx">
		<implements path="kha.Canvas"/>
		<instance line="8" static="1"><c path="kha.ScreenCanvas"/></instance>
		<the public="1" get="accessor" set="null" static="1">
			<c path="kha.ScreenCanvas"/>
			<haxe_doc>* Static instance of the ScreenCanvas.</haxe_doc>
		</the>
		<get_the set="method" line="19" static="1"><f a=""><c path="kha.ScreenCanvas"/></f></get_the>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The width of the canvas in pixels.</haxe_doc>
		</width>
		<get_width set="method" line="29"><f a=""><x path="Int"/></f></get_width>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The height of the canvas in pixels.</haxe_doc>
		</height>
		<get_height set="method" line="39"><f a=""><x path="Int"/></f></get_height>
		<g1 public="1" get="accessor" set="null">
			<c path="kha.graphics1.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics1 interface object.<br>
	 * Basic setPixel operation.]]></haxe_doc>
		</g1>
		<get_g1 set="method" line="49"><f a=""><c path="kha.graphics1.Graphics"/></f></get_g1>
		<g2 public="1" get="accessor" set="null">
			<c path="kha.graphics2.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics2 interface object.<br>
	 * Use this for 2D operations.]]></haxe_doc>
		</g2>
		<get_g2 set="method" line="59"><f a=""><c path="kha.graphics2.Graphics"/></f></get_g2>
		<g4 public="1" get="accessor" set="null">
			<c path="kha.graphics4.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics4 interface object.<br>
	 * Use this for 3D operations.]]></haxe_doc>
		</g4>
		<get_g4 set="method" line="70"><f a=""><c path="kha.graphics4.Graphics"/></f></get_g4>
		<new set="method" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This represents the screen canvas.
 * This is deprecated.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.ScreenRotation" params="" file="Kha/Sources/kha/ScreenRotation.hx">
		<RotationNone/>
		<Rotation90/>
		<Rotation180/>
		<Rotation270/>
		<haxe_doc>* Enum with all the possible rotations.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.Sound" params="" file="Kha/Sources/kha/Sound.hx">
		<implements path="kha.Resource"/>
		<data public="1">
			<x path="haxe.ds.Vector"><x path="Float"/></x>
			<haxe_doc>* The sound data.</haxe_doc>
		</data>
		<play public="1" set="method" line="24">
			<f a=""><c path="kha.SoundChannel"/></f>
			<haxe_doc>* Play this sound.
	 *
	 * @return		Return a sound channel.</haxe_doc>
		</play>
		<unload public="1" set="method" line="31">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unload this sound resource.</haxe_doc>
		</unload>
		<new public="1" set="method" line="17">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiate a new sound object.</haxe_doc>
		</new>
		<haxe_doc>* This represents a Sound file.</haxe_doc>
	</class>
	<class path="kha.SoundChannel" params="" file="Kha/Sources/kha/SoundChannel.hx">
		<wasStopped><x path="Bool"/></wasStopped>
		<play public="1" set="method" line="8"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method" line="10"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="12"><f a=""><x path="Void"/></f></stop>
		<getLength public="1" set="method" line="14"><f a=""><x path="Int"/></f></getLength>
		<getCurrentPos public="1" set="method" line="16"><f a=""><x path="Int"/></f></getCurrentPos>
		<getVolume public="1" set="method" line="18"><f a=""><x path="Float"/></f></getVolume>
		<setVolume public="1" set="method" line="20"><f a="volume">
	<x path="Float"/>
	<x path="Void"/>
</f></setVolume>
		<setPan public="1" set="method" line="22"><f a="pan">
	<x path="Float"/>
	<x path="Void"/>
</f></setPan>
		<getPan public="1" set="method" line="24"><f a=""><x path="Float"/></f></getPan>
		<isFinished public="1" set="method" line="26"><f a=""><x path="Bool"/></f></isFinished>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="kha.Starter" params="" file="Kha/Backends/Kore/kha/Starter.hx">
		<framebuffer static="1"><c path="kha.Framebuffer"/></framebuffer>
		<keyboard static="1"><c path="kha.input.Keyboard"/></keyboard>
		<mouse static="1"><c path="kha.input.Mouse"/></mouse>
		<gamepad static="1"><c path="kha.input.Gamepad"/></gamepad>
		<surface static="1"><c path="kha.input.Surface"/></surface>
		<frame public="1" set="method" line="104" static="1"><f a=""><x path="Void"/></f></frame>
		<pushUp public="1" set="method" line="121" static="1"><f a=""><x path="Void"/></f></pushUp>
		<pushDown public="1" set="method" line="127" static="1"><f a=""><x path="Void"/></f></pushDown>
		<pushLeft public="1" set="method" line="133" static="1"><f a=""><x path="Void"/></f></pushLeft>
		<pushRight public="1" set="method" line="139" static="1"><f a=""><x path="Void"/></f></pushRight>
		<pushButton1 public="1" set="method" line="145" static="1"><f a=""><x path="Void"/></f></pushButton1>
		<releaseUp public="1" set="method" line="149" static="1"><f a=""><x path="Void"/></f></releaseUp>
		<releaseDown public="1" set="method" line="155" static="1"><f a=""><x path="Void"/></f></releaseDown>
		<releaseLeft public="1" set="method" line="161" static="1"><f a=""><x path="Void"/></f></releaseLeft>
		<releaseRight public="1" set="method" line="167" static="1"><f a=""><x path="Void"/></f></releaseRight>
		<releaseButton1 public="1" set="method" line="173" static="1"><f a=""><x path="Void"/></f></releaseButton1>
		<pushChar public="1" set="method" line="177" static="1"><f a="charCode">
	<x path="Int"/>
	<x path="Void"/>
</f></pushChar>
		<releaseChar public="1" set="method" line="182" static="1"><f a="charCode">
	<x path="Int"/>
	<x path="Void"/>
</f></releaseChar>
		<pushShift public="1" set="method" line="187" static="1"><f a=""><x path="Void"/></f></pushShift>
		<releaseShift public="1" set="method" line="192" static="1"><f a=""><x path="Void"/></f></releaseShift>
		<pushBackspace public="1" set="method" line="197" static="1"><f a=""><x path="Void"/></f></pushBackspace>
		<releaseBackspace public="1" set="method" line="202" static="1"><f a=""><x path="Void"/></f></releaseBackspace>
		<pushTab public="1" set="method" line="207" static="1"><f a=""><x path="Void"/></f></pushTab>
		<releaseTab public="1" set="method" line="212" static="1"><f a=""><x path="Void"/></f></releaseTab>
		<pushEnter public="1" set="method" line="217" static="1"><f a=""><x path="Void"/></f></pushEnter>
		<releaseEnter public="1" set="method" line="222" static="1"><f a=""><x path="Void"/></f></releaseEnter>
		<pushControl public="1" set="method" line="227" static="1"><f a=""><x path="Void"/></f></pushControl>
		<releaseControl public="1" set="method" line="232" static="1"><f a=""><x path="Void"/></f></releaseControl>
		<pushAlt public="1" set="method" line="237" static="1"><f a=""><x path="Void"/></f></pushAlt>
		<releaseAlt public="1" set="method" line="242" static="1"><f a=""><x path="Void"/></f></releaseAlt>
		<pushEscape public="1" set="method" line="247" static="1"><f a=""><x path="Void"/></f></pushEscape>
		<releaseEscape public="1" set="method" line="252" static="1"><f a=""><x path="Void"/></f></releaseEscape>
		<pushDelete public="1" set="method" line="257" static="1"><f a=""><x path="Void"/></f></pushDelete>
		<releaseDelete public="1" set="method" line="262" static="1"><f a=""><x path="Void"/></f></releaseDelete>
		<mouseX public="1" static="1"><x path="Int"/></mouseX>
		<mouseY public="1" static="1"><x path="Int"/></mouseY>
		<mouseDown public="1" set="method" line="270" static="1"><f a="button:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseDown>
		<mouseUp public="1" set="method" line="277" static="1"><f a="button:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseUp>
		<mouseMove public="1" set="method" line="284" static="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseMove>
		<gamepadAxis public="1" set="method" line="291" static="1"><f a="axis:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></gamepadAxis>
		<gamepadButton public="1" set="method" line="295" static="1"><f a="button:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></gamepadButton>
		<touchStart public="1" set="method" line="299" static="1"><f a="index:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></touchStart>
		<touchEnd public="1" set="method" line="303" static="1"><f a="index:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></touchEnd>
		<touchMove public="1" set="method" line="307" static="1"><f a="index:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></touchMove>
		<foreground public="1" set="method" line="311" static="1"><f a=""><x path="Void"/></f></foreground>
		<resume public="1" set="method" line="315" static="1"><f a=""><x path="Void"/></f></resume>
		<pause public="1" set="method" line="319" static="1"><f a=""><x path="Void"/></f></pause>
		<background public="1" set="method" line="323" static="1"><f a=""><x path="Void"/></f></background>
		<shutdown public="1" set="method" line="327" static="1"><f a=""><x path="Void"/></f></shutdown>
		<gameToStart><c path="kha.Game"/></gameToStart>
		<start public="1" set="method" line="54"><f a="game">
	<c path="kha.Game"/>
	<x path="Void"/>
</f></start>
		<loadFinished public="1" set="method" line="60"><f a=""><x path="Void"/></f></loadFinished>
		<new public="1" set="method" line="40"><f a="?backbufferFormat">
	<e path="kha.graphics4.TextureFormat"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.StorageFile" params="" file="Kha/Sources/kha/StorageFile.hx">
		<read public="1" set="method" line="9"><f a=""><c path="kha.Blob"/></f></read>
		<write public="1" set="method" line="10"><f a="data">
	<c path="kha.Blob"/>
	<x path="Void"/>
</f></write>
		<append public="1" set="method" line="11"><f a="data">
	<c path="kha.Blob"/>
	<x path="Void"/>
</f></append>
		<canAppend public="1" set="method" line="12"><f a=""><x path="Bool"/></f></canAppend>
		<maxSize public="1" set="method" line="13"><f a=""><x path="Int"/></f></maxSize>
		<writeString public="1" set="method" line="15"><f a="data">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<appendString public="1" set="method" line="20"><f a="data">
	<c path="String"/>
	<x path="Void"/>
</f></appendString>
		<readString public="1" set="method" line="25"><f a=""><c path="String"/></f></readString>
		<writeObject public="1" set="method" line="31"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<readObject public="1" set="method" line="35"><f a=""><d/></f></readObject>
	</class>
	<typedef path="kha.SuperString" params="" file="Kha/Sources/kha/SuperString.hx"><c path="String"/></typedef>
	<class path="kha.Sys" params="" file="Kha/Backends/Kore/kha/Sys.hx">
		<needs3d public="1" line="9" static="1"><x path="Bool"/></needs3d>
		<mouse public="1" set="null" static="1"><c path="kha.Mouse"/></mouse>
		<screenRotation public="1" line="15" static="1"><e path="kha.ScreenRotation"/></screenRotation>
		<init public="1" set="method" line="17" static="1"><f a=""><x path="Void"/></f></init>
		<getTime public="1" set="method" line="25" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t\treturn Kore::System::time();\r\n\t"</e></m></meta>
		</getTime>
		<pixelWidth public="1" get="accessor" set="null" static="1"><x path="Int"/></pixelWidth>
		<pixelHeight public="1" get="accessor" set="null" static="1"><x path="Int"/></pixelHeight>
		<get_pixelWidth public="1" set="method" line="33" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e>"return Kore::System::screenWidth();"</e></m></meta>
		</get_pixelWidth>
		<get_pixelHeight public="1" set="method" line="38" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e>"return Kore::System::screenHeight();"</e></m></meta>
		</get_pixelHeight>
		<vsynced public="1" set="method" line="42" static="1"><f a=""><x path="Bool"/></f></vsynced>
		<refreshRate public="1" set="method" line="46" static="1"><f a=""><x path="Int"/></f></refreshRate>
		<systemId public="1" set="method" line="51" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":functionCode"><e>"return ::String(Kore::System::systemId());"</e></m></meta>
		</systemId>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/System.h>\r\n"]]></e></m>
		</meta>
	</class>
	<class path="kha.Video" params="" file="Kha/Sources/kha/Video.hx">
		<extends path="kha.Media"/>
		<width public="1" set="method" line="10">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* The width of the video file in pixels.</haxe_doc>
		</width>
		<height public="1" set="method" line="14">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* The height of the video file in pixels.</haxe_doc>
		</height>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This represents a Video file.</haxe_doc>
	</class>
	<typedef path="kha.audio1.Audio" params="" file="Kha/Backends/Kore/kha/audio1/Audio.hx"><c path="kha.audio2.Audio1"/></typedef>
	<typedef path="kha.audio1.MusicChannel" params="" file="Kha/Backends/Kore/kha/audio1/MusicChannel.hx"><c path="kha.audio2.MusicChannel"/></typedef>
	<typedef path="kha.audio1.SoundChannel" params="" file="Kha/Backends/Kore/kha/audio1/SoundChannel.hx"><c path="kha.audio2.SoundChannel"/></typedef>
	<class path="kha.audio2.Audio" params="" file="Kha/Backends/Kore/kha/audio2/Audio.hx">
		<buffer static="1"><c path="kha.audio2.Buffer"/></buffer>
		<_init public="1" set="method" line="7" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_init>
		<_callCallback public="1" set="method" line="13" static="1">
			<f a="samples">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_callCallback>
		<_readSample public="1" set="method" line="29" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_readSample>
		<audioCallback public="1" static="1"><f a=":">
	<x path="Int"/>
	<c path="kha.audio2.Buffer"/>
	<x path="Void"/>
</f></audioCallback>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.Audio1" params="" file="Kha/Sources/kha/audio2/Audio1.hx">
		<channelCount get="inline" set="null" line="11" static="1"><x path="Int"/></channelCount>
		<soundChannels static="1"><x path="haxe.ds.Vector"><t path="kha.audio1.SoundChannel"/></x></soundChannels>
		<musicChannels static="1"><x path="haxe.ds.Vector"><t path="kha.audio1.MusicChannel"/></x></musicChannels>
		<_init public="1" set="method" line="19" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_init>
		<_mix set="method" line="28" static="1"><f a="samples:buffer">
	<x path="Int"/>
	<c path="kha.audio2.Buffer"/>
	<x path="Void"/>
</f></_mix>
		<playSound public="1" set="method" line="63" static="1"><f a="sound">
	<c path="kha.Sound"/>
	<t path="kha.audio1.SoundChannel"/>
</f></playSound>
		<playMusic public="1" set="method" line="81" static="1"><f a="music:?loop">
	<c path="kha.Music"/>
	<x path="Bool"/>
	<t path="kha.audio1.MusicChannel"/>
</f></playMusic>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.Buffer" params="" file="Kha/Sources/kha/audio2/Buffer.hx">
		<channels public="1"><x path="Int"/></channels>
		<samplesPerSecond public="1"><x path="Int"/></samplesPerSecond>
		<data public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></data>
		<size public="1"><x path="Int"/></size>
		<readLocation public="1"><x path="Int"/></readLocation>
		<writeLocation public="1"><x path="Int"/></writeLocation>
		<new public="1" set="method" line="14"><f a="size:channels:samplesPerSecond">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.MusicChannel" params="" file="Kha/Sources/kha/audio2/MusicChannel.hx">
		<bufferSize get="inline" set="null" line="10" static="1"><x path="Int"/></bufferSize>
		<volume public="1"><x path="Float"/></volume>
		<buffer><x path="haxe.ds.Vector"><x path="Float"/></x></buffer>
		<reader><c path="kha.audio2.ogg.vorbis.Reader"/></reader>
		<position><x path="Int"/></position>
		<count><x path="Int"/></count>
		<atend><x path="Bool"/></atend>
		<loop><x path="Bool"/></loop>
		<updateBuffer set="method" line="26"><f a=""><x path="Void"/></f></updateBuffer>
		<nextSample public="1" set="method" line="49"><f a=""><x path="Float"/></f></nextSample>
		<ended public="1" set="method" line="58"><f a=""><x path="Bool"/></f></ended>
		<new public="1" set="method" line="18"><f a="data:loop">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.SoundChannel" params="" file="Kha/Sources/kha/audio2/SoundChannel.hx">
		<data public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></data>
		<volume public="1"><x path="Float"/></volume>
		<position><x path="Int"/></position>
		<nextSample public="1" set="method" line="15"><f a=""><x path="Float"/></f></nextSample>
		<ended public="1" set="method" line="21"><f a=""><x path="Bool"/></f></ended>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.tools.Crc32" params="" file="Kha/Sources/kha/audio2/ogg/tools/Crc32.hx">
		<POLY get="inline" set="null" line="10" static="1"><x path="UInt"/></POLY>
		<table static="1"><x path="haxe.ds.Vector"><x path="UInt"/></x></table>
		<init public="1" set="method" line="13" static="1"><f a=""><x path="Void"/></f></init>
		<update public="1" get="inline" set="null" line="28" static="1"><f a="crc:byte">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
</f></update>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.tools.MathTools" params="" file="Kha/Sources/kha/audio2/ogg/tools/MathTools.hx">
		<ilog public="1" get="inline" set="null" line="9" static="1"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></ilog>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
	</class>
	<class path="kha.audio2.ogg.tools.Mdct" params="" file="Kha/Sources/kha/audio2/ogg/tools/Mdct.hx">
		<inverseTransform public="1" get="inline" set="null" line="9" static="1"><f a="buffer:n:a:b:c:bitReverse">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Void"/>
</f></inverseTransform>
		<step3Iter0Loop get="inline" set="null" line="303" static="1"><f a="n:e:i_off:k_off:a">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></step3Iter0Loop>
		<step3InnerRLoop get="inline" set="null" line="349" static="1"><f a="lim:e:d0:k_off:a:k1">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></step3InnerRLoop>
		<step3InnerSLoop get="inline" set="null" line="397" static="1"><f a="n:e:i_off:k_off:a:aOffset0:aOffset1:k0">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></step3InnerSLoop>
		<iter54 get="inline" set="null" line="445" static="1"><f a="e:zOffset">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></iter54>
		<step3InnerSLoopLd654 get="inline" set="null" line="481" static="1"><f a="n:e:i_off:a:baseN">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></step3InnerSLoopLd654>
		<haxe_doc>* modified discrete cosine transform
 * @author shohei909</haxe_doc>
	</class>
	<class path="kha.audio2.ogg.vorbis.Reader" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/Reader.hx">
		<openFromBytes public="1" set="method" line="85" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="kha.audio2.ogg.vorbis.Reader"/>
</f></openFromBytes>
		<seekBytes set="method" line="90" static="1"><f a="bytes:pos">
	<c path="haxe.io.BytesInput"/>
	<x path="Int"/>
	<x path="Void"/>
</f></seekBytes>
		<openFromFile public="1" set="method" line="95" static="1"><f a="fileName">
	<c path="String"/>
	<c path="kha.audio2.ogg.vorbis.Reader"/>
</f></openFromFile>
		<readAll public="1" set="method" line="102" static="1"><f a="bytes:output:?useFloat">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Output"/>
	<x path="Bool"/>
	<c path="kha.audio2.ogg.vorbis.data.Header"/>
</f></readAll>
		<decoder public="1" set="null"><c path="kha.audio2.ogg.vorbis.VorbisDecoder"/></decoder>
		<header public="1" get="accessor" set="null"><c path="kha.audio2.ogg.vorbis.data.Header"/></header>
		<get_header set="method" line="33"><f a=""><c path="kha.audio2.ogg.vorbis.data.Header"/></f></get_header>
		<totalSample public="1" get="accessor" set="null"><x path="Int"/></totalSample>
		<get_totalSample set="method" line="38"><f a=""><x path="Int"/></f></get_totalSample>
		<totalMillisecond public="1" get="accessor" set="null"><x path="Float"/></totalMillisecond>
		<get_totalMillisecond set="method" line="44"><f a=""><x path="Float"/></f></get_totalMillisecond>
		<currentSample public="1" get="accessor" set="accessor"><x path="Int"/></currentSample>
		<get_currentSample set="method" line="49"><f a=""><x path="Int"/></f></get_currentSample>
		<set_currentSample set="method" line="53"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_currentSample>
		<currentMillisecond public="1" get="accessor" set="accessor"><x path="Float"/></currentMillisecond>
		<get_currentMillisecond set="method" line="60"><f a=""><x path="Float"/></f></get_currentMillisecond>
		<set_currentMillisecond set="method" line="65"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_currentMillisecond>
		<loopStart public="1"><t path="Null"><x path="Int"/></t></loopStart>
		<loopLength public="1"><t path="Null"><x path="Int"/></t></loopLength>
		<seekFunc><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></seekFunc>
		<inputLength><x path="Int"/></inputLength>
		<read public="1" set="method" line="116"><f a="output:?samples:?channels:?sampleRate:?useFloat">
	<c path="haxe.io.Output"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></read>
		<clone public="1" set="method" line="131"><f a=""><c path="kha.audio2.ogg.vorbis.Reader"/></f></clone>
		<sampleToMillisecond public="1" get="inline" set="null" line="142"><f a="samples">
	<x path="Int"/>
	<x path="Float"/>
</f></sampleToMillisecond>
		<millisecondToSample public="1" get="inline" set="null" line="146"><f a="millseconds">
	<x path="Float"/>
	<x path="Int"/>
</f></millisecondToSample>
		<new set="method" line="76"><f a="input:seekFunc:inputLength">
	<c path="haxe.io.Input"/>
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* public domain ogg reader.
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="kha.audio2.ogg.vorbis._Reader.InitData" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/Reader.hx" private="1" module="kha.audio2.ogg.vorbis.Reader"><a>
	<seekFunc><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></seekFunc>
	<inputLength><x path="Int"/></inputLength>
	<input><c path="haxe.io.Input"/></input>
</a></typedef>
	<class path="kha.audio2.ogg.vorbis.VorbisDecodeState" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecodeState.hx">
		<INVALID_BITS public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></INVALID_BITS>
		<page public="1" set="null"><c path="kha.audio2.ogg.vorbis.data.Page"/></page>
		<eof public="1" set="null"><x path="Bool"/></eof>
		<pFirst public="1" set="null"><c path="kha.audio2.ogg.vorbis.data.ProbedPage"/></pFirst>
		<pLast public="1" set="null"><c path="kha.audio2.ogg.vorbis.data.ProbedPage"/></pLast>
		<validBits public="1" set="null"><x path="Int"/></validBits>
		<inputPosition public="1" set="null"><x path="Int"/></inputPosition>
		<input public="1" set="null"><c path="haxe.io.Input"/></input>
		<discardSamplesDeferred public="1"><x path="Int"/></discardSamplesDeferred>
		<segments public="1" set="null"><x path="haxe.ds.Vector"><x path="Int"/></x></segments>
		<bytesInSeg public="1"><x path="Int"/></bytesInSeg>
		<channelBuffers public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></channelBuffers>
		<channelBufferStart public="1"><x path="Int"/></channelBufferStart>
		<channelBufferEnd public="1"><x path="Int"/></channelBufferEnd>
		<currentSample public="1" set="null"><x path="Int"/></currentSample>
		<previousWindow public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></previousWindow>
		<previousLength public="1"><x path="Int"/></previousLength>
		<finalY public="1"><x path="haxe.ds.Vector"><c path="Array"><x path="Int"/></c></x></finalY>
		<firstDecode><x path="Bool"/></firstDecode>
		<nextSeg><x path="Int"/></nextSeg>
		<acc><x path="UInt"/></acc>
		<lastSeg><x path="Bool"/></lastSeg>
		<lastSegWhich><x path="Int"/></lastSegWhich>
		<endSegWithKnownLoc><x path="Int"/></endSegWithKnownLoc>
		<knownLocForPacket><x path="Int"/></knownLocForPacket>
		<error><c path="kha.audio2.ogg.vorbis.data.ReaderError"/></error>
		<currentLoc><x path="Int"/></currentLoc>
		<currentLocValid><x path="Int"/></currentLocValid>
		<firstAudioPageOffset><x path="UInt"/></firstAudioPageOffset>
		<setup public="1" set="method" line="78"><f a="loc0:loc1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setup>
		<clone public="1" set="method" line="118"><f a="seekFunc">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
</f></clone>
		<next public="1" set="method" line="154"><f a=""><x path="Int"/></f></next>
		<startPacket public="1" set="method" line="189"><f a=""><x path="Void"/></f></startPacket>
		<maybeStartPacket public="1" set="method" line="202"><f a=""><x path="Bool"/></f></maybeStartPacket>
		<readBits public="1" get="inline" set="null" line="230"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></readBits>
		<readPacketRaw get="inline" set="null" line="270"><f a=""><x path="Int"/></f></readPacketRaw>
		<readPacket public="1" get="inline" set="null" line="280"><f a=""><x path="Int"/></f></readPacket>
		<flushPacket public="1" get="inline" set="null" line="287"><f a=""><x path="Void"/></f></flushPacket>
		<vorbisValidate public="1" get="inline" set="null" line="294"><f a=""><x path="Void"/></f></vorbisValidate>
		<firstPageValidate public="1" set="method" line="304"><f a=""><x path="Void"/></f></firstPageValidate>
		<startFirstDecode public="1" set="method" line="314"><f a=""><x path="Void"/></f></startFirstDecode>
		<capturePattern public="1" get="inline" set="null" line="320"><f a=""><x path="Void"/></f></capturePattern>
		<skip get="inline" set="null" line="327"><f a="len">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<prepHuffman set="method" line="332"><f a=""><x path="Void"/></f></prepHuffman>
		<decode public="1" get="inline" set="null" line="350"><f a="c">
	<c path="kha.audio2.ogg.vorbis.data.Codebook"/>
	<x path="Int"/>
</f></decode>
		<decodeRaw public="1" get="inline" set="null" line="358"><f a="c">
	<c path="kha.audio2.ogg.vorbis.data.Codebook"/>
	<x path="Int"/>
</f></decodeRaw>
		<isLastByte public="1" get="inline" set="null" line="382"><f a=""><x path="Bool"/></f></isLastByte>
		<finishDecodePacket public="1" set="method" line="387"><f a="previousLength:n:r">
	<x path="Int"/>
	<x path="Int"/>
	<t path="kha.audio2.ogg.vorbis.DecodeInitialResult"/>
	<a>
		<right><x path="Int"/></right>
		<len><x path="Int"/></len>
		<left><x path="Int"/></left>
	</a>
</f></finishDecodePacket>
		<readInt32 public="1" get="inline" set="null" line="462"><f a=""><x path="Int"/></f></readInt32>
		<readByte public="1" get="inline" set="null" line="468"><f a=""><x path="Int"/></f></readByte>
		<read public="1" get="inline" set="null" line="474"><f a="n">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></read>
		<readBytes public="1" get="inline" set="null" line="483"><f a="n">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readBytes>
		<readString public="1" get="inline" set="null" line="488"><f a="n">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<getSampleNumber public="1" set="method" line="494"><f a="seekFunc:inputLength">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="UInt"/>
	<x path="Int"/>
</f></getSampleNumber>
		<forcePageResync public="1" get="inline" set="null" line="566"><f a=""><x path="Void"/></f></forcePageResync>
		<setInputOffset public="1" get="inline" set="null" line="571"><f a="seekFunc:n">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></setInputOffset>
		<findPage public="1" set="method" line="576"><f a="seekFunc:inputLength">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<e path="kha.audio2.ogg.vorbis._VorbisDecodeState.FindPageResult"/>
</f></findPage>
		<analyzePage public="1" set="method" line="650"><f a="seekFunc:h">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<c path="kha.audio2.ogg.vorbis.data.Header"/>
	<c path="kha.audio2.ogg.vorbis.data.ProbedPage"/>
</f></analyzePage>
		<decodeScalarRaw set="method" line="783"><f a="c">
	<c path="kha.audio2.ogg.vorbis.data.Codebook"/>
	<x path="Int"/>
</f></decodeScalarRaw>
		<new public="1" set="method" line="70"><f a="input">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.audio2.ogg.vorbis._VorbisDecodeState.FindPageResult" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecodeState.hx" private="1" module="kha.audio2.ogg.vorbis.VorbisDecodeState">
		<Found a="end:last">
			<x path="Int"/>
			<x path="Bool"/>
		</Found>
		<NotFound/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="kha.audio2.ogg.vorbis.VorbisDecoder" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecoder.hx">
		<start public="1" set="method" line="72" static="1"><f a="input">
	<c path="haxe.io.Input"/>
	<c path="kha.audio2.ogg.vorbis.VorbisDecoder"/>
</f></start>
		<previousWindow><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></previousWindow>
		<previousLength><x path="Int"/></previousLength>
		<finalY><x path="haxe.ds.Vector"><c path="Array"><x path="Int"/></c></x></finalY>
		<a><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></a>
		<b><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></b>
		<c><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></c>
		<window><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></window>
		<bitReverseData><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></bitReverseData>
		<channelBuffers><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></channelBuffers>
		<channelBufferStart><x path="Int"/></channelBufferStart>
		<channelBufferEnd><x path="Int"/></channelBufferEnd>
		<header public="1" set="null"><c path="kha.audio2.ogg.vorbis.data.Header"/></header>
		<currentSample public="1" set="null"><x path="Int"/></currentSample>
		<totalSample public="1" set="null"><t path="Null"><x path="Int"/></t></totalSample>
		<decodeState><c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/></decodeState>
		<read public="1" set="method" line="82"><f a="output:samples:channels:sampleRate:useFloat">
	<c path="haxe.io.Output"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></read>
		<skipSamples public="1" set="method" line="147"><f a="len">
	<x path="Int"/>
	<x path="Int"/>
</f></skipSamples>
		<setupSampleNumber public="1" set="method" line="166"><f a="seekFunc:inputLength">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></setupSampleNumber>
		<seek public="1" set="method" line="173"><f a="seekFunc:inputLength:sampleNumber">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Void"/>
</f></seek>
		<seekFrameFromPage public="1" set="method" line="275"><f a="seekFunc:pageStart:firstSample:targetSample">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></seekFrameFromPage>
		<clone public="1" set="method" line="338"><f a="seekFunc">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<c path="kha.audio2.ogg.vorbis.VorbisDecoder"/>
</f></clone>
		<ensurePosition public="1" set="method" line="370"><f a="seekFunc">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensurePosition>
		<getFrameFloat set="method" line="374"><f a=""><x path="Int"/></f></getFrameFloat>
		<pumpFirstFrame set="method" line="389"><f a=""><x path="Void"/></f></pumpFirstFrame>
		<finishFrame set="method" line="393"><f a="r">
	<t path="kha.audio2.ogg.vorbis.DecodePacketResult"/>
	<x path="Int"/>
</f></finishFrame>
		<getWindow set="method" line="453"><f a="len">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
</f></getWindow>
		<initBlocksize set="method" line="466"><f a="bs:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></initBlocksize>
		<inverseMdct set="method" line="480"><f a="buffer:n:blocktype">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></inverseMdct>
		<decodePacket set="method" line="485"><f a=""><t path="kha.audio2.ogg.vorbis.DecodePacketResult"/></f></decodePacket>
		<decodeInitial set="method" line="495"><f a=""><t path="kha.audio2.ogg.vorbis.DecodeInitialResult"/></f></decodeInitial>
		<decodePacketRest set="method" line="552"><f a="r">
	<t path="kha.audio2.ogg.vorbis.DecodeInitialResult"/>
	<t path="kha.audio2.ogg.vorbis.DecodePacketResult"/>
</f></decodePacketRest>
		<new set="method" line="44"><f a="header:decodeState">
	<c path="kha.audio2.ogg.vorbis.data.Header"/>
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="kha.audio2.ogg.vorbis.DecodePacketResult" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecoder.hx" module="kha.audio2.ogg.vorbis.VorbisDecoder"><a>
	<right><x path="Int"/></right>
	<len><x path="Int"/></len>
	<left><x path="Int"/></left>
</a></typedef>
	<typedef path="kha.audio2.ogg.vorbis.DecodeInitialResult" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecoder.hx" module="kha.audio2.ogg.vorbis.VorbisDecoder"><a>
	<right><t path="kha.audio2.ogg.vorbis._VorbisDecoder.Range"/></right>
	<mode><x path="Int"/></mode>
	<left><t path="kha.audio2.ogg.vorbis._VorbisDecoder.Range"/></left>
</a></typedef>
	<typedef path="kha.audio2.ogg.vorbis._VorbisDecoder.Range" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecoder.hx" private="1" module="kha.audio2.ogg.vorbis.VorbisDecoder"><a>
	<start><x path="Int"/></start>
	<end><x path="Int"/></end>
</a></typedef>
	<class path="kha.audio2.ogg.vorbis.VorbisTools" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisTools.hx">
		<EOP public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></EOP>
		<integerDivideTable public="1" static="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></integerDivideTable>
		<M__PI get="inline" set="null" line="18" static="1"><x path="Float"/></M__PI>
		<DIVTAB_NUMER get="inline" set="null" line="20" static="1"><x path="Int"/></DIVTAB_NUMER>
		<DIVTAB_DENOM get="inline" set="null" line="21" static="1"><x path="Int"/></DIVTAB_DENOM>
		<INVERSE_DB_TABLE public="1" line="23" static="1"><c path="Array"><x path="Float"/></c></INVERSE_DB_TABLE>
		<assert public="1" get="inline" set="null" line="90" static="1"><f a="b:?p">
	<x path="Bool"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></assert>
		<neighbors public="1" get="inline" set="null" line="98" static="1"><f a="x:n">
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Int"/>
	<a>
		<low><x path="Int"/></low>
		<high><x path="Int"/></high>
	</a>
</f></neighbors>
		<floatUnpack public="1" get="inline" set="null" line="115" static="1"><f a="x">
	<x path="UInt"/>
	<x path="Float"/>
</f></floatUnpack>
		<bitReverse public="1" get="inline" set="null" line="125" static="1"><f a="n">
	<x path="UInt"/>
	<x path="UInt"/>
</f></bitReverse>
		<pointCompare public="1" get="inline" set="null" line="134" static="1"><f a="a:b">
	<c path="kha.audio2.ogg.vorbis.data.IntPoint"/>
	<c path="kha.audio2.ogg.vorbis.data.IntPoint"/>
	<x path="Int"/>
</f></pointCompare>
		<uintAsc public="1" set="method" line="138" static="1"><f a="a:b">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Int"/>
</f></uintAsc>
		<lookup1Values public="1" set="method" line="148" static="1"><f a="entries:dim">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lookup1Values>
		<computeWindow public="1" set="method" line="160" static="1"><f a="n:window">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></computeWindow>
		<square public="1" set="method" line="168" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></square>
		<computeBitReverse public="1" set="method" line="172" static="1"><f a="n:rev">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Void"/>
</f></computeBitReverse>
		<computeTwiddleFactors public="1" set="method" line="182" static="1"><f a="n:af:bf:cf">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></computeTwiddleFactors>
		<drawLine public="1" set="method" line="205" static="1"><f a="output:x0:y0:x1:y1:n">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawLine>
		<predictPoint public="1" get="inline" set="null" line="264" static="1"><f a="x:x0:x1:y0:y1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></predictPoint>
		<emptyFloatVector public="1" get="inline" set="null" line="274" static="1"><f a="len">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
</f></emptyFloatVector>
		<copyVector public="1" set="method" line="284" static="1"><f a="source">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
</f></copyVector>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Codebook" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Codebook.hx">
		<NO_CODE public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></NO_CODE>
		<read public="1" set="method" line="37" static="1"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<c path="kha.audio2.ogg.vorbis.data.Codebook"/>
</f></read>
		<delay line="480" static="1"><x path="Int"/></delay>
		<dimensions public="1"><x path="Int"/></dimensions>
		<entries public="1"><x path="Int"/></entries>
		<codewordLengths public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></codewordLengths>
		<minimumValue public="1"><x path="Float"/></minimumValue>
		<deltaValue public="1"><x path="Float"/></deltaValue>
		<valueBits public="1"><x path="Int"/></valueBits>
		<lookupType public="1"><x path="Int"/></lookupType>
		<sequenceP public="1"><x path="Bool"/></sequenceP>
		<sparse public="1"><x path="Bool"/></sparse>
		<lookupValues public="1"><x path="UInt"/></lookupValues>
		<multiplicands public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></multiplicands>
		<codewords public="1"><x path="haxe.ds.Vector"><x path="UInt"/></x></codewords>
		<fastHuffman public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></fastHuffman>
		<sortedCodewords public="1"><c path="Array"><x path="UInt"/></c></sortedCodewords>
		<sortedValues public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></sortedValues>
		<sortedEntries public="1"><x path="Int"/></sortedEntries>
		<addEntry get="inline" set="null" line="187"><f a="huffCode:symbol:count:len:values">
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="UInt"/></x>
	<x path="Void"/>
</f></addEntry>
		<includeInSort get="inline" set="null" line="198"><f a="len">
	<x path="Int"/>
	<x path="Bool"/>
</f></includeInSort>
		<computeCodewords set="method" line="213"><f a="len:n:values">
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="UInt"/></x>
	<x path="Bool"/>
</f></computeCodewords>
		<computeSortedHuffman set="method" line="283"><f a="lengths:values">
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="haxe.ds.Vector"><x path="UInt"/></x>
	<x path="Void"/>
</f></computeSortedHuffman>
		<computeAcceleratedHuffman set="method" line="340"><f a=""><x path="Void"/></f></computeAcceleratedHuffman>
		<codebookDecode set="method" line="366"><f a="decodeState:output:offset:len">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></codebookDecode>
		<codebookDecodeStep set="method" line="414"><f a="decodeState:output:offset:len:step">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></codebookDecodeStep>
		<decodeStart get="inline" set="null" line="457"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="Int"/>
</f></decodeStart>
		<decodeDeinterleaveRepeat public="1" set="method" line="482"><f a="decodeState:residueBuffers:ch:cInter:pInter:len:totalDecode">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<a>
		<pInter><x path="Int"/></pInter>
		<cInter><x path="Int"/></cInter>
	</a>
</f></decodeDeinterleaveRepeat>
		<residueDecode public="1" set="method" line="573"><f a="decodeState:target:offset:n:rtype">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></residueDecode>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Comment" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Comment.hx">
		<data public="1" set="null"><x path="Map">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</x></data>
		<title public="1" get="accessor" set="null"><c path="String"/></title>
		<get_title set="method" line="11"><f a=""><t path="Null"><c path="String"/></t></f></get_title>
		<loopStart public="1" get="accessor" set="null"><t path="Null"><x path="Int"/></t></loopStart>
		<get_loopStart set="method" line="16"><f a=""><t path="Null"><x path="Int"/></t></f></get_loopStart>
		<loopLength public="1" get="accessor" set="null"><t path="Null"><x path="Int"/></t></loopLength>
		<get_loopLength set="method" line="21"><f a=""><t path="Null"><x path="Int"/></t></f></get_loopLength>
		<version public="1" get="accessor" set="null"><c path="String"/></version>
		<get_version set="method" line="26"><f a=""><t path="Null"><c path="String"/></t></f></get_version>
		<album public="1" get="accessor" set="null"><c path="String"/></album>
		<get_album set="method" line="31"><f a=""><t path="Null"><c path="String"/></t></f></get_album>
		<organization public="1" get="accessor" set="null"><c path="String"/></organization>
		<get_organization set="method" line="36"><f a=""><t path="Null"><c path="String"/></t></f></get_organization>
		<tracknumber public="1" get="accessor" set="null"><c path="String"/></tracknumber>
		<get_tracknumber set="method" line="41"><f a=""><t path="Null"><c path="String"/></t></f></get_tracknumber>
		<performer public="1" get="accessor" set="null"><c path="String"/></performer>
		<get_performer set="method" line="46"><f a=""><t path="Null"><c path="String"/></t></f></get_performer>
		<copyright public="1" get="accessor" set="null"><c path="String"/></copyright>
		<get_copyright set="method" line="51"><f a=""><t path="Null"><c path="String"/></t></f></get_copyright>
		<license public="1" get="accessor" set="null"><c path="String"/></license>
		<get_license set="method" line="56"><f a=""><t path="Null"><c path="String"/></t></f></get_license>
		<artist public="1" get="accessor" set="null"><c path="String"/></artist>
		<get_artist set="method" line="61"><f a=""><t path="Null"><c path="String"/></t></f></get_artist>
		<description public="1" get="accessor" set="null"><c path="String"/></description>
		<get_description set="method" line="66"><f a=""><t path="Null"><c path="String"/></t></f></get_description>
		<genre public="1" get="accessor" set="null"><c path="String"/></genre>
		<get_genre set="method" line="71"><f a=""><t path="Null"><c path="String"/></t></f></get_genre>
		<date public="1" get="accessor" set="null"><c path="String"/></date>
		<get_date set="method" line="76"><f a=""><t path="Null"><c path="String"/></t></f></get_date>
		<location public="1" get="accessor" set="null"><c path="String"/></location>
		<get_location set="method" line="81"><f a=""><t path="Null"><c path="String"/></t></f></get_location>
		<contact public="1" get="accessor" set="null"><c path="String"/></contact>
		<get_contact set="method" line="86"><f a=""><t path="Null"><c path="String"/></t></f></get_contact>
		<isrc public="1" get="accessor" set="null"><c path="String"/></isrc>
		<get_isrc set="method" line="91"><f a=""><t path="Null"><c path="String"/></t></f></get_isrc>
		<artists public="1" get="accessor" set="null"><c path="Array"><c path="String"/></c></artists>
		<get_artists set="method" line="96"><f a=""><t path="Null"><t path="Null"><c path="Array"><c path="String"/></c></t></t></f></get_artists>
		<add public="1" set="method" line="104"><f a="key:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></add>
		<getString public="1" set="method" line="113"><f a="key">
	<c path="String"/>
	<t path="Null"><c path="String"/></t>
</f></getString>
		<getArray public="1" set="method" line="122"><f a="key">
	<c path="String"/>
	<t path="Null"><t path="Null"><c path="Array"><c path="String"/></c></t></t>
</f></getArray>
		<new public="1" set="method" line="100"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Floor" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Floor.hx">
		<read public="1" set="method" line="22" static="1"><f a="decodeState:codebooks">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Codebook"/></x>
	<c path="kha.audio2.ogg.vorbis.data.Floor"/>
</f></read>
		<floor0 public="1"><c path="kha.audio2.ogg.vorbis.data.Floor0"/></floor0>
		<floor1 public="1"><c path="kha.audio2.ogg.vorbis.data.Floor1"/></floor1>
		<type public="1"><x path="Int"/></type>
		<new set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Floor0" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Floor.hx" module="kha.audio2.ogg.vorbis.data.Floor">
		<order public="1"><x path="Int"/></order>
		<rate public="1"><x path="Int"/></rate>
		<barkMapSize public="1"><x path="Int"/></barkMapSize>
		<amplitudeBits public="1"><x path="Int"/></amplitudeBits>
		<amplitudeOffset public="1"><x path="Int"/></amplitudeOffset>
		<numberOfBooks public="1"><x path="Int"/></numberOfBooks>
		<bookList public="1"><x path="haxe.ds.Vector"><x path="UInt"/></x></bookList>
		<new public="1" set="method" line="130"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Floor1" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Floor.hx" module="kha.audio2.ogg.vorbis.data.Floor">
		<partitions public="1"><x path="Int"/></partitions>
		<partitionClassList public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></partitionClassList>
		<classDimensions public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></classDimensions>
		<classSubclasses public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></classSubclasses>
		<classMasterbooks public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></classMasterbooks>
		<subclassBooks public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></subclassBooks>
		<xlist public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></xlist>
		<sortedOrder public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></sortedOrder>
		<neighbors public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></neighbors>
		<floor1Multiplier public="1"><x path="Int"/></floor1Multiplier>
		<rangebits public="1"><x path="Int"/></rangebits>
		<values public="1"><x path="Int"/></values>
		<new public="1" set="method" line="149"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Header" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Header.hx">
		<PACKET_ID public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></PACKET_ID>
		<PACKET_COMMENT public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></PACKET_COMMENT>
		<PACKET_SETUP public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></PACKET_SETUP>
		<read public="1" set="method" line="41" static="1"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<c path="kha.audio2.ogg.vorbis.data.Header"/>
</f></read>
		<maximumBitRate public="1" set="null"><x path="UInt"/></maximumBitRate>
		<nominalBitRate public="1" set="null"><x path="UInt"/></nominalBitRate>
		<minimumBitRate public="1" set="null"><x path="UInt"/></minimumBitRate>
		<sampleRate public="1" set="null"><x path="UInt"/></sampleRate>
		<channel public="1" set="null"><x path="Int"/></channel>
		<blocksize0 public="1" set="null"><x path="Int"/></blocksize0>
		<blocksize1 public="1" set="null"><x path="Int"/></blocksize1>
		<codebooks public="1" set="null"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Codebook"/></x></codebooks>
		<floorConfig public="1" set="null"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Floor"/></x></floorConfig>
		<residueConfig public="1" set="null"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Residue"/></x></residueConfig>
		<mapping public="1" set="null"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Mapping"/></x></mapping>
		<modes public="1" set="null"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Mode"/></x></modes>
		<comment public="1" set="null"><c path="kha.audio2.ogg.vorbis.data.Comment"/></comment>
		<vendor public="1" set="null"><c path="String"/></vendor>
		<new set="method" line="37"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.IntPoint" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/IntPoint.hx">
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Mapping" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Mapping.hx">
		<read public="1" set="method" line="17" static="1"><f a="decodeState:channels">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="Int"/>
	<c path="kha.audio2.ogg.vorbis.data.Mapping"/>
</f></read>
		<couplingSteps public="1"><x path="Int"/></couplingSteps>
		<chan public="1"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.MappingChannel"/></x></chan>
		<submaps public="1"><x path="Int"/></submaps>
		<submapFloor public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></submapFloor>
		<submapResidue public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></submapResidue>
		<doFloor public="1" set="method" line="88"><f a="floors:i:n:target:finalY:step2Flag">
	<x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Floor"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<c path="Array"><x path="Int"/></c>
	<x path="haxe.ds.Vector"><x path="Bool"/></x>
	<x path="Void"/>
</f></doFloor>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.MappingChannel" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Mapping.hx" module="kha.audio2.ogg.vorbis.data.Mapping">
		<magnitude public="1"><x path="Int"/></magnitude>
		<angle public="1"><x path="Int"/></angle>
		<mux public="1"><x path="Int"/></mux>
		<new public="1" set="method" line="125"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Mode" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Mode.hx">
		<read public="1" set="method" line="15" static="1"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<c path="kha.audio2.ogg.vorbis.data.Mode"/>
</f></read>
		<blockflag public="1"><x path="Bool"/></blockflag>
		<mapping public="1"><x path="Int"/></mapping>
		<windowtype public="1"><x path="Int"/></windowtype>
		<transformtype public="1"><x path="Int"/></transformtype>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Page" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Page.hx">
		<flag public="1" set="null"><x path="Int"/></flag>
		<clone public="1" set="method" line="18"><f a=""><c path="kha.audio2.ogg.vorbis.data.Page"/></f></clone>
		<start public="1" set="method" line="25"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="Void"/>
</f></start>
		<startWithoutCapturePattern public="1" set="method" line="31"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="Void"/>
</f></startWithoutCapturePattern>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.PageFlag" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Page.hx" module="kha.audio2.ogg.vorbis.data.Page">
		<CONTINUED_PACKET public="1" get="inline" set="null" line="57" static="1"><x path="Int"/></CONTINUED_PACKET>
		<FIRST_PAGE public="1" get="inline" set="null" line="58" static="1"><x path="Int"/></FIRST_PAGE>
		<LAST_PAGE public="1" get="inline" set="null" line="59" static="1"><x path="Int"/></LAST_PAGE>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.ProbedPage" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/ProbedPage.hx">
		<pageStart public="1"><x path="Int"/></pageStart>
		<pageEnd public="1"><x path="Int"/></pageEnd>
		<afterPreviousPageStart public="1"><x path="Int"/></afterPreviousPageStart>
		<firstDecodedSample public="1"><t path="Null"><x path="Int"/></t></firstDecodedSample>
		<lastDecodedSample public="1"><t path="Null"><x path="Int"/></t></lastDecodedSample>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.ReaderError" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/ReaderError.hx">
		<type public="1" set="null"><e path="kha.audio2.ogg.vorbis.data.ReaderErrorType"/></type>
		<message public="1" set="null"><c path="String"/></message>
		<posInfos public="1" set="null"><t path="haxe.PosInfos"/></posInfos>
		<new public="1" set="method" line="14"><f a="type:?message:?posInfos">
	<e path="kha.audio2.ogg.vorbis.data.ReaderErrorType"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.audio2.ogg.vorbis.data.ReaderErrorType" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/ReaderError.hx" module="kha.audio2.ogg.vorbis.data.ReaderError">
		<NEED_MORE_DATA/>
		<INVALID_API_MIXING/>
		<OUTOFMEM/>
		<FEATURE_NOT_SUPPORTED/>
		<TOO_MANY_CHANNELS/>
		<FILE_OPEN_FAILURE/>
		<SEEK_WITHOUT_LENGTH/>
		<UNEXPECTED_EOF/>
		<SEEK_INVALID/>
		<INVALID_SETUP/>
		<INVALID_STREAM/>
		<MISSING_CAPTURE_PATTERN/>
		<INVALID_STREAM_STRUCTURE_VERSION/>
		<CONTINUED_PACKET_FLAG_INVALID/>
		<INCORRECT_STREAM_SERIAL_NUMBER/>
		<INVALID_FIRST_PAGE/>
		<BAD_PACKET_TYPE/>
		<CANT_FIND_LAST_PAGE/>
		<SEEK_FAILED/>
		<OTHER/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.audio2.ogg.vorbis.data.Residue" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Residue.hx">
		<read public="1" set="method" line="24" static="1"><f a="decodeState:codebooks">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Codebook"/></x>
	<c path="kha.audio2.ogg.vorbis.data.Residue"/>
</f></read>
		<begin public="1" set="null"><x path="UInt"/></begin>
		<end public="1" set="null"><x path="UInt"/></end>
		<partSize public="1" set="null"><x path="UInt"/></partSize>
		<classifications public="1" set="null"><x path="Int"/></classifications>
		<classbook public="1" set="null"><x path="Int"/></classbook>
		<classdata public="1" set="null"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></classdata>
		<residueBooks public="1" set="null"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></residueBooks>
		<type public="1" set="null"><x path="Int"/></type>
		<decode public="1" set="method" line="83"><f a="decodeState:header:residueBuffers:ch:n:doNotDecode:channelBuffers">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<c path="kha.audio2.ogg.vorbis.data.Header"/>
	<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Bool"/></x>
	<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x>
	<x path="Void"/>
</f></decode>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Setting" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Setting.hx">
		<MAX_CHANNELS public="1" get="inline" set="null" line="9" static="1"><x path="Int"/></MAX_CHANNELS>
		<PUSHDATA_CRC_COUNT public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></PUSHDATA_CRC_COUNT>
		<FAST_HUFFMAN_LENGTH public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></FAST_HUFFMAN_LENGTH>
		<FAST_HUFFMAN_TABLE_SIZE public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></FAST_HUFFMAN_TABLE_SIZE>
		<FAST_HUFFMAN_TABLE_MASK public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></FAST_HUFFMAN_TABLE_MASK>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
	</class>
	<class path="kha.graphics1.Graphics" params="" file="Kha/Sources/kha/graphics1/Graphics.hx" interface="1">
		<begin public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Begin the graphic operations.
	 * You MUST call this.</haxe_doc>
		</begin>
		<end public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Terminate all graphical operations and apply them.
	 * You MUST call this at the end.</haxe_doc>
		</end>
		<setPixel public="1" set="method">
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="kha.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the pixel color in a specific position.</haxe_doc>
		</setPixel>
		<haxe_doc><![CDATA[* Basic graphical interface.<br>
 * Represent old devices with only pixel pushing operations.]]></haxe_doc>
	</class>
	<class path="kha.graphics2.Graphics" params="" file="Kha/Sources/kha/graphics2/Graphics.hx">
		<begin public="1" set="method" line="10"><f a="?clear:?clearColor">
	<x path="Bool"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></begin>
		<end public="1" set="method" line="11"><f a=""><x path="Void"/></f></end>
		<clear public="1" set="method" line="16"><f a="?color">
	<x path="kha.Color"/>
	<x path="Void"/>
</f></clear>
		<drawImage public="1" set="method" line="17"><f a="img:x:y">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawImage>
		<drawSubImage public="1" set="method" line="20"><f a="img:x:y:sx:sy:sw:sh">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawSubImage>
		<drawScaledImage public="1" set="method" line="23"><f a="img:dx:dy:dw:dh">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawScaledImage>
		<drawScaledSubImage public="1" set="method" line="26"><f a="image:sx:sy:sw:sh:dx:dy:dw:dh">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawScaledSubImage>
		<drawRect public="1" set="method" line="27"><f a="x:y:width:height:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<fillRect public="1" set="method" line="28"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<drawString public="1" set="method" line="29"><f a="text:x:y">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawString>
		<drawLine public="1" set="method" line="30"><f a="x1:y1:x2:y2:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawLine>
		<drawVideo public="1" set="method" line="31"><f a="video:x:y:width:height">
	<c path="kha.Video"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawVideo>
		<fillTriangle public="1" set="method" line="32"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillTriangle>
		<color public="1" get="accessor" set="accessor"><x path="kha.Color"/></color>
		<font public="1" get="accessor" set="accessor"><c path="kha.Font"/></font>
		<get_color public="1" set="method" line="37"><f a=""><x path="kha.Color"/></f></get_color>
		<set_color public="1" set="method" line="41"><f a="color">
	<x path="kha.Color"/>
	<x path="kha.Color"/>
</f></set_color>
		<get_font public="1" set="method" line="45"><f a=""><c path="kha.Font"/></f></get_font>
		<set_font public="1" set="method" line="49"><f a="font">
	<c path="kha.Font"/>
	<c path="kha.Font"/>
</f></set_font>
		<transformation public="1" get="accessor" set="accessor"><c path="kha.math.Matrix3"/></transformation>
		<pushTransformation public="1" set="method" line="55"><f a="transformation">
	<c path="kha.math.Matrix3"/>
	<x path="Void"/>
</f></pushTransformation>
		<popTransformation public="1" set="method" line="60"><f a=""><c path="kha.math.Matrix3"/></f></popTransformation>
		<get_transformation public="1" set="method" line="66"><f a=""><c path="kha.math.Matrix3"/></f></get_transformation>
		<set_transformation public="1" set="method" line="70"><f a="transformation">
	<c path="kha.math.Matrix3"/>
	<c path="kha.math.Matrix3"/>
</f></set_transformation>
		<translation get="inline" set="null" line="75"><f a="tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></translation>
		<translate public="1" set="method" line="79"><f a="tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<pushTranslation public="1" set="method" line="83"><f a="tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pushTranslation>
		<rotation get="inline" set="null" line="87"><f a="angle:centerx:centery">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></rotation>
		<rotate public="1" set="method" line="91"><f a="angle:centerx:centery">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<pushRotation public="1" set="method" line="95"><f a="angle:centerx:centery">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pushRotation>
		<opacity public="1" get="accessor" set="accessor"><x path="Float"/></opacity>
		<pushOpacity public="1" set="method" line="101"><f a="opacity">
	<x path="Float"/>
	<x path="Void"/>
</f></pushOpacity>
		<popOpacity public="1" set="method" line="106"><f a=""><x path="Float"/></f></popOpacity>
		<get_opacity public="1" set="method" line="112"><f a=""><x path="Float"/></f></get_opacity>
		<set_opacity public="1" set="method" line="116"><f a="opacity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_opacity>
		<prog><c path="kha.graphics4.Program"/></prog>
		<program public="1" get="accessor" set="accessor"><c path="kha.graphics4.Program"/></program>
		<get_program set="method" line="128"><f a=""><c path="kha.graphics4.Program"/></f></get_program>
		<set_program set="method" line="132"><f a="program">
	<c path="kha.graphics4.Program"/>
	<c path="kha.graphics4.Program"/>
</f></set_program>
		<setBlendingMode public="1" set="method" line="139"><f a="source:destination">
	<e path="kha.graphics4.BlendingOperation"/>
	<e path="kha.graphics4.BlendingOperation"/>
	<x path="Void"/>
</f></setBlendingMode>
		<transformations><c path="Array"><c path="kha.math.Matrix3"/></c></transformations>
		<opacities><c path="Array"><x path="Float"/></c></opacities>
		<setTransformation set="method" line="158"><f a="transformation">
	<c path="kha.math.Matrix3"/>
	<x path="Void"/>
</f></setTransformation>
		<setOpacity set="method" line="162"><f a="opacity">
	<x path="Float"/>
	<x path="Void"/>
</f></setOpacity>
		<setProgram set="method" line="166"><f a="program">
	<c path="kha.graphics4.Program"/>
	<x path="Void"/>
</f></setProgram>
		<new public="1" set="method" line="146"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="kha.graphics2.Graphics1" params="" file="Kha/Sources/kha/graphics2/Graphics1.hx">
		<implements path="kha.graphics1.Graphics"/>
		<canvas><c path="kha.Canvas"/></canvas>
		<texture><c path="kha.Image"/></texture>
		<pixels><c path="haxe.io.Bytes"/></pixels>
		<begin public="1" set="method" line="17"><f a=""><x path="Void"/></f></begin>
		<end public="1" set="method" line="24"><f a=""><x path="Void"/></f></end>
		<setPixel public="1" set="method" line="31"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></setPixel>
		<new public="1" set="method" line="13"><f a="canvas">
	<c path="kha.Canvas"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.graphics4.BlendingOperation" params="" file="Kha/Sources/kha/graphics4/BlendingOperation.hx">
		<Undefined/>
		<BlendOne/>
		<BlendZero/>
		<SourceAlpha/>
		<DestinationAlpha/>
		<InverseSourceAlpha/>
		<InverseDestinationAlpha/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="kha.graphics4.CompareMode" params="" file="Kha/Sources/kha/graphics4/CompareMode.hx">
		<Always/>
		<Never/>
		<Equal/>
		<NotEqual/>
		<Less/>
		<LessEqual/>
		<Greater/>
		<GreaterEqual/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="kha.graphics4.ConstantLocation" params="" file="Kha/Sources/kha/graphics4/ConstantLocation.hx" interface="1"/>
	<class path="kha.graphics4.CubeMap" params="" file="Kha/Sources/kha/graphics4/CubeMap.hx" interface="1">
		<get_size public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_size>
		<size public="1" get="accessor" set="null"><x path="Int"/></size>
		<lock public="1" set="method"><f a=""><c path="haxe.io.Bytes"/></f></lock>
		<unlock public="1" set="method"><f a=""><x path="Void"/></f></unlock>
	</class>
	<enum path="kha.graphics4.CullMode" params="" file="Kha/Sources/kha/graphics4/CullMode.hx">
		<Clockwise/>
		<CounterClockwise/>
		<None/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="kha.graphics4.FragmentShader" params="" file="Kha/Backends/Kore/kha/graphics4/FragmentShader.hx">
		<initFragmentShader set="method" line="20">
			<f a="source">
				<c path="kha.Blob"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tshader = new Kore::Shader(source->toBytes()->b->Pointer(), source->length(), Kore::FragmentShader);\r\n\t"]]></e></m></meta>
		</initFragmentShader>
		<unused public="1" set="method" line="24"><f a=""><x path="Void"/></f></unused>
		<new public="1" set="method" line="13"><f a="source">
	<c path="kha.Blob"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Graphics/Graphics.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"Kore::Shader* shader;"</e></m>
		</meta>
	</class>
	<class path="kha.graphics4.Graphics" params="" file="Kha/Sources/kha/graphics4/Graphics.hx" interface="1">
		<begin public="1" set="method"><f a=""><x path="Void"/></f></begin>
		<end public="1" set="method"><f a=""><x path="Void"/></f></end>
		<vsynced public="1" set="method"><f a=""><x path="Bool"/></f></vsynced>
		<refreshRate public="1" set="method"><f a=""><x path="Int"/></f></refreshRate>
		<clear public="1" set="method"><f a="?color:?depth:?stencil">
	<x path="kha.Color"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<setCullMode public="1" set="method"><f a="mode">
	<e path="kha.graphics4.CullMode"/>
	<x path="Void"/>
</f></setCullMode>
		<setDepthMode public="1" set="method"><f a="write:mode">
	<x path="Bool"/>
	<e path="kha.graphics4.CompareMode"/>
	<x path="Void"/>
</f></setDepthMode>
		<setBlendingMode public="1" set="method"><f a="source:destination">
	<e path="kha.graphics4.BlendingOperation"/>
	<e path="kha.graphics4.BlendingOperation"/>
	<x path="Void"/>
</f></setBlendingMode>
		<setStencilParameters public="1" set="method"><f a="compareMode:bothPass:depthFail:stencilFail:referenceValue:?readMask:?writeMask">
	<e path="kha.graphics4.CompareMode"/>
	<e path="kha.graphics4.StencilAction"/>
	<e path="kha.graphics4.StencilAction"/>
	<e path="kha.graphics4.StencilAction"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setStencilParameters>
		<setScissor public="1" set="method"><f a="rect">
	<c path="kha.Rectangle"/>
	<x path="Void"/>
</f></setScissor>
		<setVertexBuffer public="1" set="method"><f a="vertexBuffer">
	<c path="kha.graphics4.VertexBuffer"/>
	<x path="Void"/>
</f></setVertexBuffer>
		<setIndexBuffer public="1" set="method"><f a="indexBuffer">
	<c path="kha.graphics4.IndexBuffer"/>
	<x path="Void"/>
</f></setIndexBuffer>
		<setTexture public="1" set="method"><f a="unit:texture">
	<c path="kha.graphics4.TextureUnit"/>
	<c path="kha.Image"/>
	<x path="Void"/>
</f></setTexture>
		<setTextureParameters public="1" set="method"><f a="texunit:uAddressing:vAddressing:minificationFilter:magnificationFilter:mipmapFilter">
	<c path="kha.graphics4.TextureUnit"/>
	<e path="kha.graphics4.TextureAddressing"/>
	<e path="kha.graphics4.TextureAddressing"/>
	<e path="kha.graphics4.TextureFilter"/>
	<e path="kha.graphics4.TextureFilter"/>
	<e path="kha.graphics4.MipMapFilter"/>
	<x path="Void"/>
</f></setTextureParameters>
		<createCubeMap public="1" set="method"><f a="size:format:usage:?canRead">
	<x path="Int"/>
	<e path="kha.graphics4.TextureFormat"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Bool"/>
	<c path="kha.graphics4.CubeMap"/>
</f></createCubeMap>
		<renderTargetsInvertedY public="1" set="method"><f a=""><x path="Bool"/></f></renderTargetsInvertedY>
		<setProgram public="1" set="method"><f a="program">
	<c path="kha.graphics4.Program"/>
	<x path="Void"/>
</f></setProgram>
		<setBool public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setBool>
		<setInt public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setFloat public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setFloat2 public="1" set="method"><f a="location:value1:value2">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat2>
		<setFloat3 public="1" set="method"><f a="location:value1:value2:value3">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat3>
		<setFloat4 public="1" set="method"><f a="location:value1:value2:value3:value4">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat4>
		<setFloats public="1" set="method"><f a="location:floats">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setFloats>
		<setVector2 public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector2"/>
	<x path="Void"/>
</f></setVector2>
		<setVector3 public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector3"/>
	<x path="Void"/>
</f></setVector3>
		<setVector4 public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector4"/>
	<x path="Void"/>
</f></setVector4>
		<setMatrix public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Matrix4"/>
	<x path="Void"/>
</f></setMatrix>
		<drawIndexedVertices public="1" set="method"><f a="?start:?count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawIndexedVertices>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
	</class>
	<class path="kha.graphics4.ImageShaderPainter" params="" file="Kha/Sources/kha/graphics4/Graphics2.hx" module="kha.graphics4.Graphics2">
		<bufferSize line="31" static="1"><x path="Int"/></bufferSize>
		<vertexSize line="32" static="1"><x path="Int"/></vertexSize>
		<projectionMatrix><c path="kha.math.Matrix4"/></projectionMatrix>
		<shaderProgram><c path="kha.graphics4.Program"/></shaderProgram>
		<structure><c path="kha.graphics4.VertexStructure"/></structure>
		<projectionLocation><c path="kha.graphics4.ConstantLocation"/></projectionLocation>
		<textureLocation><c path="kha.graphics4.TextureUnit"/></textureLocation>
		<bufferIndex><x path="Int"/></bufferIndex>
		<rectVertexBuffer><c path="kha.graphics4.VertexBuffer"/></rectVertexBuffer>
		<rectVertices><x path="haxe.io.Float32Array"/></rectVertices>
		<indexBuffer><c path="kha.graphics4.IndexBuffer"/></indexBuffer>
		<lastTexture><c path="kha.Image"/></lastTexture>
		<bilinear><x path="Bool"/></bilinear>
		<g><c path="kha.graphics4.Graphics"/></g>
		<myProgram><c path="kha.graphics4.Program"/></myProgram>
		<program public="1" get="accessor" set="accessor"><c path="kha.graphics4.Program"/></program>
		<sourceBlend public="1"><e path="kha.graphics4.BlendingOperation"/></sourceBlend>
		<destinationBlend public="1"><e path="kha.graphics4.BlendingOperation"/></destinationBlend>
		<get_program set="method" line="55"><f a=""><c path="kha.graphics4.Program"/></f></get_program>
		<set_program set="method" line="59"><f a="prog">
	<c path="kha.graphics4.Program"/>
	<c path="kha.graphics4.Program"/>
</f></set_program>
		<setProjection public="1" set="method" line="71"><f a="projectionMatrix">
	<c path="kha.math.Matrix4"/>
	<x path="Void"/>
</f></setProjection>
		<initShaders set="method" line="75"><f a=""><x path="Void"/></f></initShaders>
		<initBuffers set="method" line="91"><f a=""><x path="Void"/></f></initBuffers>
		<setRectVertices set="method" line="108"><f a="bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectVertices>
		<setRectTexCoords set="method" line="131"><f a="left:top:right:bottom">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectTexCoords>
		<setRectColor set="method" line="146"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectColor>
		<drawBuffer set="method" line="169"><f a=""><x path="Void"/></f></drawBuffer>
		<setBilinearFilter public="1" set="method" line="190"><f a="bilinear">
	<x path="Bool"/>
	<x path="Void"/>
</f></setBilinearFilter>
		<drawImage public="1" set="method" line="195"><f a="img:bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty:opacity:color">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></drawImage>
		<drawImage2 public="1" set="method" line="212"><f a="img:sx:sy:sw:sh:bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty:opacity:color">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></drawImage2>
		<drawImageScale public="1" set="method" line="229"><f a="img:sx:sy:sw:sh:left:top:right:bottom:opacity:color">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></drawImageScale>
		<end public="1" set="method" line="241"><f a=""><x path="Void"/></f></end>
		<new public="1" set="method" line="46"><f a="g4">
	<c path="kha.graphics4.Graphics"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.ColoredShaderPainter" params="" file="Kha/Sources/kha/graphics4/Graphics2.hx" module="kha.graphics4.Graphics2">
		<bufferSize line="253" static="1"><x path="Int"/></bufferSize>
		<triangleBufferSize line="259" static="1"><x path="Int"/></triangleBufferSize>
		<projectionMatrix><c path="kha.math.Matrix4"/></projectionMatrix>
		<shaderProgram><c path="kha.graphics4.Program"/></shaderProgram>
		<structure><c path="kha.graphics4.VertexStructure"/></structure>
		<projectionLocation><c path="kha.graphics4.ConstantLocation"/></projectionLocation>
		<bufferIndex><x path="Int"/></bufferIndex>
		<rectVertexBuffer><c path="kha.graphics4.VertexBuffer"/></rectVertexBuffer>
		<rectVertices><x path="haxe.io.Float32Array"/></rectVertices>
		<indexBuffer><c path="kha.graphics4.IndexBuffer"/></indexBuffer>
		<triangleBufferIndex><x path="Int"/></triangleBufferIndex>
		<triangleVertexBuffer><c path="kha.graphics4.VertexBuffer"/></triangleVertexBuffer>
		<triangleVertices><x path="haxe.io.Float32Array"/></triangleVertices>
		<triangleIndexBuffer><c path="kha.graphics4.IndexBuffer"/></triangleIndexBuffer>
		<g><c path="kha.graphics4.Graphics"/></g>
		<myProgram><c path="kha.graphics4.Program"/></myProgram>
		<program public="1" get="accessor" set="accessor"><c path="kha.graphics4.Program"/></program>
		<sourceBlend public="1"><e path="kha.graphics4.BlendingOperation"/></sourceBlend>
		<destinationBlend public="1"><e path="kha.graphics4.BlendingOperation"/></destinationBlend>
		<get_program set="method" line="281"><f a=""><c path="kha.graphics4.Program"/></f></get_program>
		<set_program set="method" line="285"><f a="prog">
	<c path="kha.graphics4.Program"/>
	<c path="kha.graphics4.Program"/>
</f></set_program>
		<setProjection public="1" set="method" line="295"><f a="projectionMatrix">
	<c path="kha.math.Matrix4"/>
	<x path="Void"/>
</f></setProjection>
		<initShaders set="method" line="299"><f a=""><x path="Void"/></f></initShaders>
		<initBuffers set="method" line="314"><f a=""><x path="Void"/></f></initBuffers>
		<setRectVertices public="1" set="method" line="343"><f a="bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectVertices>
		<setRectColors public="1" set="method" line="366"><f a="color">
	<x path="kha.Color"/>
	<x path="Void"/>
</f></setRectColors>
		<setTriVertices set="method" line="389"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTriVertices>
		<setTriColors set="method" line="404"><f a="color">
	<x path="kha.Color"/>
	<x path="Void"/>
</f></setTriColors>
		<drawBuffer set="method" line="422"><f a="trisDone">
	<x path="Bool"/>
	<x path="Void"/>
</f></drawBuffer>
		<drawTriBuffer set="method" line="442"><f a="rectsDone">
	<x path="Bool"/>
	<x path="Void"/>
</f></drawTriBuffer>
		<fillRect public="1" set="method" line="462"><f a="color:bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty">
	<x path="kha.Color"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<fillTriangle public="1" set="method" line="474"><f a="color:x1:y1:x2:y2:x3:y3">
	<x path="kha.Color"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillTriangle>
		<endTris public="1" set="method" line="482"><f a="rectsDone">
	<x path="Bool"/>
	<x path="Void"/>
</f></endTris>
		<endRects public="1" set="method" line="486"><f a="trisDone">
	<x path="Bool"/>
	<x path="Void"/>
</f></endRects>
		<end public="1" set="method" line="490"><f a=""><x path="Void"/></f></end>
		<new public="1" set="method" line="272"><f a="g4">
	<c path="kha.graphics4.Graphics"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.TextShaderPainter" params="" file="Kha/Sources/kha/graphics4/Graphics2.hx" module="kha.graphics4.Graphics2">
		<bufferSize line="505" static="1"><x path="Int"/></bufferSize>
		<projectionMatrix><c path="kha.math.Matrix4"/></projectionMatrix>
		<shaderProgram><c path="kha.graphics4.Program"/></shaderProgram>
		<structure><c path="kha.graphics4.VertexStructure"/></structure>
		<projectionLocation><c path="kha.graphics4.ConstantLocation"/></projectionLocation>
		<textureLocation><c path="kha.graphics4.TextureUnit"/></textureLocation>
		<bufferIndex><x path="Int"/></bufferIndex>
		<rectVertexBuffer><c path="kha.graphics4.VertexBuffer"/></rectVertexBuffer>
		<rectVertices><x path="haxe.io.Float32Array"/></rectVertices>
		<indexBuffer><c path="kha.graphics4.IndexBuffer"/></indexBuffer>
		<font><c path="kha.Kravur"/></font>
		<lastTexture><c path="kha.Image"/></lastTexture>
		<g><c path="kha.graphics4.Graphics"/></g>
		<myProgram><c path="kha.graphics4.Program"/></myProgram>
		<program public="1" get="accessor" set="accessor"><c path="kha.graphics4.Program"/></program>
		<sourceBlend public="1"><e path="kha.graphics4.BlendingOperation"/></sourceBlend>
		<destinationBlend public="1"><e path="kha.graphics4.BlendingOperation"/></destinationBlend>
		<get_program set="method" line="528"><f a=""><c path="kha.graphics4.Program"/></f></get_program>
		<set_program set="method" line="532"><f a="prog">
	<c path="kha.graphics4.Program"/>
	<c path="kha.graphics4.Program"/>
</f></set_program>
		<setProjection public="1" set="method" line="544"><f a="projectionMatrix">
	<c path="kha.math.Matrix4"/>
	<x path="Void"/>
</f></setProjection>
		<initShaders set="method" line="548"><f a=""><x path="Void"/></f></initShaders>
		<initBuffers set="method" line="564"><f a=""><x path="Void"/></f></initBuffers>
		<setRectVertices set="method" line="581"><f a="bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectVertices>
		<setRectTexCoords set="method" line="604"><f a="left:top:right:bottom">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectTexCoords>
		<setRectColors set="method" line="619"><f a="color">
	<x path="kha.Color"/>
	<x path="Void"/>
</f></setRectColors>
		<drawBuffer set="method" line="642"><f a=""><x path="Void"/></f></drawBuffer>
		<setFont public="1" set="method" line="662"><f a="font">
	<c path="kha.Font"/>
	<x path="Void"/>
</f></setFont>
		<text><c path="String"/></text>
		<startString set="method" line="673"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></startString>
		<charCodeAt set="method" line="682"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></charCodeAt>
		<stringLength set="method" line="691"><f a=""><x path="Int"/></f></stringLength>
		<endString set="method" line="700"><f a=""><x path="Void"/></f></endString>
		<drawString public="1" set="method" line="704"><f a="text:color:x:y:transformation">
	<c path="String"/>
	<x path="kha.Color"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
	<x path="Void"/>
</f></drawString>
		<end public="1" set="method" line="730"><f a=""><x path="Void"/></f></end>
		<new public="1" set="method" line="519"><f a="g4">
	<c path="kha.graphics4.Graphics"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.Graphics2" params="" file="Kha/Sources/kha/graphics4/Graphics2.hx">
		<extends path="kha.graphics2.Graphics"/>
		<upperPowerOfTwo set="method" line="772" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></upperPowerOfTwo>
		<myColor><x path="kha.Color"/></myColor>
		<myFont><c path="kha.Font"/></myFont>
		<projectionMatrix><c path="kha.math.Matrix4"/></projectionMatrix>
		<imagePainter public="1"><c path="kha.graphics4.ImageShaderPainter"/></imagePainter>
		<coloredPainter><c path="kha.graphics4.ColoredShaderPainter"/></coloredPainter>
		<textPainter><c path="kha.graphics4.TextShaderPainter"/></textPainter>
		<videoProgram><c path="kha.graphics4.Program"/></videoProgram>
		<canvas><c path="kha.Canvas"/></canvas>
		<g><c path="kha.graphics4.Graphics"/></g>
		<setProjection set="method" line="783"><f a=""><x path="Void"/></f></setProjection>
		<drawImage public="1" set="method" line="804" override="1"><f a="img:x:y">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawImage>
		<drawScaledSubImage public="1" set="method" line="814" override="1"><f a="img:sx:sy:sw:sh:dx:dy:dw:dh">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawScaledSubImage>
		<get_color public="1" set="method" line="824" override="1"><f a=""><x path="kha.Color"/></f></get_color>
		<set_color public="1" set="method" line="828" override="1"><f a="color">
	<x path="kha.Color"/>
	<x path="kha.Color"/>
</f></set_color>
		<drawRect public="1" set="method" line="832" override="1"><f a="x:y:width:height:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<fillRect public="1" set="method" line="859" override="1"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<drawString public="1" set="method" line="870" override="1"><f a="text:x:y">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawString>
		<get_font public="1" set="method" line="877" override="1"><f a=""><c path="kha.Font"/></f></get_font>
		<set_font public="1" set="method" line="881" override="1"><f a="font">
	<c path="kha.Font"/>
	<c path="kha.Font"/>
</f></set_font>
		<drawLine public="1" set="method" line="886" override="1"><f a="x1:y1:x2:y2:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawLine>
		<fillTriangle public="1" set="method" line="908" override="1"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillTriangle>
		<setBilinearFiltering public="1" set="method" line="918"><f a="bilinear">
	<x path="Bool"/>
	<x path="Void"/>
</f></setBilinearFiltering>
		<setProgram set="method" line="922" override="1"><f a="program">
	<c path="kha.graphics4.Program"/>
	<x path="Void"/>
</f></setProgram>
		<setBlendingMode public="1" set="method" line="930" override="1"><f a="source:destination">
	<e path="kha.graphics4.BlendingOperation"/>
	<e path="kha.graphics4.BlendingOperation"/>
	<x path="Void"/>
</f></setBlendingMode>
		<begin public="1" set="method" line="940" override="1"><f a="?clear:?clearColor">
	<x path="Bool"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></begin>
		<clear public="1" set="method" line="946" override="1"><f a="?color">
	<x path="kha.Color"/>
	<x path="Void"/>
</f></clear>
		<endDrawing set="method" line="950"><f a=""><x path="Void"/></f></endDrawing>
		<end public="1" set="method" line="956" override="1"><f a=""><x path="Void"/></f></end>
		<drawVideoInternal set="method" line="961"><f a="video:x:y:width:height">
	<c path="kha.Video"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawVideoInternal>
		<drawVideo public="1" set="method" line="965" override="1"><f a="video:x:y:width:height">
	<c path="kha.Video"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawVideo>
		<new public="1" set="method" line="747"><f a="canvas">
	<c path="kha.Canvas"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.IndexBuffer" params="" file="Kha/Backends/Kore/kha/graphics4/IndexBuffer.hx">
		<data><c path="Array"><x path="Int"/></c></data>
		<myCount><x path="Int"/></myCount>
		<init set="method" line="23">
			<f a="count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tbuffer = new Kore::IndexBuffer(count);\r\n\t"</e></m></meta>
		</init>
		<lock public="1" set="method" line="27"><f a=""><c path="Array"><x path="Int"/></c></f></lock>
		<unlock public="1" set="method" line="38">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tint* indices = buffer->lock();\r\n\t\tfor (int i = 0; i < myCount; ++i) {\r\n\t\t\tindices[i] = data[i];\r\n\t\t}\r\n\t\tbuffer->unlock();\r\n\t"]]></e></m></meta>
		</unlock>
		<set public="1" set="method" line="45">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tbuffer->set();\r\n\t"]]></e></m></meta>
		</set>
		<count public="1" set="method" line="49"><f a=""><x path="Int"/></f></count>
		<new public="1" set="method" line="13"><f a="indexCount:usage:?canRead">
	<x path="Int"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Graphics/Graphics.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"Kore::IndexBuffer* buffer;"</e></m>
		</meta>
	</class>
	<enum path="kha.graphics4.MipMapFilter" params="" file="Kha/Sources/kha/graphics4/MipMapFilter.hx">
		<NoMipFilter/>
		<PointMipFilter/>
		<LinearMipFilter/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.graphics4.Program" params="" file="Kha/Backends/Kore/kha/graphics4/Program.hx">
		<init set="method" line="23">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t\tprogram = new Kore::Program();\r\n\t"</e></m></meta>
		</init>
		<setVertexShader public="1" set="method" line="27"><f a="shader">
	<c path="kha.graphics4.VertexShader"/>
	<x path="Void"/>
</f></setVertexShader>
		<setVertexShaderImpl set="method" line="34">
			<f a="shader">
				<c path="kha.graphics4.VertexShader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tprogram->setVertexShader(shader->shader);\r\n\t"]]></e></m></meta>
		</setVertexShaderImpl>
		<setFragmentShader public="1" set="method" line="38"><f a="shader">
	<c path="kha.graphics4.FragmentShader"/>
	<x path="Void"/>
</f></setFragmentShader>
		<setFragmentShaderImpl set="method" line="45">
			<f a="shader">
				<c path="kha.graphics4.FragmentShader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tprogram->setFragmentShader(shader->shader);\r\n\t"]]></e></m></meta>
		</setFragmentShaderImpl>
		<link public="1" set="method" line="71">
			<f a="structure">
				<c path="kha.graphics4.VertexStructure"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::VertexStructure structure2;\r\n\t\tfor (int i = 0; i < structure->size(); ++i) {\r\n\t\t\tKore::VertexData data;\r\n\t\t\tswitch (structure->get(i)->data->index) {\r\n\t\t\tcase 0:\r\n\t\t\t\tdata = Kore::Float1VertexData;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tdata = Kore::Float2VertexData;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tdata = Kore::Float3VertexData;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tdata = Kore::Float4VertexData;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tstructure2.add(structure->get(i)->name, data);\r\n\t\t}\r\n\t\tprogram->link(structure2);\r\n\t"]]></e></m></meta>
		</link>
		<getConstantLocation public="1" set="method" line="75"><f a="name">
	<c path="String"/>
	<c path="kha.graphics4.ConstantLocation"/>
</f></getConstantLocation>
		<initConstantLocation set="method" line="84">
			<f a="location:name">
				<c path="kha.kore.graphics4.ConstantLocation"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tlocation->location = program->getConstantLocation(name.c_str());\r\n\t"]]></e></m></meta>
		</initConstantLocation>
		<getTextureUnit public="1" set="method" line="88"><f a="name">
	<c path="String"/>
	<c path="kha.graphics4.TextureUnit"/>
</f></getTextureUnit>
		<initTextureUnit set="method" line="97">
			<f a="unit:name">
				<c path="kha.kore.graphics4.TextureUnit"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tunit->unit = program->getTextureUnit(name.c_str());\r\n\t"]]></e></m></meta>
		</initTextureUnit>
		<set public="1" set="method" line="104">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tprogram->set();\r\n\t"]]></e></m></meta>
		</set>
		<unused public="1" set="method" line="108"><f a=""><x path="Void"/></f></unused>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Graphics/Graphics.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"Kore::Program* program;"</e></m>
		</meta>
	</class>
	<enum path="kha.graphics4.StencilAction" params="" file="Kha/Sources/kha/graphics4/StencilAction.hx">
		<Keep/>
		<Zero/>
		<Replace/>
		<Increment/>
		<IncrementWrap/>
		<Decrement/>
		<DecrementWrap/>
		<Invert/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="kha.graphics4.TexDir" params="" file="Kha/Sources/kha/graphics4/TexDir.hx">
		<U/>
		<V/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="kha.graphics4.TextureAddressing" params="" file="Kha/Sources/kha/graphics4/TextureAddressing.hx">
		<Repeat/>
		<Mirror/>
		<Clamp/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="kha.graphics4.TextureFilter" params="" file="Kha/Sources/kha/graphics4/TextureFilter.hx">
		<PointFilter/>
		<LinearFilter/>
		<AnisotropicFilter/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="kha.graphics4.TextureFormat" params="" file="Kha/Sources/kha/graphics4/TextureFormat.hx">
		<RGBA32/>
		<L8/>
		<RGBA128/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.graphics4.TextureUnit" params="" file="Kha/Sources/kha/graphics4/TextureUnit.hx" interface="1"/>
	<enum path="kha.graphics4.Usage" params="" file="Kha/Sources/kha/graphics4/Usage.hx">
		<StaticUsage/>
		<DynamicUsage/>
		<ReadableUsage/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.graphics4.VertexBuffer" params="" file="Kha/Backends/Kore/kha/graphics4/VertexBuffer.hx">
		<data><x path="haxe.io.Float32Array"/></data>
		<init set="method" line="47">
			<f a="vertexCount:structure">
				<x path="Int"/>
				<c path="kha.graphics4.VertexStructure"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::VertexStructure structure2;\r\n\t\tfor (int i = 0; i < structure->size(); ++i) {\r\n\t\t\tKore::VertexData data;\r\n\t\t\tswitch (structure->get(i)->data->index) {\r\n\t\t\tcase 0:\r\n\t\t\t\tdata = Kore::Float1VertexData;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tdata = Kore::Float2VertexData;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tdata = Kore::Float3VertexData;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tdata = Kore::Float4VertexData;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tstructure2.add(structure->get(i)->name, data);\r\n\t\t}\r\n\t\tbuffer = new Kore::VertexBuffer(vertexCount, structure2);\r\n\t"]]></e></m></meta>
		</init>
		<lock public="1" set="method" line="51"><f a="?start:?count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.io.Float32Array"/>
</f></lock>
		<unlock2 set="method" line="63">
			<f a="bytes">
				<t path="haxe.io.BytesData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tfloat* vertices = buffer->lock();\r\n\t\tfloat* pointer = (float*)bytes->Pointer();\r\n\t\tfor (int i = 0; i < buffer->count() * buffer->stride() / 4; ++i) {\r\n\t\t\tvertices[i] = pointer[i];\r\n\t\t}\r\n\t\tbuffer->unlock();\r\n\t"]]></e></m></meta>
		</unlock2>
		<unlock public="1" set="method" line="67"><f a=""><x path="Void"/></f></unlock>
		<stride public="1" set="method" line="74">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\treturn buffer->stride();\r\n\t"]]></e></m></meta>
		</stride>
		<count public="1" set="method" line="81">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\treturn buffer->count();\r\n\t"]]></e></m></meta>
		</count>
		<set public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tbuffer->set();\r\n\t"]]></e></m></meta>
		</set>
		<new public="1" set="method" line="18"><f a="vertexCount:structure:usage:?canRead">
	<x path="Int"/>
	<c path="kha.graphics4.VertexStructure"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Graphics/Graphics.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"Kore::VertexBuffer* buffer;"</e></m>
		</meta>
	</class>
	<enum path="kha.graphics4.VertexData" params="" file="Kha/Sources/kha/graphics4/VertexData.hx">
		<Float1/>
		<Float2/>
		<Float3/>
		<Float4/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.graphics4.VertexElement" params="" file="Kha/Sources/kha/graphics4/VertexElement.hx">
		<name public="1"><c path="String"/></name>
		<data public="1"><e path="kha.graphics4.VertexData"/></data>
		<new public="1" set="method" line="7"><f a="name:data">
	<c path="String"/>
	<e path="kha.graphics4.VertexData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.VertexShader" params="" file="Kha/Backends/Kore/kha/graphics4/VertexShader.hx">
		<initVertexShader set="method" line="20">
			<f a="source">
				<c path="kha.Blob"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tshader = new Kore::Shader(source->toBytes()->b->Pointer(), source->length(), Kore::VertexShader);\r\n\t"]]></e></m></meta>
		</initVertexShader>
		<unused public="1" set="method" line="24"><f a=""><x path="Void"/></f></unused>
		<new public="1" set="method" line="13"><f a="source">
	<c path="kha.Blob"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Graphics/Graphics.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"Kore::Shader* shader;"</e></m>
		</meta>
	</class>
	<class path="kha.graphics4.VertexStructure" params="" file="Kha/Sources/kha/graphics4/VertexStructure.hx">
		<elements public="1"><c path="Array"><c path="kha.graphics4.VertexElement"/></c></elements>
		<add public="1" set="method" line="10"><f a="name:data">
	<c path="String"/>
	<e path="kha.graphics4.VertexData"/>
	<x path="Void"/>
</f></add>
		<size public="1" set="method" line="14"><f a=""><x path="Int"/></f></size>
		<get public="1" set="method" line="18"><f a="index">
	<x path="Int"/>
	<c path="kha.graphics4.VertexElement"/>
</f></get>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.input.Gamepad" params="" file="Kha/Sources/kha/input/Gamepad.hx">
		<get public="1" set="method" line="6" static="1"><f a="?num">
	<x path="Int"/>
	<c path="kha.input.Gamepad"/>
</f></get>
		<instance static="1"><c path="kha.input.Gamepad"/></instance>
		<notify public="1" set="method" line="11"><f a="axisListener:buttonListener">
	<f a=":">
		<x path="Int"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<x path="Int"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></notify>
		<remove public="1" set="method" line="16"><f a="axisListener:buttonListener">
	<f a=":">
		<x path="Int"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<x path="Int"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></remove>
		<axisListeners><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></axisListeners>
		<buttonListeners><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></buttonListeners>
		<sendAxisEvent set="method" line="31"><f a="axis:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></sendAxisEvent>
		<sendButtonEvent set="method" line="37"><f a="button:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></sendButtonEvent>
		<new set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>kha.Starter</e></m>
			<m n=":expose"/>
		</meta>
	</class>
	<class path="kha.input.Keyboard" params="" file="Kha/Sources/kha/input/Keyboard.hx">
		<get public="1" set="method" line="13" static="1"><f a="?num">
	<x path="Int"/>
	<c path="kha.input.Keyboard"/>
</f></get>
		<instance static="1"><c path="kha.input.Keyboard"/></instance>
		<notify public="1" set="method" line="18"><f a="downListener:upListener">
	<f a=":">
		<e path="kha.Key"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<e path="kha.Key"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></notify>
		<remove public="1" set="method" line="23"><f a="downListener:upListener">
	<f a=":">
		<e path="kha.Key"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<e path="kha.Key"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></remove>
		<downListeners><c path="Array"><f a=":">
	<e path="kha.Key"/>
	<c path="String"/>
	<x path="Void"/>
</f></c></downListeners>
		<upListeners><c path="Array"><f a=":">
	<e path="kha.Key"/>
	<c path="String"/>
	<x path="Void"/>
</f></c></upListeners>
		<sendDownEvent set="method" line="39">
			<f a="key:char">
				<e path="kha.Key"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n="input"/></meta>
		</sendDownEvent>
		<sendUpEvent set="method" line="49">
			<f a="key:char">
				<e path="kha.Key"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n="input"/></meta>
		</sendUpEvent>
		<new set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>kha.Starter</e></m>
			<m n=":expose"/>
		</meta>
	</class>
	<class path="kha.input.Mouse" params="" file="Kha/Sources/kha/input/Mouse.hx">
		<get public="1" set="method" line="6" static="1"><f a="?num">
	<x path="Int"/>
	<c path="kha.input.Mouse"/>
</f></get>
		<instance static="1"><c path="kha.input.Mouse"/></instance>
		<notify public="1" set="method" line="11"><f a="downListener:upListener:moveListener:wheelListener">
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></notify>
		<remove public="1" set="method" line="18"><f a="downListener:upListener:moveListener:wheelListener">
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></remove>
		<downListeners><c path="Array"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></downListeners>
		<upListeners><c path="Array"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></upListeners>
		<moveListeners><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></moveListeners>
		<wheelListeners><c path="Array"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c></wheelListeners>
		<sendDownEvent set="method" line="39"><f a="button:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sendDownEvent>
		<sendUpEvent set="method" line="45"><f a="button:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sendUpEvent>
		<sendMoveEvent set="method" line="51"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sendMoveEvent>
		<sendWheelEvent set="method" line="57"><f a="delta">
	<x path="Int"/>
	<x path="Void"/>
</f></sendWheelEvent>
		<new set="method" line="31"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>kha.Starter</e></m>
			<m n=":expose"/>
		</meta>
	</class>
	<class path="kha.input.Sensor" params="" file="Kha/Backends/Kore/kha/input/Sensor.hx">
		<accelerometer line="4" static="1"><c path="kha.input.Sensor"/></accelerometer>
		<gyroscope line="5" static="1"><c path="kha.input.Sensor"/></gyroscope>
		<get public="1" set="method" line="8" static="1"><f a="type">
	<e path="kha.input.SensorType"/>
	<c path="kha.input.Sensor"/>
</f></get>
		<_changed public="1" set="method" line="25" static="1"><f a="type:x:y:z">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></_changed>
		<listeners><c path="Array"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></listeners>
		<notify public="1" set="method" line="17"><f a="listener">
	<f a="::">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></notify>
		<new set="method" line="21"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.input.SensorType" params="" file="Kha/Sources/kha/input/SensorType.hx">
		<Accelerometer/>
		<Gyroscope/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.input.Surface" params="" file="Kha/Sources/kha/input/Surface.hx">
		<get public="1" set="method" line="6" static="1"><f a="?num">
	<x path="Int"/>
	<c path="kha.input.Surface"/>
</f></get>
		<instance static="1"><c path="kha.input.Surface"/></instance>
		<notify public="1" set="method" line="11"><f a="touchStartListener:touchEndListener:moveListener">
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></notify>
		<remove public="1" set="method" line="17"><f a="touchStartListener:touchEndListener:moveListener">
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></remove>
		<touchStartListeners><c path="Array"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></touchStartListeners>
		<touchEndListeners><c path="Array"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></touchEndListeners>
		<moveListeners><c path="Array"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></moveListeners>
		<sendTouchStartEvent set="method" line="35"><f a="index:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sendTouchStartEvent>
		<sendTouchEndEvent set="method" line="41"><f a="index:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sendTouchEndEvent>
		<sendMoveEvent set="method" line="47"><f a="index:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sendMoveEvent>
		<new set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>kha.Starter</e></m>
			<m n=":expose"/>
		</meta>
	</class>
	<class path="kha.kore.Loader" params="" file="Kha/Backends/Kore/kha/kore/Loader.hx">
		<extends path="kha.Loader"/>
		<loadMusic public="1" set="method" line="18" override="1"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Music"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadMusic>
		<loadSound public="1" set="method" line="22" override="1"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadSound>
		<loadImage public="1" set="method" line="26" override="1"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Image"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadImage>
		<loadBlob public="1" set="method" line="31" override="1"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Blob"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBlob>
		<loadFont public="1" set="method" line="35" override="1"><f a="name:style:size">
	<c path="String"/>
	<c path="kha.FontStyle"/>
	<x path="Float"/>
	<c path="kha.Font"/>
</f></loadFont>
		<loadVideo public="1" set="method" line="39" override="1"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.kore.Video"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadVideo>
		<showKeyboard public="1" set="method" line="44" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"Kore::System::showKeyboard();"</e></m></meta>
		</showKeyboard>
		<hideKeyboard public="1" set="method" line="49" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"Kore::System::hideKeyboard();"</e></m></meta>
		</hideKeyboard>
		<loadURL public="1" set="method" line="54" override="1">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"Kore::System::loadURL(url);"</e></m></meta>
		</loadURL>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/System.h>\r\n"]]></e></m>
		</meta>
	</class>
	<class path="kha.kore.Mouse" params="" file="Kha/Backends/Kore/kha/kore/Mouse.hx">
		<extends path="kha.Mouse"/>
		<new public="1" set="method" line="4"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.kore.Music" params="" file="Kha/Backends/Kore/kha/kore/Music.hx">
		<extends path="kha.Music"/>
		<loadMusic set="method" line="19"><f a="filename">
	<c path="String"/>
	<x path="Void"/>
</f></loadMusic>
		<unload public="1" set="method" line="24" override="1"><f a=""><x path="Void"/></f></unload>
		<play public="1" set="method" line="33" override="1"><f a="?loop">
	<x path="Bool"/>
	<x path="Void"/>
</f></play>
		<stop public="1" set="method" line="38" override="1"><f a=""><x path="Void"/></f></stop>
		<getCurrentPos public="1" set="method" line="43" override="1"><f a=""><x path="Int"/></f></getCurrentPos>
		<getLength public="1" set="method" line="48" override="1"><f a=""><x path="Int"/></f></getLength>
		<getVolume public="1" set="method" line="53" override="1"><f a=""><x path="Float"/></f></getVolume>
		<setVolume public="1" set="method" line="56" override="1"><f a="volume">
	<x path="Float"/>
	<x path="Void"/>
</f></setVolume>
		<new public="1" set="method" line="12"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Audio/SoundStream.h>\r\n#include <Kore/Audio/Mixer.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"Kore::SoundStream* stream;"</e></m>
		</meta>
	</class>
	<class path="kha.kore.Sound" params="" file="Kha/Backends/Kore/kha/kore/Sound.hx">
		<extends path="kha.Sound"/>
		<loadSound set="method" line="59">
			<f a="filename">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tsound = new Kore::Sound(filename.c_str());\r\n\t\tif (sound->format.channels == 1) {\r\n\t\t\tif (sound->format.bitsPerSample == 8) {\r\n\t\t\t\tthis->_createData(sound->size * 2);\r\n\t\t\t\tfor (int i = 0; i < sound->size; ++i) {\r\n\t\t\t\t\tdata[i * 2 + 0] = sound->data[i] / 255.0 * 2.0 - 1.0;\r\n\t\t\t\t\tdata[i * 2 + 1] = sound->data[i] / 255.0 * 2.0 - 1.0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (sound->format.bitsPerSample == 16) {\r\n\t\t\t\tthis->_createData(sound->size);\r\n\t\t\t\tKore::s16* sdata = (Kore::s16*)&sound->data[0];\r\n\t\t\t\tfor (int i = 0; i < sound->size / 2; ++i) {\r\n\t\t\t\t\tdata[i * 2 + 0] = sdata[i] / 32767.0;\r\n\t\t\t\t\tdata[i * 2 + 1] = sdata[i] / 32767.0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis->_createData(2);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (sound->format.bitsPerSample == 8) {\r\n\t\t\t\tthis->_createData(sound->size);\r\n\t\t\t\tfor (int i = 0; i < sound->size; ++i) {\r\n\t\t\t\t\tdata[i] = sound->data[i] / 255.0 * 2.0 - 1.0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (sound->format.bitsPerSample == 16) {\r\n\t\t\t\tthis->_createData(sound->size / 2);\r\n\t\t\t\tKore::s16* sdata = (Kore::s16*)&sound->data[0];\r\n\t\t\t\tfor (int i = 0; i < sound->size / 2; ++i) {\r\n\t\t\t\t\tdata[i] = sdata[i] / 32767.0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis->_createData(2);\r\n\t\t\t}\r\n\t\t}\r\n\t"]]></e></m></meta>
		</loadSound>
		<playInternal set="method" line="64">
			<f a="channel">
				<c path="kha.kore.SoundChannel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["channel->sound = sound; Kore::Mixer::play(sound);"]]></e></m></meta>
		</playInternal>
		<play public="1" set="method" line="68" override="1"><f a=""><c path="kha.SoundChannel"/></f></play>
		<unload public="1" set="method" line="75" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"Kore::Mixer::stop(sound); delete sound; sound = nullptr;"</e></m></meta>
		</unload>
		<_createData set="method" line="79"><f a="size">
	<x path="Int"/>
	<x path="Void"/>
</f></_createData>
		<new public="1" set="method" line="13"><f a="filename">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Audio/Sound.h>\r\n#include <Kore/Audio/Mixer.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"Kore::Sound* sound;"</e></m>
		</meta>
	</class>
	<class path="kha.kore.SoundChannel" params="" file="Kha/Backends/Kore/kha/kore/SoundChannel.hx">
		<extends path="kha.SoundChannel"/>
		<play public="1" set="method" line="15" override="1"><f a=""><x path="Void"/></f></play>
		<stop public="1" set="method" line="19" override="1"><f a=""><x path="Void"/></f></stop>
		<getLength public="1" set="method" line="24" override="1"><f a=""><x path="Int"/></f></getLength>
		<getCurrentPos public="1" set="method" line="27" override="1"><f a=""><x path="Int"/></f></getCurrentPos>
		<getVolume public="1" set="method" line="30" override="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":functionCode"><e><![CDATA["return sound->volume();"]]></e></m></meta>
		</getVolume>
		<setVolume public="1" set="method" line="33" override="1">
			<f a="volume">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["sound->setVolume(volume);"]]></e></m></meta>
		</setVolume>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Audio/Sound.h>\r\n#include <Kore/Audio/Mixer.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"Kore::Sound* sound;"</e></m>
		</meta>
	</class>
	<class path="kha.kore.Video" params="" file="Kha/Backends/Kore/kha/kore/Video.hx">
		<extends path="kha.Video"/>
		<init set="method" line="20">
			<f a="filename">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\tvideo = new Kore::Video(filename.c_str());\r\n\t"</e></m></meta>
		</init>
		<play public="1" set="method" line="27" override="1">
			<f a="?loop">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\tvideo->play();\r\n\t"]]></e></m></meta>
		</play>
		<pause public="1" set="method" line="34" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\tvideo->pause();\r\n\t"]]></e></m></meta>
		</pause>
		<stop public="1" set="method" line="41" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\tvideo->stop();\r\n\t"]]></e></m></meta>
		</stop>
		<getLength public="1" set="method" line="48" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\treturn static_cast<int>(video->duration * 1000.0);\r\n\t"]]></e></m></meta>
		</getLength>
		<getCurrentPos public="1" set="method" line="55" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n="functionCode"><e><![CDATA["\r\n\treturn scast<int>(video->position * 1000.0);\r\n\t"]]></e></m></meta>
		</getCurrentPos>
		<isFinished public="1" set="method" line="62" override="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\treturn video->finished;\r\n\t"]]></e></m></meta>
		</isFinished>
		<width public="1" set="method" line="69" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\treturn video->width();\r\n\t"]]></e></m></meta>
		</width>
		<height public="1" set="method" line="74" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\treturn video->height();\r\n\t"]]></e></m></meta>
		</height>
		<unload public="1" set="method" line="80" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\r\n\tdelete video;\r\n\tvideo = nullptr;\r\n\t"</e></m></meta>
		</unload>
		<new public="1" set="method" line="12"><f a="filename">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Video.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"\r\n\tKore::Video* video;\r\n"</e></m>
		</meta>
	</class>
	<class path="kha.kore.graphics4.ConstantLocation" params="" file="Kha/Backends/Kore/kha/kore/graphics4/ConstantLocation.hx">
		<implements path="kha.graphics4.ConstantLocation"/>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Graphics/Shader.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"Kore::ConstantLocation location;"</e></m>
		</meta>
	</class>
	<class path="kha.kore.graphics4.Graphics" params="" file="Kha/Backends/Kore/kha/kore/graphics4/Graphics.hx">
		<implements path="kha.graphics4.Graphics"/>
		<target><c path="kha.Image"/></target>
		<vsynced public="1" set="method" line="41">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t\treturn Kore::Graphics::vsynced();\r\n\t"</e></m></meta>
		</vsynced>
		<refreshRate public="1" set="method" line="48">
			<f a=""><x path="Int"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t\treturn (Int)Kore::Graphics::refreshRate();\r\n\t"</e></m></meta>
		</refreshRate>
		<clear public="1" set="method" line="52"><f a="?color:?z:?stencil">
	<x path="kha.Color"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<setDepthMode2 set="method" line="97">
			<f a="write:mode">
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tswitch (mode) {\r\n\t\tcase 0:\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTest, false);\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTestCompare, Kore::ZCompareAlways);\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTest, true);\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTestCompare, Kore::ZCompareNever);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTest, true);\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTestCompare, Kore::ZCompareEqual);\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTest, true);\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTestCompare, Kore::ZCompareNotEqual);\r\n\t\t\tbreak;\r\n\t\tcase 4:\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTest, true);\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTestCompare, Kore::ZCompareLess);\r\n\t\t\tbreak;\r\n\t\tcase 5:\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTest, true);\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTestCompare, Kore::ZCompareLessEqual);\r\n\t\t\tbreak;\r\n\t\tcase 6:\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTest, true);\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTestCompare, Kore::ZCompareGreater);\r\n\t\t\tbreak;\r\n\t\tcase 7:\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTest, true);\r\n\t\t\tKore::Graphics::setRenderState(Kore::DepthTestCompare, Kore::ZCompareGreaterEqual);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tKore::Graphics::setRenderState(Kore::DepthWrite, write);\r\n\t"</e></m></meta>
		</setDepthMode2>
		<setDepthMode public="1" set="method" line="101"><f a="write:mode">
	<x path="Bool"/>
	<e path="kha.graphics4.CompareMode"/>
	<x path="Void"/>
</f></setDepthMode>
		<getBlendingMode set="method" line="106"><f a="op">
	<e path="kha.graphics4.BlendingOperation"/>
	<x path="Int"/>
</f></getBlendingMode>
		<setBlendingModeNative set="method" line="132">
			<f a="source:destination">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tif (source == 0 && destination == 1) {\r\n\t\t\tKore::Graphics::setRenderState(Kore::BlendingState, false);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tKore::Graphics::setRenderState(Kore::BlendingState, true);\r\n\t\t\tKore::Graphics::setBlendingMode((Kore::BlendingOperation)source, (Kore::BlendingOperation)destination);\r\n\t\t}\r\n\t"]]></e></m></meta>
		</setBlendingModeNative>
		<setBlendingMode public="1" set="method" line="136"><f a="source:destination">
	<e path="kha.graphics4.BlendingOperation"/>
	<e path="kha.graphics4.BlendingOperation"/>
	<x path="Void"/>
</f></setBlendingMode>
		<clear2 set="method" line="143">
			<f a="flags:color:z:stencil">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tKore::Graphics::clear(flags, color, z, stencil);\r\n\t"</e></m></meta>
		</clear2>
		<setVertexBuffer public="1" set="method" line="151"><f a="vertexBuffer">
	<c path="kha.graphics4.VertexBuffer"/>
	<x path="Void"/>
</f></setVertexBuffer>
		<setIndexBuffer public="1" set="method" line="158"><f a="indexBuffer">
	<c path="kha.graphics4.IndexBuffer"/>
	<x path="Void"/>
</f></setIndexBuffer>
		<maxTextureSize public="1" set="method" line="172"><f a=""><x path="Int"/></f></maxTextureSize>
		<supportsNonPow2Textures public="1" set="method" line="176"><f a=""><x path="Bool"/></f></supportsNonPow2Textures>
		<createCubeMap public="1" set="method" line="180"><f a="size:format:usage:?canRead">
	<x path="Int"/>
	<e path="kha.graphics4.TextureFormat"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Bool"/>
	<c path="kha.graphics4.CubeMap"/>
</f></createCubeMap>
		<setStencilParameters public="1" set="method" line="184"><f a="compareMode:bothPass:depthFail:stencilFail:referenceValue:?readMask:?writeMask">
	<e path="kha.graphics4.CompareMode"/>
	<e path="kha.graphics4.StencilAction"/>
	<e path="kha.graphics4.StencilAction"/>
	<e path="kha.graphics4.StencilAction"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setStencilParameters>
		<setScissor public="1" set="method" line="188"><f a="rect">
	<c path="kha.Rectangle"/>
	<x path="Void"/>
</f></setScissor>
		<renderTargetsInvertedY public="1" set="method" line="193">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":functionCode"><e>"return Kore::Graphics::renderTargetsInvertedY();"</e></m></meta>
		</renderTargetsInvertedY>
		<setTextureWrapNative set="method" line="201">
			<f a="unit:uWrap:vWrap">
				<c path="kha.kore.graphics4.TextureUnit"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::Graphics::setTextureAddressing(unit->unit, Kore::U, (Kore::TextureAddressing)uWrap);\r\n\t\tKore::Graphics::setTextureAddressing(unit->unit, Kore::V, (Kore::TextureAddressing)vWrap);\r\n\t"]]></e></m></meta>
		</setTextureWrapNative>
		<setTextureFiltersNative set="method" line="210">
			<f a="unit:minificationFilter:magnificationFilter:mipMapFilter">
				<c path="kha.kore.graphics4.TextureUnit"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::Graphics::setTextureMinificationFilter(unit->unit, (Kore::TextureFilter)minificationFilter);\r\n\t\tKore::Graphics::setTextureMagnificationFilter(unit->unit, (Kore::TextureFilter)magnificationFilter);\r\n\t\tKore::Graphics::setTextureMipmapFilter(unit->unit, (Kore::MipmapFilter)mipMapFilter);\r\n\t"]]></e></m></meta>
		</setTextureFiltersNative>
		<getTextureAddressing set="method" line="214"><f a="addressing">
	<e path="kha.graphics4.TextureAddressing"/>
	<x path="Int"/>
</f></getTextureAddressing>
		<getTextureFilter set="method" line="225"><f a="filter">
	<e path="kha.graphics4.TextureFilter"/>
	<x path="Int"/>
</f></getTextureFilter>
		<getTextureMipMapFilter set="method" line="236"><f a="filter">
	<e path="kha.graphics4.MipMapFilter"/>
	<x path="Int"/>
</f></getTextureMipMapFilter>
		<setTextureParameters public="1" set="method" line="247"><f a="texunit:uAddressing:vAddressing:minificationFilter:magnificationFilter:mipmapFilter">
	<c path="kha.graphics4.TextureUnit"/>
	<e path="kha.graphics4.TextureAddressing"/>
	<e path="kha.graphics4.TextureAddressing"/>
	<e path="kha.graphics4.TextureFilter"/>
	<e path="kha.graphics4.TextureFilter"/>
	<e path="kha.graphics4.MipMapFilter"/>
	<x path="Void"/>
</f></setTextureParameters>
		<setCullModeNative set="method" line="255">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tKore::Graphics::setRenderState(Kore::BackfaceCulling, value);\r\n\t"</e></m></meta>
		</setCullModeNative>
		<setCullMode public="1" set="method" line="259"><f a="mode">
	<e path="kha.graphics4.CullMode"/>
	<x path="Void"/>
</f></setCullMode>
		<setTexture public="1" set="method" line="263"><f a="unit:texture">
	<c path="kha.graphics4.TextureUnit"/>
	<c path="kha.Image"/>
	<x path="Void"/>
</f></setTexture>
		<setProgram public="1" set="method" line="280"><f a="program">
	<c path="kha.graphics4.Program"/>
	<x path="Void"/>
</f></setProgram>
		<setBool public="1" set="method" line="284"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setBool>
		<setBoolPrivate set="method" line="291">
			<f a="location:value">
				<c path="kha.kore.graphics4.ConstantLocation"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::Graphics::setBool(location->location, value);\r\n\t"]]></e></m></meta>
		</setBoolPrivate>
		<setInt public="1" set="method" line="295"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setIntPrivate set="method" line="302">
			<f a="location:value">
				<c path="kha.kore.graphics4.ConstantLocation"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::Graphics::setInt(location->location, value);\r\n\t"]]></e></m></meta>
		</setIntPrivate>
		<setFloat public="1" set="method" line="306"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setFloatPrivate set="method" line="313">
			<f a="location:value">
				<c path="kha.kore.graphics4.ConstantLocation"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::Graphics::setFloat(location->location, value);\r\n\t"]]></e></m></meta>
		</setFloatPrivate>
		<setFloat2 public="1" set="method" line="317"><f a="location:value1:value2">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat2>
		<setFloat2Private set="method" line="324">
			<f a="location:value1:value2">
				<c path="kha.kore.graphics4.ConstantLocation"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::Graphics::setFloat2(location->location, value1, value2);\r\n\t"]]></e></m></meta>
		</setFloat2Private>
		<setFloat3 public="1" set="method" line="328"><f a="location:value1:value2:value3">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat3>
		<setFloat3Private set="method" line="335">
			<f a="location:value1:value2:value3">
				<c path="kha.kore.graphics4.ConstantLocation"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::Graphics::setFloat3(location->location, value1, value2, value3);\r\n\t"]]></e></m></meta>
		</setFloat3Private>
		<setFloat4 public="1" set="method" line="339"><f a="location:value1:value2:value3:value4">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat4>
		<setFloat4Private set="method" line="346">
			<f a="location:value1:value2:value3:value4">
				<c path="kha.kore.graphics4.ConstantLocation"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::Graphics::setFloat4(location->location, value1, value2, value3, value4);\r\n\t"]]></e></m></meta>
		</setFloat4Private>
		<setVector2 public="1" set="method" line="350"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector2"/>
	<x path="Void"/>
</f></setVector2>
		<setVector2Private set="method" line="357">
			<f a="location:x:y">
				<c path="kha.kore.graphics4.ConstantLocation"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::Graphics::setFloat2(location->location, x, y);\r\n\t"]]></e></m></meta>
		</setVector2Private>
		<setVector3 public="1" set="method" line="361"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector3"/>
	<x path="Void"/>
</f></setVector3>
		<setVector3Private set="method" line="368">
			<f a="location:x:y:z">
				<c path="kha.kore.graphics4.ConstantLocation"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::Graphics::setFloat3(location->location, x, y, z);\r\n\t"]]></e></m></meta>
		</setVector3Private>
		<setVector4 public="1" set="method" line="372"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector4"/>
	<x path="Void"/>
</f></setVector4>
		<setVector4Private set="method" line="379">
			<f a="location:x:y:z:w">
				<c path="kha.kore.graphics4.ConstantLocation"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::Graphics::setFloat4(location->location, x, y, z, w);\r\n\t"]]></e></m></meta>
		</setVector4Private>
		<setFloats public="1" set="method" line="383"><f a="location:values">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setFloats>
		<setFloatsPrivate set="method" line="392">
			<f a="location:values">
				<c path="kha.kore.graphics4.ConstantLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tfloat v[100];\r\n\t\tfor (int i = 0; i < values->length; ++i) v[i] = values[i];\r\n\t\tKore::Graphics::setFloats(location->location, v, values->length);\r\n\t"]]></e></m></meta>
		</setFloatsPrivate>
		<setMatrix public="1" get="inline" set="null" line="405">
			<f a="location:matrix">
				<c path="kha.graphics4.ConstantLocation"/>
				<c path="kha.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e><![CDATA["\r\n\t\tKore::mat4 value;\r\n\t\tvalue.Set(0, 0, matrix->_00); value.Set(0, 1, matrix->_10); value.Set(0, 2, matrix->_20); value.Set(0, 3, matrix->_30);\r\n\t\tvalue.Set(1, 0, matrix->_01); value.Set(1, 1, matrix->_11); value.Set(1, 2, matrix->_21); value.Set(1, 3, matrix->_31);\r\n\t\tvalue.Set(2, 0, matrix->_02); value.Set(2, 1, matrix->_12); value.Set(2, 2, matrix->_22); value.Set(2, 3, matrix->_32);\r\n\t\tvalue.Set(3, 0, matrix->_03); value.Set(3, 1, matrix->_13); value.Set(3, 2, matrix->_23); value.Set(3, 3, matrix->_33);\r\n\t\t::kha::kore::graphics4::ConstantLocation_obj* loc = dynamic_cast< ::kha::kore::graphics4::ConstantLocation_obj*>(location->__GetRealObject());\r\n\t\tKore::Graphics::setMatrix(loc->location, value);\r\n\t"]]></e></m></meta>
		</setMatrix>
		<drawIndexedVertices public="1" set="method" line="409"><f a="?start:?count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawIndexedVertices>
		<drawAllIndexedVertices set="method" line="417">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t\tKore::Graphics::drawIndexedVertices();\r\n\t"</e></m></meta>
		</drawAllIndexedVertices>
		<drawSomeIndexedVertices public="1" set="method" line="424">
			<f a="start:count">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tKore::Graphics::drawIndexedVertices(start, count);\r\n\t"</e></m></meta>
		</drawSomeIndexedVertices>
		<renderToTexture set="method" line="429">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e><![CDATA["Kore::Graphics::setRenderTarget(target->renderTarget, 0);"]]></e></m></meta>
		</renderToTexture>
		<renderToBackbuffer set="method" line="434">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"Kore::Graphics::restoreRenderTarget();"</e></m></meta>
		</renderToBackbuffer>
		<begin public="1" set="method" line="438"><f a=""><x path="Void"/></f></begin>
		<end public="1" set="method" line="443"><f a=""><x path="Void"/></f></end>
		<flush public="1" set="method" line="448">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"Kore::Graphics::flush();"</e></m></meta>
		</flush>
		<new public="1" set="method" line="34"><f a="?target">
	<c path="kha.Image"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Graphics/Graphics.h>\r\n"]]></e></m>
		</meta>
	</class>
	<class path="kha.kore.graphics4.Graphics2" params="" file="Kha/Backends/Kore/kha/kore/graphics4/Graphics2.hx">
		<extends path="kha.graphics4.Graphics2"/>
		<drawVideoInternal public="1" set="method" line="13" override="1"><f a="video:x:y:width:height">
	<c path="kha.Video"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawVideoInternal>
		<new public="1" set="method" line="9"><f a="canvas">
	<c path="kha.Canvas"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.kore.graphics4.TextureUnit" params="" file="Kha/Backends/Kore/kha/kore/graphics4/TextureUnit.hx">
		<implements path="kha.graphics4.TextureUnit"/>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerCode"><e><![CDATA["\r\n#include <Kore/pch.h>\r\n#include <Kore/Graphics/Graphics.h>\r\n"]]></e></m>
			<m n=":headerClassCode"><e>"Kore::TextureUnit unit;"</e></m>
		</meta>
	</class>
	<class path="kha.loader.Room" params="" file="Kha/Sources/kha/loader/Room.hx">
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of the group.</haxe_doc>
		</name>
		<assets public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* The group of asset objects.</haxe_doc>
		</assets>
		<parent public="1">
			<c path="kha.loader.Room"/>
			<haxe_doc>* The parent group.</haxe_doc>
		</parent>
		<new public="1" set="method" line="25">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new group.
	 *
	 * @param name		The group name.</haxe_doc>
		</new>
		<haxe_doc>* A group of resources that can be loaded.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.math.Matrix3" params="" file="Kha/Sources/kha/math/Matrix3.hx">
		<width get="inline" set="null" line="4" static="1"><x path="Int"/></width>
		<height get="inline" set="null" line="5" static="1"><x path="Int"/></height>
		<translation public="1" get="inline" set="null" line="32" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></translation>
		<empty public="1" get="inline" set="null" line="40" static="1"><f a=""><c path="kha.math.Matrix3"/></f></empty>
		<identity public="1" get="inline" set="null" line="48" static="1"><f a=""><c path="kha.math.Matrix3"/></f></identity>
		<scale public="1" get="inline" set="null" line="56" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></scale>
		<rotation public="1" set="method" line="64" static="1"><f a="alpha">
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></rotation>
		<_00 public="1"><x path="Float"/></_00>
		<_10 public="1"><x path="Float"/></_10>
		<_20 public="1"><x path="Float"/></_20>
		<_01 public="1"><x path="Float"/></_01>
		<_11 public="1"><x path="Float"/></_11>
		<_21 public="1"><x path="Float"/></_21>
		<_02 public="1"><x path="Float"/></_02>
		<_12 public="1"><x path="Float"/></_12>
		<_22 public="1"><x path="Float"/></_22>
		<add public="1" get="inline" set="null" line="72"><f a="m">
	<c path="kha.math.Matrix3"/>
	<c path="kha.math.Matrix3"/>
</f></add>
		<sub public="1" get="inline" set="null" line="80"><f a="m">
	<c path="kha.math.Matrix3"/>
	<c path="kha.math.Matrix3"/>
</f></sub>
		<mult public="1" get="inline" set="null" line="88"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></mult>
		<transpose public="1" get="inline" set="null" line="96"><f a=""><c path="kha.math.Matrix3"/></f></transpose>
		<trace public="1" get="inline" set="null" line="104"><f a=""><x path="Float"/></f></trace>
		<multmat public="1" get="inline" set="null" line="108"><f a="m">
	<c path="kha.math.Matrix3"/>
	<c path="kha.math.Matrix3"/>
</f></multmat>
		<multvec public="1" get="inline" set="null" line="116"><f a="value">
	<c path="kha.math.Vector2"/>
	<c path="kha.math.Vector2"/>
</f></multvec>
		<new public="1" get="inline" set="null" line="11"><f a="_00:_10:_20:_01:_11:_21:_02:_12:_22">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.math.Matrix4" params="" file="Kha/Sources/kha/math/Matrix4.hx">
		<width get="inline" set="null" line="4" static="1"><x path="Int"/></width>
		<height get="inline" set="null" line="5" static="1"><x path="Int"/></height>
		<translation public="1" get="inline" set="null" line="22" static="1"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></translation>
		<empty public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="kha.math.Matrix4"/></f></empty>
		<identity public="1" get="inline" set="null" line="40" static="1"><f a=""><c path="kha.math.Matrix4"/></f></identity>
		<scale public="1" get="inline" set="null" line="49" static="1"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></scale>
		<rotationX public="1" get="inline" set="null" line="58" static="1"><f a="alpha">
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></rotationX>
		<rotationY public="1" get="inline" set="null" line="69" static="1"><f a="alpha">
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></rotationY>
		<rotationZ public="1" get="inline" set="null" line="80" static="1"><f a="alpha">
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></rotationZ>
		<rotation public="1" get="inline" set="null" line="91" static="1"><f a="yaw:pitch:roll">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></rotation>
		<orthogonalProjection public="1" set="method" line="107" static="1"><f a="left:right:bottom:top:zn:zf">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></orthogonalProjection>
		<perspectiveProjection public="1" set="method" line="119" static="1"><f a="fovY:aspect:zn:zf">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></perspectiveProjection>
		<lookAt public="1" set="method" line="130" static="1"><f a="eye:at:up">
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Matrix4"/>
</f></lookAt>
		<_00 public="1"><x path="Float"/></_00>
		<_10 public="1"><x path="Float"/></_10>
		<_20 public="1"><x path="Float"/></_20>
		<_30 public="1"><x path="Float"/></_30>
		<_01 public="1"><x path="Float"/></_01>
		<_11 public="1"><x path="Float"/></_11>
		<_21 public="1"><x path="Float"/></_21>
		<_31 public="1"><x path="Float"/></_31>
		<_02 public="1"><x path="Float"/></_02>
		<_12 public="1"><x path="Float"/></_12>
		<_22 public="1"><x path="Float"/></_22>
		<_32 public="1"><x path="Float"/></_32>
		<_03 public="1"><x path="Float"/></_03>
		<_13 public="1"><x path="Float"/></_13>
		<_23 public="1"><x path="Float"/></_23>
		<_33 public="1"><x path="Float"/></_33>
		<add public="1" set="method" line="144"><f a="m">
	<c path="kha.math.Matrix4"/>
	<c path="kha.math.Matrix4"/>
</f></add>
		<sub public="1" set="method" line="153"><f a="m">
	<c path="kha.math.Matrix4"/>
	<c path="kha.math.Matrix4"/>
</f></sub>
		<mult public="1" set="method" line="162"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></mult>
		<transpose public="1" set="method" line="171"><f a=""><c path="kha.math.Matrix4"/></f></transpose>
		<transpose3x3 public="1" set="method" line="180"><f a=""><c path="kha.math.Matrix4"/></f></transpose3x3>
		<trace public="1" set="method" line="189"><f a=""><x path="Float"/></f></trace>
		<multmat public="1" get="inline" set="null" line="193"><f a="m">
	<c path="kha.math.Matrix4"/>
	<c path="kha.math.Matrix4"/>
</f></multmat>
		<multvec public="1" get="inline" set="null" line="202"><f a="value">
	<c path="kha.math.Vector4"/>
	<c path="kha.math.Vector4"/>
</f></multvec>
		<determinant public="1" get="inline" set="null" line="211"><f a=""><x path="Float"/></f></determinant>
		<new public="1" get="inline" set="null" line="12"><f a="_00:_10:_20:_30:_01:_11:_21:_31:_02:_12:_22:_32:_03:_13:_23:_33">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.math.Quaternion" params="" file="Kha/Sources/kha/math/Quaternion.hx">
		<fromAxisAngle public="1" set="method" line="22" static="1"><f a="axis:radians">
	<c path="kha.math.Vector3"/>
	<x path="Float"/>
	<c path="kha.math.Quaternion"/>
</f></fromAxisAngle>
		<AXIS_X public="1" get="inline" set="null" line="216" static="1"><x path="Int"/></AXIS_X>
		<AXIS_Y public="1" get="inline" set="null" line="217" static="1"><x path="Int"/></AXIS_Y>
		<AXIS_Z public="1" get="inline" set="null" line="218" static="1"><x path="Int"/></AXIS_Z>
		<values><c path="Array"><x path="Float"/></c></values>
		<slerp public="1" set="method" line="32"><f a="t:q">
	<x path="Float"/>
	<c path="kha.math.Quaternion"/>
	<c path="kha.math.Quaternion"/>
</f></slerp>
		<rotated public="1" set="method" line="59"><f a="b">
	<c path="kha.math.Quaternion"/>
	<c path="kha.math.Quaternion"/>
</f></rotated>
		<scaled public="1" set="method" line="69"><f a="scale">
	<x path="Float"/>
	<c path="kha.math.Quaternion"/>
</f></scaled>
		<scale public="1" set="method" line="73"><f a="scale">
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<matrix public="1" set="method" line="80"><f a=""><c path="kha.math.Matrix4"/></f></matrix>
		<get public="1" set="method" line="105"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<set public="1" set="method" line="109"><f a="index:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<z public="1" get="accessor" set="accessor"><x path="Float"/></z>
		<w public="1" get="accessor" set="accessor"><x path="Float"/></w>
		<length public="1" get="accessor" set="accessor"><x path="Float"/></length>
		<get_x public="1" set="method" line="119"><f a=""><x path="Float"/></f></get_x>
		<set_x public="1" set="method" line="123"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_y public="1" set="method" line="127"><f a=""><x path="Float"/></f></get_y>
		<set_y public="1" set="method" line="131"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_z public="1" set="method" line="135"><f a=""><x path="Float"/></f></get_z>
		<set_z public="1" set="method" line="139"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<get_w public="1" set="method" line="143"><f a=""><x path="Float"/></f></get_w>
		<set_w public="1" set="method" line="147"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_w>
		<get_length set="method" line="152"><f a=""><x path="Float"/></f></get_length>
		<set_length set="method" line="156"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<addVector public="1" set="method" line="166"><f a="vec">
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Quaternion"/>
</f></addVector>
		<add public="1" set="method" line="179"><f a="q">
	<c path="kha.math.Quaternion"/>
	<c path="kha.math.Quaternion"/>
</f></add>
		<sub public="1" set="method" line="183"><f a="q">
	<c path="kha.math.Quaternion"/>
	<c path="kha.math.Quaternion"/>
</f></sub>
		<mult public="1" set="method" line="188"><f a="r">
	<c path="kha.math.Quaternion"/>
	<c path="kha.math.Quaternion"/>
</f></mult>
		<normalize public="1" set="method" line="197"><f a=""><x path="Void"/></f></normalize>
		<dot public="1" set="method" line="201"><f a="q">
	<c path="kha.math.Quaternion"/>
	<x path="Float"/>
</f></dot>
		<getEulerAngles public="1" set="method" line="221"><f a="A1:A2:A3:?S:?D">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="kha.math.Vector3"/>
</f></getEulerAngles>
		<new public="1" set="method" line="13"><f a="?x:?y:?z:?w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.math.Vector2" params="" file="Kha/Sources/kha/math/Vector2.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<length public="1" get="accessor" set="accessor"><x path="Float"/></length>
		<get_length set="method" line="13"><f a=""><x path="Float"/></f></get_length>
		<set_length set="method" line="17"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<add public="1" set="method" line="25"><f a="vec">
	<c path="kha.math.Vector2"/>
	<c path="kha.math.Vector2"/>
</f></add>
		<sub public="1" set="method" line="29"><f a="vec">
	<c path="kha.math.Vector2"/>
	<c path="kha.math.Vector2"/>
</f></sub>
		<mult public="1" set="method" line="33"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Vector2"/>
</f></mult>
		<div public="1" set="method" line="37"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Vector2"/>
</f></div>
		<dot public="1" set="method" line="41"><f a="v">
	<c path="kha.math.Vector2"/>
	<x path="Float"/>
</f></dot>
		<normalize public="1" set="method" line="45"><f a=""><x path="Void"/></f></normalize>
		<new public="1" get="inline" set="null" line="4"><f a="?x:?y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.math.Vector3" params="" file="Kha/Sources/kha/math/Vector3.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<length public="1" get="accessor" set="accessor"><x path="Float"/></length>
		<get_length set="method" line="15"><f a=""><x path="Float"/></f></get_length>
		<set_length set="method" line="19"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<add public="1" set="method" line="28"><f a="vec">
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Vector3"/>
</f></add>
		<sub public="1" set="method" line="32"><f a="vec">
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Vector3"/>
</f></sub>
		<mult public="1" set="method" line="36"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Vector3"/>
</f></mult>
		<dot public="1" set="method" line="40"><f a="v">
	<c path="kha.math.Vector3"/>
	<x path="Float"/>
</f></dot>
		<cross public="1" set="method" line="44"><f a="v">
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Vector3"/>
</f></cross>
		<normalize public="1" set="method" line="51"><f a=""><x path="Void"/></f></normalize>
		<new public="1" set="method" line="4"><f a="?x:?y:?z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.math.Vector4" params="" file="Kha/Sources/kha/math/Vector4.hx">
		<values><c path="Array"><x path="Float"/></c></values>
		<get public="1" set="method" line="14"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<set public="1" set="method" line="18"><f a="index:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<z public="1" get="accessor" set="accessor"><x path="Float"/></z>
		<w public="1" get="accessor" set="accessor"><x path="Float"/></w>
		<length public="1" get="accessor" set="accessor"><x path="Float"/></length>
		<get_x public="1" set="method" line="28"><f a=""><x path="Float"/></f></get_x>
		<set_x public="1" set="method" line="32"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_y public="1" set="method" line="36"><f a=""><x path="Float"/></f></get_y>
		<set_y public="1" set="method" line="40"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_z public="1" set="method" line="44"><f a=""><x path="Float"/></f></get_z>
		<set_z public="1" set="method" line="48"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<get_w public="1" set="method" line="52"><f a=""><x path="Float"/></f></get_w>
		<set_w public="1" set="method" line="56"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_w>
		<get_length set="method" line="60"><f a=""><x path="Float"/></f></get_length>
		<set_length set="method" line="64"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<add public="1" set="method" line="73"><f a="vec">
	<c path="kha.math.Vector4"/>
	<c path="kha.math.Vector4"/>
</f></add>
		<sub public="1" set="method" line="77"><f a="vec">
	<c path="kha.math.Vector4"/>
	<c path="kha.math.Vector4"/>
</f></sub>
		<mult public="1" set="method" line="81"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Vector4"/>
</f></mult>
		<new public="1" set="method" line="6"><f a="?x:?y:?z:?w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.networking.Controller" params="" file="Kha/Sources/kha/networking/Controller.hx" interface="1">
		<_id public="1" set="method"><f a=""><x path="Int"/></f></_id>
		<_receive public="1" set="method"><f a="offset:bytes">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></_receive>
		<meta><m n=":autoBuild"><e>kha.networking.ControllerBuilder.build()</e></m></meta>
	</class>
	<class path="kha.vr.Pose" params="" file="Kha/Sources/kha/vr/Pose.hx">
		<Orientation public="1"><c path="kha.math.Quaternion"/></Orientation>
		<Position public="1"><c path="kha.math.Vector3"/></Position>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.vr.PoseState" params="" file="Kha/Sources/kha/vr/PoseState.hx">
		<Pose public="1"><c path="kha.vr.Pose"/></Pose>
		<AngularVelocity public="1"><c path="kha.math.Vector3"/></AngularVelocity>
		<LinearVelocity public="1"><c path="kha.math.Vector3"/></LinearVelocity>
		<AngularAcceleration public="1"><c path="kha.math.Vector3"/></AngularAcceleration>
		<LinearAcceleration public="1"><c path="kha.math.Vector3"/></LinearAcceleration>
		<TimeInSeconds public="1"><x path="Float"/></TimeInSeconds>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.vr.SensorState" params="" file="Kha/Sources/kha/vr/SensorState.hx">
		<Predicted public="1"><c path="kha.vr.PoseState"/></Predicted>
		<Recorded public="1"><c path="kha.vr.PoseState"/></Recorded>
		<Temperature public="1"><x path="Float"/></Temperature>
		<Status public="1"><x path="Int"/></Status>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.vr.TimeWarpImage" params="" file="Kha/Sources/kha/vr/TimeWarpImage.hx">
		<Image public="1"><c path="kha.Image"/></Image>
		<TexCoordsFromTanAngles public="1"><c path="kha.math.Matrix4"/></TexCoordsFromTanAngles>
		<Pose public="1"><c path="kha.vr.PoseState"/></Pose>
		<new public="1" set="method" line="40"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="kha.vr.TimeWarpParms" params="" file="Kha/Sources/kha/vr/TimeWarpParms.hx">
		<LeftImage public="1"><c path="kha.vr.TimeWarpImage"/></LeftImage>
		<RightImage public="1"><c path="kha.vr.TimeWarpImage"/></RightImage>
		<LeftOverlay public="1"><c path="kha.vr.TimeWarpImage"/></LeftOverlay>
		<RightOverlay public="1"><c path="kha.vr.TimeWarpImage"/></RightOverlay>
		<new public="1" set="method" line="53"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="kha.vr.VrInterface" params="" file="Kha/Sources/kha/vr/VrInterface.hx">
		<instance public="1" static="1"><c path="kha.vr.VrInterface"/></instance>
		<GetSensorState public="1" set="method" line="11"><f a=""><c path="kha.vr.SensorState"/></f></GetSensorState>
		<GetPredictedSensorState public="1" set="method" line="16"><f a="time">
	<x path="Float"/>
	<c path="kha.vr.SensorState"/>
</f></GetPredictedSensorState>
		<WarpSwapBlack public="1" set="method" line="21"><f a=""><x path="Void"/></f></WarpSwapBlack>
		<WarpSwapLoadingIcon public="1" set="method" line="26"><f a=""><x path="Void"/></f></WarpSwapLoadingIcon>
		<WarpSwap public="1" set="method" line="31"><f a="parms">
	<c path="kha.vr.TimeWarpParms"/>
	<x path="Void"/>
</f></WarpSwap>
		<GetTimeInSeconds public="1" set="method" line="37"><f a=""><x path="Float"/></f></GetTimeInSeconds>
		<new set="method" line="43"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.vr.VrInterfaceEmulated" params="" file="Kha/Sources/kha/vr/VrInterfaceEmulated.hx">
		<extends path="kha.vr.VrInterface"/>
		<keyboardSpeed get="inline" set="null" line="47" static="1"><x path="Float"/></keyboardSpeed>
		<mouseSpeed get="inline" set="null" line="49" static="1"><x path="Float"/></mouseSpeed>
		<minPitchDegrees get="inline" set="null" line="51" static="1"><x path="Float"/></minPitchDegrees>
		<maxPitchDegrees get="inline" set="null" line="52" static="1"><x path="Float"/></maxPitchDegrees>
		<framebuffer public="1"><c path="kha.Framebuffer"/></framebuffer>
		<orientation><c path="kha.math.Quaternion"/></orientation>
		<pitchDegrees><x path="Float"/></pitchDegrees>
		<yawDegrees><x path="Float"/></yawDegrees>
		<pitchDelta><x path="Float"/></pitchDelta>
		<yawDelta><x path="Float"/></yawDelta>
		<degreesToRadians set="method" line="54"><f a="degrees">
	<x path="Float"/>
	<x path="Float"/>
</f></degreesToRadians>
		<updateOrientation set="method" line="59"><f a=""><x path="Void"/></f></updateOrientation>
		<buttonEvent set="method" line="79"><f a="button:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></buttonEvent>
		<axisEvent set="method" line="83"><f a="axis:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></axisEvent>
		<keyDownEvent set="method" line="87"><f a="key:char">
	<e path="kha.Key"/>
	<c path="String"/>
	<x path="Void"/>
</f></keyDownEvent>
		<keyUpEvent set="method" line="108"><f a="key:char">
	<e path="kha.Key"/>
	<c path="String"/>
	<x path="Void"/>
</f></keyUpEvent>
		<oldMouseX><x path="Int"/></oldMouseX>
		<oldMouseY><x path="Int"/></oldMouseY>
		<mouseMoveEvent set="method" line="131"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseMoveEvent>
		<mouseButtonDown><x path="Bool"/></mouseButtonDown>
		<mouseButtonDownEvent set="method" line="151"><f a="button:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseButtonDownEvent>
		<mouseButtonUpEvent set="method" line="159"><f a="button:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseButtonUpEvent>
		<GetSensorState public="1" set="method" line="169" override="1"><f a=""><c path="kha.vr.SensorState"/></f></GetSensorState>
		<GetPredictedSensorState public="1" set="method" line="175" override="1"><f a="time">
	<x path="Float"/>
	<c path="kha.vr.SensorState"/>
</f></GetPredictedSensorState>
		<WarpSwapBlack public="1" set="method" line="202" override="1"><f a=""><x path="Void"/></f></WarpSwapBlack>
		<WarpSwapLoadingIcon public="1" set="method" line="208" override="1"><f a=""><x path="Void"/></f></WarpSwapLoadingIcon>
		<WarpSwap public="1" set="method" line="213" override="1"><f a="parms">
	<c path="kha.vr.TimeWarpParms"/>
	<x path="Void"/>
</f></WarpSwap>
		<GetTimeInSeconds public="1" set="method" line="240" override="1"><f a=""><x path="Float"/></f></GetTimeInSeconds>
		<vb><c path="kha.graphics4.VertexBuffer"/></vb>
		<ib><c path="kha.graphics4.IndexBuffer"/></ib>
		<program><c path="kha.graphics4.Program"/></program>
		<setVertex set="method" line="251"><f a="a:index:pos:uv:color">
	<x path="haxe.io.Float32Array"/>
	<x path="Int"/>
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Vector2"/>
	<c path="kha.math.Vector4"/>
	<x path="Void"/>
</f></setVertex>
		<new public="1" set="method" line="265"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.util.interfaces.ISpiDestroyable" params="" file="Libs/spiller/util/interfaces/ISpiDestroyable.hx" interface="1">
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Call this method to destroy the object and all it's content.</haxe_doc>
		</destroy>
		<haxe_doc><![CDATA[* Generic inferface for a destroyable object.
 * 
 * v1.0 Initial version<br>
 * <br>
 * @version 1.0 - 18/04/2015
 * @author ratalaika / ratalaikaGames]]></haxe_doc>
	</class>
	<class path="spiller.SpiBasic" params="" file="Libs/spiller/SpiBasic.hx">
		<implements path="spiller.util.interfaces.ISpiDestroyable"/>
		<ACTIVECOUNT public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Number of active SpiBasics in the game.</haxe_doc>
		</ACTIVECOUNT>
		<VISIBLECOUNT public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Number of visible SpiBasics in the game.</haxe_doc>
		</VISIBLECOUNT>
		<ID public="1">
			<x path="Int"/>
			<haxe_doc>* IDs seem like they could be pretty useful, huh?
	 * They're not actually used for anything yet though.</haxe_doc>
		</ID>
		<exists public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>update():Void</code> and <code>draw():Void</code> are automatically called by SpiState/SpiGroup.]]></haxe_doc>
		</exists>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>update():Void</code> is automatically called by SpiState/SpiGroup.]]></haxe_doc>
		</active>
		<visible public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>draw():Void</code> is automatically called by SpiState/SpiGroup.]]></haxe_doc>
		</visible>
		<alive public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Useful state for many game objects - "dead" (!alive) vs alive.
	 * <code>kill():Void</code> and <code>revive():Void</code> both flip this switch (along with exists, but you can override that).]]></haxe_doc>
		</alive>
		<cameras public="1">
			<c path="Array"><c path="spiller.SpiCamera"/></c>
			<haxe_doc><![CDATA[* An array of camera objects that this object will use during <code>draw():Void</code>.
	 * This value will initialize itself during the first draw to automatically
	 * point at the main camera list out in <code>SpiG</code> unless you already set it.
	 * You can also change it afterward too, very flexible!]]></haxe_doc>
		</cameras>
		<ignoreDrawDebug public="1">
			<x path="Bool"/>
			<haxe_doc>* Setting this to true will prevent the object from appearing
	 * when the visual debug mode in the debugger overlay is toggled on.</haxe_doc>
		</ignoreDrawDebug>
		<autoClear public="1">
			<x path="Bool"/>
			<haxe_doc>* If the Tweener should clear on removal. For Entities, this is when they are
	 * removed from a World, and for World this is when the active World is switched.</haxe_doc>
		</autoClear>
		<_tween>
			<c path="spiller.plugin.tweens.SpiTween"/>
			<haxe_doc>* The SpiTween reference.</haxe_doc>
		</_tween>
		<destroy public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Override this function to null out variables or manually call
	 * <code>destroy():Void</code> on class members if necessary.
	 * Don't forget to call <code>super.destroy():Void</code>!]]></haxe_doc>
		</destroy>
		<preUpdate public="1" set="method" line="104">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Pre-update is called right before <code>update():Void</code> on each object in the game loop.]]></haxe_doc>
		</preUpdate>
		<update public="1" set="method" line="113">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this function to update your class's position and appearance.
	 * This is where most of your game rules and behavioral code will go.</haxe_doc>
		</update>
		<postUpdate public="1" set="method" line="121">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Post-update is called right after <code>update():Void</code> on each object in the game loop.]]></haxe_doc>
		</postUpdate>
		<draw public="1" set="method" line="130">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Override this function to control how the object is drawn.
	 * Overriding <code>draw():Void</code> is rarely necessary, but can be very useful.]]></haxe_doc>
		</draw>
		<drawDebug public="1" set="method" line="150">
			<f a="?Camera">
				<c path="spiller.SpiCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this function to draw custom "debug mode" graphics to the
	 * specified camera while the debugger's visual mode is toggled on.
	 * 
	 * @param	Camera	Which camera to draw the debug visuals to.</haxe_doc>
		</drawDebug>
		<kill public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Handy function for "killing" game objects.
	 * Default behavior is to flag them as nonexistent AND dead.
	 * However, if you want the "corpse" to remain in the game,
	 * like to animate an effect or whatever, you should override this,
	 * setting only alive to false, and leaving exists true.</haxe_doc>
		</kill>
		<revive public="1" set="method" line="172">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Handy function for bringing game objects "back to life". Just sets alive and exists back to true.
	 * In practice, this function is most often called by <code>SpiObject.reset():Void</code>.]]></haxe_doc>
		</revive>
		<toString public="1" set="method" line="181">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name.  Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<addTween public="1" set="method" line="197">
			<f a="t:start">
				<c path="spiller.plugin.tweens.SpiTween"/>
				<x path="Bool"/>
				<c path="spiller.plugin.tweens.SpiTween"/>
			</f>
			<haxe_doc>* Add a new SpiTween instance to this object.
	 * 
	 * @param t			The SpiTween instance.
	 * @param start		True if it should start.
	 * @return			The t instance.</haxe_doc>
		</addTween>
		<removeTween public="1" set="method" line="224">
			<f a="t:?destroy">
				<c path="spiller.plugin.tweens.SpiTween"/>
				<x path="Bool"/>
				<c path="spiller.plugin.tweens.SpiTween"/>
			</f>
			<haxe_doc>* Remove a new SpiTween instance to this object.
	 * 
	 * @param t			The SpiTween instance.
	 * @param destroy	True if it should be destroyed.
	 * @return			The t instance.</haxe_doc>
		</removeTween>
		<clearTweens public="1" set="method" line="251">
			<f a="?destroy">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Clear all the game tweens.
	 * 
	 * @param destroy		True if they should be destroyed.</haxe_doc>
		</clearTweens>
		<updateTweens public="1" set="method" line="266">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update the SpiBasic tweens.</haxe_doc>
		</updateTweens>
		<hasTween public="1" set="method" line="288">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Return true if the SpiBasic has a tween.
	 * 
	 * @return		True if the SpiBasic has a tween.</haxe_doc>
		</hasTween>
		<new public="1" set="method" line="75">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiate the basic spiller object.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is a useful "generic" spiller object.
 * Both <code>SpiObject</code> and <code>SpiGroup</code> extend this class,
 * as do the plugins.  Has no size, position or graphical data.
 * 
 * v1.0 Initial version
 * 
 * @version 1.0 - 27/03/2013
 * @author ratalaika / ratalaikaGames
 * @author Ka Wing Chin]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.SpiCamera" params="" file="Libs/spiller/SpiCamera.hx">
		<extends path="spiller.SpiBasic"/>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* The camera class is used to display the game's visuals in the Flash player.<br>
 * By default one camera is created automatically, that is the same size as the Flash player.<br>
 * You can add more cameras or even replace the main camera using utilities in <code>SpiG</code>.<br>
 * <br>
 * v1.0 Initial version
 * 
 * @version 1.0 - 17/07/2013
 * @author ratalaika / ratalaikaGames
 * @author Ka Wing Chin]]></haxe_doc>
	</class>
	<class path="spiller.SpiG" params="" file="Libs/spiller/SpiG.hx">
		<elapsed public="1" static="1">
			<x path="Float"/>
			<haxe_doc>* Represents the amount of time in seconds that passed since last frame.</haxe_doc>
		</elapsed>
		<visualDebug public="1" static="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to show visual debug displays or not.
	 * Default = false.</haxe_doc>
		</visualDebug>
		<cameras public="1" static="1">
			<c path="Array"><c path="spiller.SpiCamera"/></c>
			<haxe_doc><![CDATA[* An array of <code>SpiCamera</code> objects that are used to draw stuff.
	 * By default spiller creates one camera the size of the screen.]]></haxe_doc>
		</cameras>
		<displayList public="1" static="1">
			<c path="Array"><c path="spiller.SpiCamera"/></c>
			<haxe_doc>* Internal, keeps track of all the cameras that would have been added
	 * to the stage in Flash.</haxe_doc>
		</displayList>
		<camera public="1" static="1">
			<c path="spiller.SpiCamera"/>
			<haxe_doc>* By default this just refers to the first entry in the cameras array
	 * declared above, but you can do what you like with it.</haxe_doc>
		</camera>
		<activeCamera static="1">
			<c path="spiller.SpiCamera"/>
			<haxe_doc>* The camera currently being drawn.</haxe_doc>
		</activeCamera>
		<log public="1" set="method" line="471" static="1">
			<f a="?tag:?data:?showThreadName">
				<c path="String"/>
				<a><toString set="null"><f a=""><c path="String"/></f></toString></a>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Log data to the debugger.
	 * 
	 * @param tag					The tag you want to show in the console or cat log.
	 * @param data					Anything you want to log to the console.
	 * @param showThreadName		If the log prints the Thread name or not.</haxe_doc>
		</log>
		<getActiveCamera public="1" set="method" line="1835" static="1">
			<f a=""><c path="spiller.SpiCamera"/></f>
			<haxe_doc>* Read-only: gets the current SpiCamera.</haxe_doc>
		</getActiveCamera>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>spiller</e></m>
		</meta>
	</class>
	<class path="spiller.util.interfaces.ISpiPoolable" params="" file="Libs/spiller/util/interfaces/ISpiPoolable.hx" interface="1">
		<extends path="spiller.util.interfaces.ISpiDestroyable"/>
		<put public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Put the object on a pool.</haxe_doc>
		</put>
		<haxe_doc><![CDATA[* Generic interface for poolable objects.
 * 
 * v1.0 Initial version<br>
 * <br>
 * @version 1.0 - 18/04/2015
 * @author ratalaika / ratalaikaGames]]></haxe_doc>
	</class>
	<class path="spiller.util.SpiPool" params="T" file="Libs/spiller/util/SpiPool.hx">
		<_pool>
			<c path="Array"><c path="spiller.util.SpiPool.T"/></c>
			<haxe_doc>* Internal, stores the pooled objects.</haxe_doc>
		</_pool>
		<dispose public="1" set="method" line="43">
			<f a="obj">
				<c path="spiller.util.SpiPool.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Put an object back in the pool.
	 * 
	 * @param Object	The object to pool.</haxe_doc>
		</dispose>
		<remove public="1" set="method" line="53">
			<f a="obj">
				<c path="spiller.util.SpiPool.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove an object from the pool.
	 * 
	 * @param Object	The object to remove.</haxe_doc>
		</remove>
		<getNew public="1" set="method" line="64">
			<f a=""><c path="spiller.util.SpiPool.T"/></f>
			<haxe_doc>* Gets an object from the pool. If the pool is empty, returns
	 * a new object.
	 * 
	 * @return	A new object.</haxe_doc>
		</getNew>
		<create set="method" line="79">
			<f a=""><c path="spiller.util.SpiPool.T"/></f>
			<haxe_doc>* Instantiates a new object.
	 * 
	 * @return A new object.</haxe_doc>
		</create>
		<get public="1" set="method" line="89">
			<f a="index">
				<x path="Int"/>
				<c path="spiller.util.SpiPool.T"/>
			</f>
			<haxe_doc><![CDATA[* Get a specific element from the pool array.<br>
	 * Use this only in really specific situations.]]></haxe_doc>
		</get>
		<size public="1" set="method" line="97">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the total amount of elements in the pool.</haxe_doc>
		</size>
		<new public="1" set="method" line="28">
			<f a="?StartSize">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * 
	 * @param StartSize		How many objects to initially create. Optional.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A very basic object pool. Used by <code>SpiQuadTree</code> and<br>
 * <code>SpiList</code> to avoid costly instantiations every frame.<br>
 * <br>
 * @param <T>	The type of object to store in this pool.<br>
 * <br>
 * v1.0 Initial version<br>
 * 
 * @version 1.0 - 25/04/2013
 * @author ratalaika / ratalaikaGames
 * @author Thomas Weston]]></haxe_doc>
	</class>
	<class path="spiller.math.SpiPointPool" params="" file="Libs/spiller/math/SpiPoint.hx" module="spiller.math.SpiPoint">
		<extends path="spiller.util.SpiPool"><c path="spiller.math.SpiPoint"/></extends>
		<create public="1" set="method" line="607" override="1"><f a=""><c path="spiller.math.SpiPoint"/></f></create>
		<new public="1" set="method" line="604"><f a="?StartSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>spiller.math.SpiPoint.new</e></m>
		</meta>
	</class>
	<class path="spiller.math.SpiPoint" params="" file="Libs/spiller/math/SpiPoint.hx">
		<implements path="spiller.util.interfaces.ISpiPoolable"/>
		<TO_RADIANS public="1" line="25" static="1">
			<x path="Float"/>
			<haxe_doc>* Constant to convert degree angles into radial angles.</haxe_doc>
		</TO_RADIANS>
		<TO_DEGREES public="1" line="29" static="1">
			<x path="Float"/>
			<haxe_doc>* Constant to convert radial angles into degree angles.</haxe_doc>
		</TO_DEGREES>
		<_pool line="33" static="1">
			<c path="spiller.math.SpiPointPool"/>
			<haxe_doc>* The pool.</haxe_doc>
		</_pool>
		<get public="1" set="method" line="43" static="1">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Recycle or create a new SpiPoint. 
	 * Be sure to put() them back into the pool after you're done with them!
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @return	This point.</haxe_doc>
		</get>
		<weak public="1" set="method" line="58" static="1">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Recycle or create a new SpiPoint which will automatically be released 
	 * to the pool when passed into a spiller function.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @return	This point.</haxe_doc>
		</weak>
		<poolStatus public="1" set="method" line="594" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Return the pool status.</haxe_doc>
		</poolStatus>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X coordinate of the point.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y coordinate of the point.</haxe_doc>
		</y>
		<_weak>
			<x path="Bool"/>
			<haxe_doc>* If the point is a weak reference.</haxe_doc>
		</_weak>
		<_inPool>
			<x path="Bool"/>
			<haxe_doc>* If the point is on the pool.</haxe_doc>
		</_inPool>
		<put public="1" set="method" line="97">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this SpiPoint to the recycling pool.</haxe_doc>
		</put>
		<putWeak public="1" set="method" line="109">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this SpiPoint to the recycling pool if it's a weak reference (allocated via weak()).</haxe_doc>
		</putWeak>
		<make public="1" set="method" line="122">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Instantiate a new point object.
	 * 
	 * @param X The X-coordinate of the point in space.
	 * @param Y The Y-coordinate of the point in space.</haxe_doc>
		</make>
		<copyFrom public="1" set="method" line="136">
			<f a="point">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified point.
	 * 
	 * @param Point Any <code>SpiPoint</code>.
	 * 
	 * @return A reference to itself.]]></haxe_doc>
		</copyFrom>
		<copyTo public="1" set="method" line="152">
			<f a="point">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this point to the specified point.
	 * 
	 * @param Point Any <code>SpiPoint</code>.
	 * 
	 * @return A reference to the altered point parameter.]]></haxe_doc>
		</copyTo>
		<copyFromFlash public="1" set="method" line="170">
			<f a="FlashPoint">
				<c path="kha.math.Vector2"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified libgdx vector.
	 * 
	 * @param Point Any <code>Point</code>.
	 * 
	 * @return A reference to itself.]]></haxe_doc>
		</copyFromFlash>
		<copyToFlash public="1" set="method" line="184">
			<f a="FlashPoint">
				<c path="kha.math.Vector2"/>
				<c path="kha.math.Vector2"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this point to the specified libgdx vector.
	 * 
	 * @param Point Any <code>Point</code>.
	 * 
	 * @return A reference to the altered point parameter.]]></haxe_doc>
		</copyToFlash>
		<add public="1" set="method" line="198">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method add to its coordinates the X and Y values passed.
	 * 
	 * @param x The X coordinate.
	 * @param y The Y coordinate.
	 * @return The vector itself.</haxe_doc>
		</add>
		<addPoint public="1" set="method" line="211">
			<f a="other">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method add to its coordinates the vector passed coordinates.
	 * 
	 * @param other The vector to add with.
	 * @return The vector itself.</haxe_doc>
		</addPoint>
		<subtract public="1" set="method" line="226">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method sub to its coordinates the X and Y values passed.
	 * 
	 * @param x The X coordinate.
	 * @param y The Y coordinate.
	 * @return The vector itself.</haxe_doc>
		</subtract>
		<subtractPoint public="1" set="method" line="239">
			<f a="other">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method sub to its coordinates the vector passed coordinates.
	 * 
	 * @param other The vector to sub with.
	 * @return The vector itself.</haxe_doc>
		</subtractPoint>
		<mul public="1" set="method" line="253">
			<f a="scalar">
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method multiply a vector for a scalar value.
	 * 
	 * @param scalar The scalar number we want to multiply with.
	 * @return The vector itself.</haxe_doc>
		</mul>
		<length public="1" set="method" line="265">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* This method calculates the length of the vector.
	 * 
	 * @return The length of the vector.</haxe_doc>
		</length>
		<lengthSquared public="1" set="method" line="275">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* This method calculates the length of the vector squared.
	 * 
	 * @return The length of the vector.</haxe_doc>
		</lengthSquared>
		<normalize public="1" set="method" line="285">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* This method normalizes the vector to unit length.
	 * 
	 * @return The vector itself.</haxe_doc>
		</normalize>
		<normalizeWithScale public="1" set="method" line="301">
			<f a="scale">
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method normalizes the vector to unit length.
	 * 
	 * @param length The length to normalize with.
	 * @return The vector itself.</haxe_doc>
		</normalizeWithScale>
		<angle public="1" set="method" line="318">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* This method calculates the angle between the X and Y coordinates.
	 * 
	 * @return The angle between X and Y.</haxe_doc>
		</angle>
		<anglePoint public="1" set="method" line="331">
			<f a="other">
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This method calculates the angle between the vector and the given vector.
	 * 
	 * @return The angle between X and Y.</haxe_doc>
		</anglePoint>
		<rotateX public="1" set="method" line="344">
			<f a="angle">
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method rotates the vector X coordinate by a given amount of angles.
	 * 
	 * @param angle The amount we want to rotate the angle.
	 * @return The vector itself.</haxe_doc>
		</rotateX>
		<rotateY public="1" set="method" line="360">
			<f a="angle">
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method rotates the vector Y coordinate by a given amount of angles.
	 * 
	 * @param angle The amount we want to rotate the angle.
	 * @return The vector itself.</haxe_doc>
		</rotateY>
		<rotate public="1" set="method" line="376">
			<f a="angle">
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method rotates the vector by a given amount of angles.
	 * 
	 * @param angle The amount we want to rotate the angle.
	 * @return The vector itself.</haxe_doc>
		</rotate>
		<distToPoint public="1" set="method" line="391">
			<f a="other">
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This method calculates the distance between the vector and the given vector.
	 * 
	 * @param other The vector to calculate the distance with.
	 * @return The distance.</haxe_doc>
		</distToPoint>
		<distToZero public="1" set="method" line="404">
			<f a=""><x path="Float"/></f>
			<meta><m n=":access"><e>spiller.SpiObject</e></m></meta>
			<haxe_doc>* This method calculates the distance between the vector and (0, 0).
	 * 
	 * @return The distance.</haxe_doc>
		</distToZero>
		<dist public="1" set="method" line="416">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This method calculates the distance between the vector and the given coordinates.
	 * 
	 * @param x The X coordinate.
	 * @param y The Y coordinate.
	 * @return The distance.</haxe_doc>
		</dist>
		<distSquaredToPoint public="1" set="method" line="429">
			<f a="other">
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This method calculates the distance between the vector and other vector. This method returns the distance Squared.
	 * 
	 * @param other The vector to calculate the distance with.
	 * @return The distance squared.</haxe_doc>
		</distSquaredToPoint>
		<distSquared public="1" set="method" line="443">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This method calculates the distance between the vector and the given X and Y coordinates. This method returns the distance Squared.
	 * 
	 * @param x The X coordinate.
	 * @param y The Y coordinate.
	 * @return The distance squared.</haxe_doc>
		</distSquared>
		<setFromPoint public="1" set="method" line="453">
			<f a="localPoint">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Handy method to redirect the set to the copy method.</haxe_doc>
		</setFromPoint>
		<set public="1" set="method" line="461">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Handy method to redirect the set to the make method.</haxe_doc>
		</set>
		<inCoords public="1" set="method" line="475">
			<f a="RectX:RectY:RectWidth:RectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this point is within the given rectangular block
	 * 
	 * @param	RectX		The X value of the region to test within
	 * @param	RectY		The Y value of the region to test within
	 * @param	RectWidth	The width of the region to test within
	 * @param	RectHeight	The height of the region to test within
	 * @return	True if the point is within the region, otherwise false</haxe_doc>
		</inCoords>
		<inSpiRect public="1" set="method" line="486">
			<f a="Rect">
				<c path="spiller.math.SpiRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this point is within the given rectangular block
	 * 
	 * @param	Rect	The SpiRect to test within
	 * @return	True if pointX/pointY is within the SpiRect, otherwise false</haxe_doc>
		</inSpiRect>
		<distanceTo public="1" set="method" line="497">
			<f a="AnotherPoint">
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate the distance to another point.
	 * 
	 * @param 	AnotherPoint	A SpiPoint object to calculate the distance to.
	 * @return	The distance between the two points as a Float.</haxe_doc>
		</distanceTo>
		<floor public="1" set="method" line="505">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* Rounds x and y using Math.floor()</haxe_doc>
		</floor>
		<ceil public="1" set="method" line="515">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* Rounds x and y using Math.ceil()</haxe_doc>
		</ceil>
		<round public="1" set="method" line="525">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* Rounds x and y using Math.round()</haxe_doc>
		</round>
		<print public="1" set="method" line="537">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the values in a printable format.
	 * 
	 * @return</haxe_doc>
		</print>
		<toString public="1" set="method" line="547">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the values in a printable format.
	 * 
	 * @return</haxe_doc>
		</toString>
		<equalsToPoint public="1" set="method" line="555">
			<f a="point">
				<c path="spiller.math.SpiPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Equals method for points.</haxe_doc>
		</equalsToPoint>
		<equals public="1" set="method" line="563">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Equals method for points.</haxe_doc>
		</equals>
		<lerp public="1" set="method" line="575">
			<f a="target:alpha">
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Linear interpolation.
	 * 
	 * @param target		Target point.
	 * @param alpha			The alpha value.
	 * @return				This point.</haxe_doc>
		</lerp>
		<destroy public="1" set="method" line="586">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* {@inheritDoc}</haxe_doc>
		</destroy>
		<new set="method" line="88">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new point object.
	 * 
	 * @param X The X-coordinate of the point in space.
	 * @param Y The Y-coordinate of the point in space.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Stores a 2D floating point coordinate.<br>
 * <br>
 * v1.2 Added new equals methods<br>
 * v1.1 Fixed the point ration<br>
 * v1.0 Initial version<br>
 * <br>
 * @version 1.2 - 28/03/2013
 * @author ratalaika / ratalaikaGames
 * @author Ka Wing Chin]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.SpiObject" params="" file="Libs/spiller/SpiObject.hx">
		<extends path="spiller.SpiBasic"/>
		<LEFT public="1" get="inline" set="null" line="32" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "left" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" line="36" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "right" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</RIGHT>
		<UP public="1" get="inline" set="null" line="40" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "up" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</UP>
		<DOWN public="1" get="inline" set="null" line="44" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "down" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</DOWN>
		<NONE public="1" get="inline" set="null" line="48" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case const meaning no collisions, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</NONE>
		<CEILING public="1" get="inline" set="null" line="52" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case const meaning up, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</CEILING>
		<FLOOR public="1" get="inline" set="null" line="56" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case const meaning down, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</FLOOR>
		<WALL public="1" get="inline" set="null" line="60" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case const meaning only the left and right sides, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</WALL>
		<ANY public="1" get="inline" set="null" line="64" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case const meaning any direction, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</ANY>
		<OVERLAP_BIAS public="1" line="71" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The number of pixels the overlap can have before it won't count.<br>
	 * Default value is 4, should be enough for normal games 16x16 or so<br>
	 * for bigger game you may need to increase this to avoid entering on the map.<br>
	 * (Used in <code>separateX()</code> and <code>separateY()</code>).]]></haxe_doc>
		</OVERLAP_BIAS>
		<PREVENT_OVERLAP public="1" line="76" static="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If we want to prevent overlapping of colliding objects.<br>
	 * This is useful to prevent that one objects move inside another a few pixels.]]></haxe_doc>
		</PREVENT_OVERLAP>
		<PATH_FORWARD public="1" get="inline" set="null" line="80" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then stop.</haxe_doc>
		</PATH_FORWARD>
		<PATH_BACKWARD public="1" get="inline" set="null" line="84" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then stop.</haxe_doc>
		</PATH_BACKWARD>
		<PATH_LOOP_FORWARD public="1" get="inline" set="null" line="88" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then directly back to the start, and start over.</haxe_doc>
		</PATH_LOOP_FORWARD>
		<PATH_LOOP_BACKWARD public="1" get="inline" set="null" line="92" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then directly back to the end, and start over.</haxe_doc>
		</PATH_LOOP_BACKWARD>
		<PATH_YOYO public="1" get="inline" set="null" line="96" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then turn around and go back to the start, over and over.</haxe_doc>
		</PATH_YOYO>
		<PATH_HORIZONTAL_ONLY public="1" get="inline" set="null" line="100" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: ignores any vertical component to the path data, only follows side to side.</haxe_doc>
		</PATH_HORIZONTAL_ONLY>
		<PATH_VERTICAL_ONLY public="1" get="inline" set="null" line="104" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: ignores any horizontal component to the path data, only follows up and down.</haxe_doc>
		</PATH_VERTICAL_ONLY>
		<_pZero set="null" line="191" static="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc><![CDATA[* Should always represent (0,0) - useful for different things, for avoiding unnecessary <code>new</code> calls.]]></haxe_doc>
		</_pZero>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* X position of the upper left corner of this object in world space.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* Y position of the upper left corner of this object in world space.</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of this object.</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of this object.</haxe_doc>
		</height>
		<immovable public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether an object will move/alter position after a collision.</haxe_doc>
		</immovable>
		<immovableX public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether an object will move/alter position after a collision in the X.</haxe_doc>
		</immovableX>
		<immovableY public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether an object will move/alter position after a collision in the Y axis.</haxe_doc>
		</immovableY>
		<velocity public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* The basic speed of this object.</haxe_doc>
		</velocity>
		<mass public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The virtual mass of the object. Default value is 1.
	 * Currently only used with <code>elasticity</code> during collision resolution.
	 * Change at your own risk; effects seem crazy unpredictable so far!]]></haxe_doc>
		</mass>
		<elasticity public="1">
			<x path="Float"/>
			<haxe_doc>* The bounciness of this object.  Only affects collisions.  Default value is 0, or "not bouncy at all."</haxe_doc>
		</elasticity>
		<acceleration public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* How fast the speed of this object is changing.
	 * Useful for smooth movement and gravity.</haxe_doc>
		</acceleration>
		<drag public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* This isn't drag exactly, more like deceleration that is only applied
	 * when acceleration is not affecting the sprite.</haxe_doc>
		</drag>
		<maxVelocity public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc><![CDATA[* If you are using <code>acceleration</code>, you can use <code>maxVelocity</code> with it
	 * to cap the speed automatically (very useful!).]]></haxe_doc>
		</maxVelocity>
		<angle public="1">
			<x path="Float"/>
			<haxe_doc>* Set the angle of a sprite to rotate it.
	 * WARNING: rotating sprites decreases rendering
	 * performance for this sprite by a factor of 10x!</haxe_doc>
		</angle>
		<angularVelocity public="1">
			<x path="Float"/>
			<haxe_doc>* This is how fast you want this sprite to spin.</haxe_doc>
		</angularVelocity>
		<angularAcceleration public="1">
			<x path="Float"/>
			<haxe_doc>* How fast the spin speed should change.</haxe_doc>
		</angularAcceleration>
		<angularDrag public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Like <code>drag</code> but for spinning.]]></haxe_doc>
		</angularDrag>
		<maxAngular public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Use in conjunction with <code>angularAcceleration</code> for fluid spin speed control.]]></haxe_doc>
		</maxAngular>
		<scrollFactor public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* A point that can store numbers from 0 to 1 (for X and Y independently)
	 * that governs how much this object is affected by the camera subsystem.
	 * 0 means it never moves, like a HUD element or far background graphic.
	 * 1 means it scrolls along a the same speed as the foreground layer.
	 * scrollFactor is initialized as (1,1) by default.</haxe_doc>
		</scrollFactor>
		<_flicker>
			<x path="Bool"/>
			<haxe_doc>* Internal helper used for retro-style flickering.</haxe_doc>
		</_flicker>
		<_flickerTimer>
			<x path="Float"/>
			<haxe_doc>* Internal helper used for retro-style flickering.</haxe_doc>
		</_flickerTimer>
		<health public="1">
			<x path="Float"/>
			<haxe_doc>* Handy for storing health percentage or armor points or whatever.</haxe_doc>
		</health>
		<_point>
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* This is just a pre-allocated x-y point container to be used however you like</haxe_doc>
		</_point>
		<_rect>
			<c path="spiller.math.SpiRect"/>
			<haxe_doc>* This is just a pre-allocated rectangle container to be used however you like</haxe_doc>
		</_rect>
		<moves public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Set this to false if you want to skip the automatic motion/movement stuff (see <code>updateMotion()</code>).
	 * SpiObject and SpiSprite default to true.
	 * SpiText, SpiTileblock and SpiTilemap default to false.]]></haxe_doc>
		</moves>
		<touching public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts.
	 * Use bitwise operators to check the values stored here, or use touching(), justStartedTouching(), etc.
	 * You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</touching>
		<wasTouching public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts from the previous game loop step.
	 * Use bitwise operators to check the values stored here, or use touching(), justStartedTouching(), etc.
	 * You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</wasTouching>
		<allowCollisions public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating collision directions.
	 * Use bitwise operators to check the values stored here.
	 * Useful for things like one-way platforms (e.g. allowCollisions = UP;)
	 * The accessor "solid" just flips this variable between NONE and ANY.</haxe_doc>
		</allowCollisions>
		<last public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc><![CDATA[* Important variable for collision processing.
	 * By default this value is set automatically during <code>preUpdate()</code>.]]></haxe_doc>
		</last>
		<path public="1">
			<c path="spiller.util.SpiPath"/>
			<haxe_doc><![CDATA[* A reference to a path object.  Null by default, assigned by <code>followPath()</code>.]]></haxe_doc>
		</path>
		<pathSpeed public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The speed at which the object is moving on the path.
	 * When an object completes a non-looping path circuit,
	 * the pathSpeed will be zeroed out, but the <code>path</code> reference
	 * will NOT be nulled out.  So <code>pathSpeed</code> is a good way
	 * to check if this object is currently following a path or not.]]></haxe_doc>
		</pathSpeed>
		<pathAngle public="1">
			<x path="Float"/>
			<haxe_doc>* The angle in degrees between this object and the next node, where 0 is directly upward, and 90 is to the right.</haxe_doc>
		</pathAngle>
		<_pathNodeIndex>
			<x path="Int"/>
			<haxe_doc>* Internal helper, tracks which node of the path this object is moving toward.</haxe_doc>
		</_pathNodeIndex>
		<_pathMode>
			<x path="Int"/>
			<haxe_doc>* Internal tracker for path behavior flags (like looping, horizontal only, etc).</haxe_doc>
		</_pathMode>
		<_pathInc>
			<x path="Int"/>
			<haxe_doc>* Internal helper for node navigation, specifically yo-yo and backwards movement.</haxe_doc>
		</_pathInc>
		<_pathRotate>
			<x path="Bool"/>
			<haxe_doc>* Internal flag for whether the object's angle should be adjusted to the path angle during path follow behavior.</haxe_doc>
		</_pathRotate>
		<_seeked>
			<c path="spiller.SpiObject"/>
			<haxe_doc>* The object you are seeking.</haxe_doc>
		</_seeked>
		<steerForce>
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* The force of the seeker.</haxe_doc>
		</steerForce>
		<categoryBits public="1">
			<x path="Int"/>
			<haxe_doc>* The collision categoryBits.</haxe_doc>
		</categoryBits>
		<maskBits public="1">
			<x path="Int"/>
			<haxe_doc>* The collision maskBits.</haxe_doc>
		</maskBits>
		<groupIndex public="1">
			<x path="Int"/>
			<haxe_doc>* The ground index for collisions.</haxe_doc>
		</groupIndex>
		<_lastTouching>
			<x path="Int"/>
			<haxe_doc><![CDATA[* The information about the last collision.<br>
	 * You can use it on the postCollision method.]]></haxe_doc>
		</_lastTouching>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* This is the base class for most of the display objects<br>
 * (<code>SpiSprite</code>, <code>SpiText</code>, etc).<br>
 * It includes some basic attributes about game objects,<br>
 * including retro-style flickering, basic state information,<br>
 * sizes, scrolling, and basic physics and motion.<br>
 * <br>
 * v1.0 Initial version
 * 
 * @version 1.0 - 17/07/2013
 * @author ratalaika / ratalaikaGames
 * @author Ka Wing Chin
 * @author Thomas Weston]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.math.SpiMath" params="" file="Libs/spiller/math/SpiMath.hx">
		<roundDecimal public="1" set="method" line="58" static="1">
			<f a="num:dec">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Round to the closes number with the number of decimals given. E.g round(2.954165, 2) == 2.95
	 * 
	 * @param num	The number to round.
	 * @param dec 	The number of decimals wanted.
	 * @return The rounded value of that number.</haxe_doc>
		</roundDecimal>
		<bound public="1" get="inline" set="null" line="76" static="1">
			<f a="Value:?Min:?Max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Bound a number by a minimum and maximum. Ensures that this number is 
	 * no smaller than the minimum, and no larger than the maximum.
	 * Leaving a bound null means that side is unbounded.
	 * 
	 * @param	Value	Any number.
	 * @param	Min		Any number.
	 * @param	Max		Any number.
	 * @return	The bounded value of the number.</haxe_doc>
		</bound>
		<pointInCoordinates public="1" set="method" line="94" static="1">
			<f a="pointX:pointY:rectX:rectY:rectWidth:rectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the given rectangular block
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rectX		The X value of the region to test within
	 * @param	rectY		The Y value of the region to test within
	 * @param	rectWidth	The width of the region to test within
	 * @param	rectHeight	The height of the region to test within
	 * 
	 * @return	true if pointX/pointY is within the region, otherwise false</haxe_doc>
		</pointInCoordinates>
		<pointInSpiRect public="1" set="method" line="113" static="1">
			<f a="pointX:pointY:rect">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the given rectangular block
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rect		The SpiRect to test within
	 * @return	true if pointX/pointY is within the SpiRect, otherwise false</haxe_doc>
		</pointInSpiRect>
		<wrapValue public="1" set="method" line="600" static="1">
			<f a="value:amount:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Adds value to amount and ensures that the result always stays between 0 and max, by wrapping the value around.
	 * <p>Values must be positive integers, and are passed through Math.abs</p>
	 * 
	 * @param value The value to add the amount to
	 * @param amount The amount to add to the value
	 * @param max The maximum the value is allowed to be
	 * @return The wrapped value]]></haxe_doc>
		</wrapValue>
		<vectorLength public="1" set="method" line="621" static="1">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Finds the length of the given vector
	 * 
	 * @param	dx
	 * @param	dy
	 * 
	 * @return</haxe_doc>
		</vectorLength>
		<getDistance public="1" set="method" line="879" static="1">
			<f a="Point1:Point2">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate the distance between two points.
	 * 
	 * @param 	Point1		A SpiPoint object referring to the first location.
	 * @param 	Point2		A SpiPoint object referring to the second location.
	 * @return	The distance between the two points as a floating point Number object.</haxe_doc>
		</getDistance>
		<haxe_doc>* Adds a set of fast Math functions and extends a few commonly used ones.
 * 
 * v1.1 Updated some references and commented 
 * v1.0 Initial version
 * 
 * @version 1.1 - 27/02/2013
 * @author ratalaika / ratalaikaGames
 * @author Richard Davey / Photon Storm</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.math.SpiRect" params="" file="Libs/spiller/math/SpiRect.hx">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X coordinate of the point.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y coordinate of the point.</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the rectangle.</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the rectangle.</haxe_doc>
		</height>
		<getLeft public="1" set="method" line="52">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The X coordinate of the left side of the rectangle.  Read-only.</haxe_doc>
		</getLeft>
		<getRight public="1" set="method" line="60">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The X coordinate of the right side of the rectangle.  Read-only.</haxe_doc>
		</getRight>
		<getTop public="1" set="method" line="68">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The Y coordinate of the top of the rectangle.  Read-only.</haxe_doc>
		</getTop>
		<getBottom public="1" set="method" line="76">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The Y coordinate of the bottom of the rectangle.  Read-only.</haxe_doc>
		</getBottom>
		<make public="1" set="method" line="91">
			<f a="?X:?Y:?Width:?Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiRect"/>
			</f>
			<haxe_doc>* Instantiate a new rectangle.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.
	 * 
	 * @return	A reference to itself.</haxe_doc>
		</make>
		<copyFrom public="1" set="method" line="107">
			<f a="Rect">
				<c path="spiller.math.SpiRect"/>
				<c path="spiller.math.SpiRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified rectangle.
	 * 
	 * @param	Rect	Any <code>SpiRect</code>.
	 * 
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFrom>
		<copyTo public="1" set="method" line="123">
			<f a="Rect">
				<c path="spiller.math.SpiRect"/>
				<c path="spiller.math.SpiRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this rectangle to the specified rectangle.
	 * 
	 * @param	Point	Any <code>SpiRect</code>.
	 * 
	 * @return	A reference to the altered rectangle parameter.]]></haxe_doc>
		</copyTo>
		<copyFromFlash public="1" set="method" line="139">
			<f a="FlashRect">
				<c path="kha.Rectangle"/>
				<c path="spiller.math.SpiRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified libgdx rectangle.
	 * 
	 * @param	FlashRect	Any <code>Rectangle</code>.
	 * 
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFromFlash>
		<copyToFlash public="1" set="method" line="155">
			<f a="FlashRect">
				<c path="kha.Rectangle"/>
				<c path="kha.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this rectangle to the specified libgdx rectangle.
	 * 
	 * @param	Point	Any <code>Rectangle</code>.
	 * 
	 * @return	A reference to the altered rectangle parameter.]]></haxe_doc>
		</copyToFlash>
		<overlaps public="1" set="method" line="171">
			<f a="Rect">
				<c path="spiller.math.SpiRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if some <code>SpiRect</code> object overlaps this <code>SpiRect</code> object.
	 * 
	 * @param	Rect	The rectangle being tested.
	 * 
	 * @return	Whether or not the two rectangles overlap.]]></haxe_doc>
		</overlaps>
		<contains public="1" set="method" line="185">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the given coordinates are contained in the rectangle.
	 * 
	 * @param x			The X coordinate.
	 * @param y			The Y coordinate.</haxe_doc>
		</contains>
		<containsPoint public="1" set="method" line="195">
			<f a="point">
				<c path="spiller.math.SpiPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the given coordinates are contained in the rectangle.
	 * 
	 * @param point			The point with the coordinates.</haxe_doc>
		</containsPoint>
		<containsRect public="1" set="method" line="205">
			<f a="rect">
				<c path="spiller.math.SpiRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the given rectangle is contained in the rectangle.
	 * 
	 * @param rect			The rectangle.</haxe_doc>
		</containsRect>
		<intersection public="1" set="method" line="216">
			<f a="toIntersect">
				<c path="spiller.math.SpiRect"/>
				<c path="spiller.math.SpiRect"/>
			</f>
			<haxe_doc>* Returns the intersection of two rectangles.
	 * 
	 * @param toIntersect
	 * @return</haxe_doc>
		</intersection>
		<intersects public="1" set="method" line="238">
			<f a="toIntersect">
				<c path="spiller.math.SpiRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if two rectangles intersect.
	 * 
	 * @param toIntersect
	 * @return</haxe_doc>
		</intersects>
		<isEmpty public="1" set="method" line="247">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if the rectangle is empty.
	 * @return</haxe_doc>
		</isEmpty>
		<print public="1" set="method" line="256">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the values in a printable format.
	 * @return</haxe_doc>
		</print>
		<offset public="1" set="method" line="267">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adjusts the location of the rectangle object.
	 * 
	 * @param dx
	 * @param dy</haxe_doc>
		</offset>
		<new public="1" set="method" line="41">
			<f a="?X:?Y:?Width:?Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new rectangle.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Stores a rectangle.<br>
 * <br>
 * v1.0 Initial version
 * 
 * @version 1.0 - 17/07/2013
 * @author ratalaika / ratalaikaGames
 * @author	Ka Wing Chin]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.plugin.tweens.SpiTween" params="" file="Libs/spiller/plugin/tweens/SpiTween.hx">
		<implements path="spiller.util.interfaces.ISpiDestroyable"/>
		<PERSIST public="1" get="inline" set="null" line="21" static="1">
			<x path="Int"/>
			<haxe_doc>* Persistent Tween type, will stop when it finishes.</haxe_doc>
		</PERSIST>
		<LOOPING public="1" get="inline" set="null" line="25" static="1">
			<x path="Int"/>
			<haxe_doc>* Looping Tween type, will restart immediately when it finishes.</haxe_doc>
		</LOOPING>
		<PINGPONG public="1" get="inline" set="null" line="29" static="1">
			<x path="Int"/>
			<haxe_doc>* "To and from" Tween type, will play tween hither and thither</haxe_doc>
		</PINGPONG>
		<ONESHOT public="1" get="inline" set="null" line="33" static="1">
			<x path="Int"/>
			<haxe_doc>* Oneshot Tween type, will stop and remove itself from its core container when it finishes.</haxe_doc>
		</ONESHOT>
		<BACKWARD public="1" get="inline" set="null" line="37" static="1">
			<x path="Int"/>
			<haxe_doc>* Backward Tween type, will play tween in reverse direction</haxe_doc>
		</BACKWARD>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc>* True if the tweening is active.</haxe_doc>
		</active>
		<complete public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This method will be called when the tween complete.</haxe_doc>
		</complete>
		<percent public="1">
			<x path="Float"/>
			<haxe_doc>* The period of time that tween has completed.</haxe_doc>
		</percent>
		<scale public="1">
			<x path="Float"/>
			<haxe_doc>* The scale of time.</haxe_doc>
		</scale>
		<_type>
			<x path="Int"/>
			<haxe_doc>* The type of tween.</haxe_doc>
		</_type>
		<_ease>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* The easer method to apply to the Tweened value.</haxe_doc>
		</_ease>
		<_t>
			<x path="Float"/>
			<haxe_doc>* The percent of completed tween.</haxe_doc>
		</_t>
		<_time>
			<x path="Float"/>
			<haxe_doc>* The time that has passed since the tween started.</haxe_doc>
		</_time>
		<_target>
			<x path="Float"/>
			<haxe_doc>* Duration of the tween (in seconds or frames).</haxe_doc>
		</_target>
		<isFinished public="1">
			<x path="Bool"/>
			<haxe_doc>* True if the tweening has finished.</haxe_doc>
		</isFinished>
		<parent public="1">
			<c path="spiller.SpiBasic"/>
			<haxe_doc>* The parent object.</haxe_doc>
		</parent>
		<prev public="1">
			<c path="spiller.plugin.tweens.SpiTween"/>
			<haxe_doc>* The previous tween.</haxe_doc>
		</prev>
		<next public="1">
			<c path="spiller.plugin.tweens.SpiTween"/>
			<haxe_doc>* The next tween.</haxe_doc>
		</next>
		<_backward>
			<x path="Bool"/>
			<haxe_doc>* If the tween has to be played in a reverse direction.</haxe_doc>
		</_backward>
		<destroy public="1" set="method" line="120">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroy method.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="130">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the Tween, called by World.</haxe_doc>
		</update>
		<start public="1" set="method" line="155">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Starts the Tween, or restarts it if it's currently running.</haxe_doc>
		</start>
		<cancel public="1" set="method" line="168">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Immediately stops the Tween and removes it from its Tweener without calling the complete callback.</haxe_doc>
		</cancel>
		<finish public="1" set="method" line="179">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the Tween completes.</haxe_doc>
		</finish>
		<getPercent public="1" set="method" line="215">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Get the percent of completed tween.
	 * 
	 * @return</haxe_doc>
		</getPercent>
		<setPercent public="1" set="method" line="226">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Set the percent.
	 * 
	 * @param value		The percent value.
	 * @return</haxe_doc>
		</setPercent>
		<getScale public="1" set="method" line="235">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Return the time scale.</haxe_doc>
		</getScale>
		<new public="1" set="method" line="102">
			<f a="duration:?type:?complete:?ease">
				<x path="Float"/>
				<x path="Int"/>
				<f a=""><x path="Void"/></f>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor. Specify basic information about the Tween.
	 * @param	duration		Duration of the tween (in seconds or frames).
	 * @param	type			Tween type, one of Tween.PERSIST (default), Tween.LOOPING, or Tween.ONESHOT.
	 * @param	complete		Optional callback for when the Tween completes.
	 * @param	ease			Optional easer method to apply to the Tweened value.</haxe_doc>
		</new>
		<haxe_doc>* The global tween class.
 * 
 * v1.1 Ported to Java
 * v1.0 Initial version (?)
 * 
 * @version 1.1 - January 24th 2013
 * @author ratalaika / ratalaikaGames</haxe_doc>
	</class>
	<class path="spiller.system.macros.SpiMacroUtil" params="" file="Libs/spiller/system/macros/SpiMacroUtil.hx"/>
	<abstract path="spiller.util.SpiColor" params="" file="Libs/spiller/util/SpiColor.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<haxe_doc>* Class representing a color, based on Int. Provides a variety of methods for creating and converting colors.
 * 
 * SpiColor's can be written as Ints. This means you can pass a hex value such as
 * 0xff123456 to a function expecting a SpiColor, and it will automatically become a SpiColor object.
 * Similarly, SpiColors may be treated as Ints.
 * 
 * Note that when using properties of a SpiColor other than ARGB, the values are ultimately stored as
 * ARGB values, so repeatedly manipulating HSB/HSL/CMYK values may result in a gradual loss of precision.
 * 
 * @author Joe Williamson (JoeCreates)</haxe_doc>
		<impl><class path="spiller.util._SpiColor.SpiColor_Impl_" params="" file="Libs/spiller/util/SpiColor.hx" private="1" module="spiller.util.SpiColor">
	<TRANSPARENT public="1" get="inline" set="null" line="20" static="1"><x path="spiller.util.SpiColor"/></TRANSPARENT>
	<WHITE public="1" get="inline" set="null" line="21" static="1"><x path="spiller.util.SpiColor"/></WHITE>
	<GRAY public="1" get="inline" set="null" line="22" static="1"><x path="spiller.util.SpiColor"/></GRAY>
	<BLACK public="1" get="inline" set="null" line="23" static="1"><x path="spiller.util.SpiColor"/></BLACK>
	<GREEN public="1" get="inline" set="null" line="25" static="1"><x path="spiller.util.SpiColor"/></GREEN>
	<LIME public="1" get="inline" set="null" line="26" static="1"><x path="spiller.util.SpiColor"/></LIME>
	<YELLOW public="1" get="inline" set="null" line="27" static="1"><x path="spiller.util.SpiColor"/></YELLOW>
	<ORANGE public="1" get="inline" set="null" line="28" static="1"><x path="spiller.util.SpiColor"/></ORANGE>
	<RED public="1" get="inline" set="null" line="29" static="1"><x path="spiller.util.SpiColor"/></RED>
	<PURPLE public="1" get="inline" set="null" line="30" static="1"><x path="spiller.util.SpiColor"/></PURPLE>
	<BLUE public="1" get="inline" set="null" line="31" static="1"><x path="spiller.util.SpiColor"/></BLUE>
	<BROWN public="1" get="inline" set="null" line="32" static="1"><x path="spiller.util.SpiColor"/></BROWN>
	<PINK public="1" get="inline" set="null" line="33" static="1"><x path="spiller.util.SpiColor"/></PINK>
	<MAGENTA public="1" get="inline" set="null" line="34" static="1"><x path="spiller.util.SpiColor"/></MAGENTA>
	<CYAN public="1" get="inline" set="null" line="35" static="1"><x path="spiller.util.SpiColor"/></CYAN>
	<colorLookup public="1" set="null" line="52" static="1">
		<x path="Map">
			<c path="String"/>
			<x path="Int"/>
		</x>
		<haxe_doc><![CDATA[* A Map<String, Int> which values are the static colors of SpiColor.
	 * You can add more colors for SpiColor.fromString(String) if you need.]]></haxe_doc>
	</colorLookup>
	<red public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</red>
	<blue public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</blue>
	<green public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</green>
	<alpha public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</alpha>
	<redFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redFloat>
	<blueFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueFloat>
	<greenFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenFloat>
	<alphaFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaFloat>
	<cyan public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cyan>
	<magenta public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</magenta>
	<yellow public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</yellow>
	<black public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</black>
	<hue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hue>
	<saturation public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
	</saturation>
	<brightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
	</brightness>
	<lightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
	</lightness>
	<COLOR_REGEX line="76" static="1"><c path="EReg"/></COLOR_REGEX>
	<fromInt public="1" get="inline" set="null" line="84" static="1">
		<f a="Value">
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Create a color from the lest significant four bytes of an Int
	 * 
	 * @param	Value And Int with bytes in the format 0xAARRGGBB
	 * @return	The color as a SpiColor</haxe_doc>
	</fromInt>
	<fromRGB public="1" get="inline" set="null" line="98" static="1">
		<f a="Red:Green:Blue:?Alpha">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Generate a color from integer RGB values (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return The color as a SpiColor</haxe_doc>
	</fromRGB>
	<fromRGBFloat public="1" get="inline" set="null" line="113" static="1">
		<f a="Red:Green:Blue:?Alpha">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Generate a color from float RGB values (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return The color as a SpiColor</haxe_doc>
	</fromRGBFloat>
	<fromCMYK public="1" get="inline" set="null" line="129" static="1">
		<f a="Cyan:Magenta:Yellow:Black:?Alpha">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Generate a color from CMYK values (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return The color as a SpiColor</haxe_doc>
	</fromCMYK>
	<fromHSB public="1" set="method" line="144" static="1">
		<f a="Hue:Saturation:Brightness:?Alpha">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Generate a color from HSB (aka HSV) components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a SpiColor</haxe_doc>
	</fromHSB>
	<fromHSL public="1" get="inline" set="null" line="159" static="1">
		<f a="Hue:Saturation:Lightness:?Alpha">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Generate a color from HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a SpiColor</haxe_doc>
	</fromHSL>
	<fromString public="1" set="method" line="177" static="1">
		<f a="str">
			<c path="String"/>
			<t path="Null"><x path="spiller.util.SpiColor"/></t>
		</f>
		<haxe_doc><![CDATA[* Parses a String and returns a SpiColor or null if the String couldn't be parsed.
	 * Examples (input -> output in hex):
	 * 0x00FF00    -> 0xFF00FF00
	 * 0xAA4578C2  -> 0xAA4578C2
	 * #0000FF     -> 0xFF0000FF
	 * #3F000011   -> 0x3F000011
	 * GRAY        -> 0xFF808080
	 * blue        -> 0xFF0000FF
	 * @param	str 	The string to be parsed
	 * @return	A SpiColor or null if the String couldn't be parsed]]></haxe_doc>
	</fromString>
	<getHSBColorWheel public="1" set="method" line="213" static="1">
		<f a="?Alpha">
			<x path="Int"/>
			<c path="Array"><x path="spiller.util.SpiColor"/></c>
		</f>
		<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
	 * 
	 * @param	Alpha Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque)
	 * @return	HSB color wheel as Array of SpiColors</haxe_doc>
	</getHSBColorWheel>
	<interpolate public="1" get="inline" set="null" line="233" static="1">
		<f a="Color1:Color2:?Factor">
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Get an interpolated color based on two different colors.
	 * 
	 * @param 	Color1 The first color
	 * @param 	Color2 The second color
	 * @param 	Factor Value from 0 to 1 representing how much to shift Color1 toward Color2
	 * @return	The interpolated color</haxe_doc>
	</interpolate>
	<gradient public="1" set="method" line="252" static="1">
		<f a="Color1:Color2:Steps:?Ease">
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
			<x path="Int"/>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<c path="Array"><x path="spiller.util.SpiColor"/></c>
		</f>
		<haxe_doc>* Create a gradient from one color to another
	 * 
	 * @param Color1 The color to shift from
	 * @param Color2 The color to shift to
	 * @param Steps How many colors the gradient should have
	 * @param Ease An optional easing function, such as those provided in SpiEase
	 * @return An array of colors of length Steps, shifting from Color1 to Color2</haxe_doc>
	</gradient>
	<multiply public="1" get="inline" set="null" line="276" static="1">
		<f a="lhs:rhs">
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":op"><e>A*B</e></m></meta>
		<haxe_doc>* Multiply the RGB channels of two SpiColors</haxe_doc>
	</multiply>
	<add public="1" get="inline" set="null" line="285" static="1">
		<f a="lhs:rhs">
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":op"><e>A+B</e></m></meta>
		<haxe_doc>* Add the RGB channels of two SpiColors</haxe_doc>
	</add>
	<subtract public="1" get="inline" set="null" line="294" static="1">
		<f a="lhs:rhs">
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":op"><e>A-B</e></m></meta>
		<haxe_doc>* Subtract the RGB channels of one SpiColor from another</haxe_doc>
	</subtract>
	<getComplementHarmony public="1" get="inline" set="null" line="305" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns a Complementary Color Harmony of this color.
	 * A complementary hue is one directly opposite the color given on the color wheel
	 * 
	 * @return	The complimentary color</haxe_doc>
	</getComplementHarmony>
	<getAnalogousHarmony public="1" get="inline" set="null" line="317" static="1">
		<f a="this:?Threshold">
			<x path="Int"/>
			<x path="Int"/>
			<t path="spiller.util.Harmony"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns an Analogous Color Harmony for the given color.
	 * An Analogous harmony are hues adjacent to each other on the color wheel
	 * 
	 * @param	Threshold Control how adjacent the colors will be (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
	</getAnalogousHarmony>
	<getSplitComplementHarmony public="1" get="inline" set="null" line="332" static="1">
		<f a="this:?Threshold">
			<x path="Int"/>
			<x path="Int"/>
			<t path="spiller.util.Harmony"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns an Split Complement Color Harmony for this color.
	 * A Split Complement harmony are the two hues on either side of the color's Complement
	 * 
	 * @param	Threshold Control how adjacent the colors will be to the Complement (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
	</getSplitComplementHarmony>
	<getTriadicHarmony public="1" get="inline" set="null" line="347" static="1">
		<f a="this">
			<x path="Int"/>
			<t path="spiller.util.TriadicHarmony"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns a Triadic Color Harmony for this color. A Triadic harmony are 3 hues equidistant 
	 * from each other on the color wheel.
	 * 
	 * @return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
	</getTriadicHarmony>
	<to24Bit public="1" get="inline" set="null" line="360" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Return a 24 bit version of this color (i.e. without an alpha value)
	 * 
	 * @return A 24 bit version of this color</haxe_doc>
	</to24Bit>
	<toHexString public="1" get="inline" set="null" line="372" static="1">
		<f a="this:?Alpha:?Prefix">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Return a String representation of the color in the format
	 * 
	 * @param Alpha Whether to include the alpha value in the hes string
	 * @param Prefix Whether to include "0x" prefix at start of string
	 * @return	A string of length 10 in the format 0xAARRGGBB</haxe_doc>
	</toHexString>
	<toWebString public="1" get="inline" set="null" line="383" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Return a String representation of the color in the format #RRGGBB
	 * 
	 * @return	A string of length 7 in the format #RRGGBB</haxe_doc>
	</toWebString>
	<getColorInfo public="1" set="method" line="393" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Get a string of color information about this color
	 * 
	 * @return A string containing information about this color</haxe_doc>
	</getColorInfo>
	<getDarkened public="1" set="method" line="414" static="1">
		<f a="this:?Factor">
			<x path="Int"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Get a darkened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward black.
	 * @return 	A darkened version of this color</haxe_doc>
	</getDarkened>
	<getLightened public="1" get="inline" set="null" line="428" static="1">
		<f a="this:?Factor">
			<x path="Int"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Get a lightened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward white.
	 * @return 	A lightened version of this color</haxe_doc>
	</getLightened>
	<getInverted public="1" get="inline" set="null" line="441" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Get the inversion of this color
	 * 
	 * @return The inversion of this color</haxe_doc>
	</getInverted>
	<setRGB public="1" get="inline" set="null" line="458" static="1">
		<f a="this:Red:Green:Blue:?Alpha">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set RGB values as integers (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return This color</haxe_doc>
	</setRGB>
	<setRGBFloat public="1" get="inline" set="null" line="476" static="1">
		<f a="this:Red:Green:Blue:?Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set RGB values as floats (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
	</setRGBFloat>
	<setCMYK public="1" get="inline" set="null" line="495" static="1">
		<f a="this:Cyan:Magenta:Yellow:Black:?Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set CMYK values as floats (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
	</setCMYK>
	<setHSB public="1" get="inline" set="null" line="513" static="1">
		<f a="this:Hue:Saturation:Brightness:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set HSB (aka HSV) components
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	This color</haxe_doc>
	</setHSB>
	<setHSL public="1" get="inline" set="null" line="529" static="1">
		<f a="this:Hue:Saturation:Lightness:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255
	 * @return	This color</haxe_doc>
	</setHSL>
	<setHSChromaMatch get="inline" set="null" line="539" static="1">
		<f a="this:Hue:Saturation:Chroma:Match:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
	</setHSChromaMatch>
	<_new public="1" set="method" line="559" static="1">
		<f a="?Value">
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<get_red get="inline" set="null" line="564" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_red>
	<get_green get="inline" set="null" line="569" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_green>
	<get_blue get="inline" set="null" line="574" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blue>
	<get_alpha get="inline" set="null" line="579" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alpha>
	<get_redFloat get="inline" set="null" line="584" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redFloat>
	<get_greenFloat get="inline" set="null" line="589" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenFloat>
	<get_blueFloat get="inline" set="null" line="594" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueFloat>
	<get_alphaFloat get="inline" set="null" line="599" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaFloat>
	<set_red get="inline" set="null" line="604" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_red>
	<set_green get="inline" set="null" line="611" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_green>
	<set_blue get="inline" set="null" line="618" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blue>
	<set_alpha get="inline" set="null" line="625" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alpha>
	<set_redFloat get="inline" set="null" line="632" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redFloat>
	<set_greenFloat get="inline" set="null" line="638" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenFloat>
	<set_blueFloat get="inline" set="null" line="644" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueFloat>
	<set_alphaFloat get="inline" set="null" line="650" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaFloat>
	<get_cyan get="inline" set="null" line="656" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cyan>
	<get_magenta get="inline" set="null" line="661" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_magenta>
	<get_yellow get="inline" set="null" line="666" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_yellow>
	<get_black get="inline" set="null" line="671" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_black>
	<set_cyan get="inline" set="null" line="676" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cyan>
	<set_magenta get="inline" set="null" line="682" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_magenta>
	<set_yellow get="inline" set="null" line="688" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_yellow>
	<set_black get="inline" set="null" line="694" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_black>
	<get_hue set="method" line="700" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_hue>
	<get_brightness get="inline" set="null" line="712" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_brightness>
	<get_saturation get="inline" set="null" line="717" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_saturation>
	<get_lightness get="inline" set="null" line="722" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_lightness>
	<set_hue get="inline" set="null" line="727" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_hue>
	<set_saturation get="inline" set="null" line="733" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_saturation>
	<set_brightness get="inline" set="null" line="739" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_brightness>
	<set_lightness get="inline" set="null" line="745" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_lightness>
	<maxColor get="inline" set="null" line="751" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</maxColor>
	<minColor get="inline" set="null" line="756" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</minColor>
	<boundChannel get="inline" set="null" line="761" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</boundChannel>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="spiller.util._SpiColor.SpiColor_Impl_" params="" file="Libs/spiller/util/SpiColor.hx" private="1" module="spiller.util.SpiColor">
		<TRANSPARENT public="1" get="inline" set="null" line="20" static="1"><x path="spiller.util.SpiColor"/></TRANSPARENT>
		<WHITE public="1" get="inline" set="null" line="21" static="1"><x path="spiller.util.SpiColor"/></WHITE>
		<GRAY public="1" get="inline" set="null" line="22" static="1"><x path="spiller.util.SpiColor"/></GRAY>
		<BLACK public="1" get="inline" set="null" line="23" static="1"><x path="spiller.util.SpiColor"/></BLACK>
		<GREEN public="1" get="inline" set="null" line="25" static="1"><x path="spiller.util.SpiColor"/></GREEN>
		<LIME public="1" get="inline" set="null" line="26" static="1"><x path="spiller.util.SpiColor"/></LIME>
		<YELLOW public="1" get="inline" set="null" line="27" static="1"><x path="spiller.util.SpiColor"/></YELLOW>
		<ORANGE public="1" get="inline" set="null" line="28" static="1"><x path="spiller.util.SpiColor"/></ORANGE>
		<RED public="1" get="inline" set="null" line="29" static="1"><x path="spiller.util.SpiColor"/></RED>
		<PURPLE public="1" get="inline" set="null" line="30" static="1"><x path="spiller.util.SpiColor"/></PURPLE>
		<BLUE public="1" get="inline" set="null" line="31" static="1"><x path="spiller.util.SpiColor"/></BLUE>
		<BROWN public="1" get="inline" set="null" line="32" static="1"><x path="spiller.util.SpiColor"/></BROWN>
		<PINK public="1" get="inline" set="null" line="33" static="1"><x path="spiller.util.SpiColor"/></PINK>
		<MAGENTA public="1" get="inline" set="null" line="34" static="1"><x path="spiller.util.SpiColor"/></MAGENTA>
		<CYAN public="1" get="inline" set="null" line="35" static="1"><x path="spiller.util.SpiColor"/></CYAN>
		<colorLookup public="1" set="null" line="52" static="1">
			<x path="Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<haxe_doc><![CDATA[* A Map<String, Int> which values are the static colors of SpiColor.
	 * You can add more colors for SpiColor.fromString(String) if you need.]]></haxe_doc>
		</colorLookup>
		<red public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</red>
		<blue public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</blue>
		<green public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</green>
		<alpha public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</alpha>
		<redFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redFloat>
		<blueFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueFloat>
		<greenFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenFloat>
		<alphaFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaFloat>
		<cyan public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cyan>
		<magenta public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</magenta>
		<yellow public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</yellow>
		<black public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</black>
		<hue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hue>
		<saturation public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
		</saturation>
		<brightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
		</brightness>
		<lightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
		</lightness>
		<COLOR_REGEX line="76" static="1"><c path="EReg"/></COLOR_REGEX>
		<fromInt public="1" get="inline" set="null" line="84" static="1">
			<f a="Value">
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Create a color from the lest significant four bytes of an Int
	 * 
	 * @param	Value And Int with bytes in the format 0xAARRGGBB
	 * @return	The color as a SpiColor</haxe_doc>
		</fromInt>
		<fromRGB public="1" get="inline" set="null" line="98" static="1">
			<f a="Red:Green:Blue:?Alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Generate a color from integer RGB values (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return The color as a SpiColor</haxe_doc>
		</fromRGB>
		<fromRGBFloat public="1" get="inline" set="null" line="113" static="1">
			<f a="Red:Green:Blue:?Alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Generate a color from float RGB values (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return The color as a SpiColor</haxe_doc>
		</fromRGBFloat>
		<fromCMYK public="1" get="inline" set="null" line="129" static="1">
			<f a="Cyan:Magenta:Yellow:Black:?Alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Generate a color from CMYK values (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return The color as a SpiColor</haxe_doc>
		</fromCMYK>
		<fromHSB public="1" set="method" line="144" static="1">
			<f a="Hue:Saturation:Brightness:?Alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Generate a color from HSB (aka HSV) components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a SpiColor</haxe_doc>
		</fromHSB>
		<fromHSL public="1" get="inline" set="null" line="159" static="1">
			<f a="Hue:Saturation:Lightness:?Alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Generate a color from HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a SpiColor</haxe_doc>
		</fromHSL>
		<fromString public="1" set="method" line="177" static="1">
			<f a="str">
				<c path="String"/>
				<t path="Null"><x path="spiller.util.SpiColor"/></t>
			</f>
			<haxe_doc><![CDATA[* Parses a String and returns a SpiColor or null if the String couldn't be parsed.
	 * Examples (input -> output in hex):
	 * 0x00FF00    -> 0xFF00FF00
	 * 0xAA4578C2  -> 0xAA4578C2
	 * #0000FF     -> 0xFF0000FF
	 * #3F000011   -> 0x3F000011
	 * GRAY        -> 0xFF808080
	 * blue        -> 0xFF0000FF
	 * @param	str 	The string to be parsed
	 * @return	A SpiColor or null if the String couldn't be parsed]]></haxe_doc>
		</fromString>
		<getHSBColorWheel public="1" set="method" line="213" static="1">
			<f a="?Alpha">
				<x path="Int"/>
				<c path="Array"><x path="spiller.util.SpiColor"/></c>
			</f>
			<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
	 * 
	 * @param	Alpha Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque)
	 * @return	HSB color wheel as Array of SpiColors</haxe_doc>
		</getHSBColorWheel>
		<interpolate public="1" get="inline" set="null" line="233" static="1">
			<f a="Color1:Color2:?Factor">
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Get an interpolated color based on two different colors.
	 * 
	 * @param 	Color1 The first color
	 * @param 	Color2 The second color
	 * @param 	Factor Value from 0 to 1 representing how much to shift Color1 toward Color2
	 * @return	The interpolated color</haxe_doc>
		</interpolate>
		<gradient public="1" set="method" line="252" static="1">
			<f a="Color1:Color2:Steps:?Ease">
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<c path="Array"><x path="spiller.util.SpiColor"/></c>
			</f>
			<haxe_doc>* Create a gradient from one color to another
	 * 
	 * @param Color1 The color to shift from
	 * @param Color2 The color to shift to
	 * @param Steps How many colors the gradient should have
	 * @param Ease An optional easing function, such as those provided in SpiEase
	 * @return An array of colors of length Steps, shifting from Color1 to Color2</haxe_doc>
		</gradient>
		<multiply public="1" get="inline" set="null" line="276" static="1">
			<f a="lhs:rhs">
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":op"><e>A*B</e></m></meta>
			<haxe_doc>* Multiply the RGB channels of two SpiColors</haxe_doc>
		</multiply>
		<add public="1" get="inline" set="null" line="285" static="1">
			<f a="lhs:rhs">
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":op"><e>A+B</e></m></meta>
			<haxe_doc>* Add the RGB channels of two SpiColors</haxe_doc>
		</add>
		<subtract public="1" get="inline" set="null" line="294" static="1">
			<f a="lhs:rhs">
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":op"><e>A-B</e></m></meta>
			<haxe_doc>* Subtract the RGB channels of one SpiColor from another</haxe_doc>
		</subtract>
		<getComplementHarmony public="1" get="inline" set="null" line="305" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns a Complementary Color Harmony of this color.
	 * A complementary hue is one directly opposite the color given on the color wheel
	 * 
	 * @return	The complimentary color</haxe_doc>
		</getComplementHarmony>
		<getAnalogousHarmony public="1" get="inline" set="null" line="317" static="1">
			<f a="this:?Threshold">
				<x path="Int"/>
				<x path="Int"/>
				<t path="spiller.util.Harmony"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns an Analogous Color Harmony for the given color.
	 * An Analogous harmony are hues adjacent to each other on the color wheel
	 * 
	 * @param	Threshold Control how adjacent the colors will be (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
		</getAnalogousHarmony>
		<getSplitComplementHarmony public="1" get="inline" set="null" line="332" static="1">
			<f a="this:?Threshold">
				<x path="Int"/>
				<x path="Int"/>
				<t path="spiller.util.Harmony"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns an Split Complement Color Harmony for this color.
	 * A Split Complement harmony are the two hues on either side of the color's Complement
	 * 
	 * @param	Threshold Control how adjacent the colors will be to the Complement (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
		</getSplitComplementHarmony>
		<getTriadicHarmony public="1" get="inline" set="null" line="347" static="1">
			<f a="this">
				<x path="Int"/>
				<t path="spiller.util.TriadicHarmony"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns a Triadic Color Harmony for this color. A Triadic harmony are 3 hues equidistant 
	 * from each other on the color wheel.
	 * 
	 * @return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
		</getTriadicHarmony>
		<to24Bit public="1" get="inline" set="null" line="360" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Return a 24 bit version of this color (i.e. without an alpha value)
	 * 
	 * @return A 24 bit version of this color</haxe_doc>
		</to24Bit>
		<toHexString public="1" get="inline" set="null" line="372" static="1">
			<f a="this:?Alpha:?Prefix">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Return a String representation of the color in the format
	 * 
	 * @param Alpha Whether to include the alpha value in the hes string
	 * @param Prefix Whether to include "0x" prefix at start of string
	 * @return	A string of length 10 in the format 0xAARRGGBB</haxe_doc>
		</toHexString>
		<toWebString public="1" get="inline" set="null" line="383" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Return a String representation of the color in the format #RRGGBB
	 * 
	 * @return	A string of length 7 in the format #RRGGBB</haxe_doc>
		</toWebString>
		<getColorInfo public="1" set="method" line="393" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Get a string of color information about this color
	 * 
	 * @return A string containing information about this color</haxe_doc>
		</getColorInfo>
		<getDarkened public="1" set="method" line="414" static="1">
			<f a="this:?Factor">
				<x path="Int"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Get a darkened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward black.
	 * @return 	A darkened version of this color</haxe_doc>
		</getDarkened>
		<getLightened public="1" get="inline" set="null" line="428" static="1">
			<f a="this:?Factor">
				<x path="Int"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Get a lightened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward white.
	 * @return 	A lightened version of this color</haxe_doc>
		</getLightened>
		<getInverted public="1" get="inline" set="null" line="441" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Get the inversion of this color
	 * 
	 * @return The inversion of this color</haxe_doc>
		</getInverted>
		<setRGB public="1" get="inline" set="null" line="458" static="1">
			<f a="this:Red:Green:Blue:?Alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set RGB values as integers (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return This color</haxe_doc>
		</setRGB>
		<setRGBFloat public="1" get="inline" set="null" line="476" static="1">
			<f a="this:Red:Green:Blue:?Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set RGB values as floats (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
		</setRGBFloat>
		<setCMYK public="1" get="inline" set="null" line="495" static="1">
			<f a="this:Cyan:Magenta:Yellow:Black:?Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set CMYK values as floats (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
		</setCMYK>
		<setHSB public="1" get="inline" set="null" line="513" static="1">
			<f a="this:Hue:Saturation:Brightness:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set HSB (aka HSV) components
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	This color</haxe_doc>
		</setHSB>
		<setHSL public="1" get="inline" set="null" line="529" static="1">
			<f a="this:Hue:Saturation:Lightness:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255
	 * @return	This color</haxe_doc>
		</setHSL>
		<setHSChromaMatch get="inline" set="null" line="539" static="1">
			<f a="this:Hue:Saturation:Chroma:Match:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
		</setHSChromaMatch>
		<_new public="1" set="method" line="559" static="1">
			<f a="?Value">
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<get_red get="inline" set="null" line="564" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_red>
		<get_green get="inline" set="null" line="569" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_green>
		<get_blue get="inline" set="null" line="574" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blue>
		<get_alpha get="inline" set="null" line="579" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alpha>
		<get_redFloat get="inline" set="null" line="584" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redFloat>
		<get_greenFloat get="inline" set="null" line="589" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenFloat>
		<get_blueFloat get="inline" set="null" line="594" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueFloat>
		<get_alphaFloat get="inline" set="null" line="599" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaFloat>
		<set_red get="inline" set="null" line="604" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_red>
		<set_green get="inline" set="null" line="611" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_green>
		<set_blue get="inline" set="null" line="618" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blue>
		<set_alpha get="inline" set="null" line="625" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alpha>
		<set_redFloat get="inline" set="null" line="632" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redFloat>
		<set_greenFloat get="inline" set="null" line="638" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenFloat>
		<set_blueFloat get="inline" set="null" line="644" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueFloat>
		<set_alphaFloat get="inline" set="null" line="650" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaFloat>
		<get_cyan get="inline" set="null" line="656" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cyan>
		<get_magenta get="inline" set="null" line="661" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_magenta>
		<get_yellow get="inline" set="null" line="666" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_yellow>
		<get_black get="inline" set="null" line="671" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_black>
		<set_cyan get="inline" set="null" line="676" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cyan>
		<set_magenta get="inline" set="null" line="682" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_magenta>
		<set_yellow get="inline" set="null" line="688" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_yellow>
		<set_black get="inline" set="null" line="694" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_black>
		<get_hue set="method" line="700" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_hue>
		<get_brightness get="inline" set="null" line="712" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_brightness>
		<get_saturation get="inline" set="null" line="717" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_saturation>
		<get_lightness get="inline" set="null" line="722" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_lightness>
		<set_hue get="inline" set="null" line="727" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_hue>
		<set_saturation get="inline" set="null" line="733" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_saturation>
		<set_brightness get="inline" set="null" line="739" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_brightness>
		<set_lightness get="inline" set="null" line="745" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_lightness>
		<maxColor get="inline" set="null" line="751" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</maxColor>
		<minColor get="inline" set="null" line="756" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</minColor>
		<boundChannel get="inline" set="null" line="761" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</boundChannel>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="spiller.util.Harmony" params="" file="Libs/spiller/util/SpiColor.hx" module="spiller.util.SpiColor"><a>
	<warmer><x path="spiller.util.SpiColor"/></warmer>
	<original><x path="spiller.util.SpiColor"/></original>
	<colder><x path="spiller.util.SpiColor"/></colder>
</a></typedef>
	<typedef path="spiller.util.TriadicHarmony" params="" file="Libs/spiller/util/SpiColor.hx" module="spiller.util.SpiColor"><a>
	<color3><x path="spiller.util.SpiColor"/></color3>
	<color2><x path="spiller.util.SpiColor"/></color2>
	<color1><x path="spiller.util.SpiColor"/></color1>
</a></typedef>
	<class path="spiller.util.SpiDestroyUtil" params="" file="Libs/spiller/util/SpiDestroyUtil.hx">
		<destroy public="1" params="T" set="method" line="21" static="1">
			<f a="object">
				<c path="destroy.T"/>
				<c path="destroy.T"/>
			</f>
			<haxe_doc>* Checks if an object is not null before calling destroy(), always returns null.
	 * 
	 * @param	object	An ISpiDestroyable object that will be destroyed if it's not null.</haxe_doc>
		</destroy>
		<destroyArray public="1" params="T" set="method" line="35" static="1">
			<f a="array">
				<c path="Array"><c path="destroyArray.T"/></c>
				<c path="Array"><c path="destroyArray.T"/></c>
			</f>
			<haxe_doc>* Destroy every element of an array of ISpiDestroyables
	 *
	 * @param	array	An Array of ISpiDestroyable objects</haxe_doc>
		</destroyArray>
		<put public="1" params="T" set="method" line="51" static="1">
			<f a="object">
				<c path="put.T"/>
				<c path="put.T"/>
			</f>
			<haxe_doc>* Checks if an object is not null before putting it back into the pool, always returns null.
	 * 
	 * @param	object	An ISpiPoolable object that will be put back into the pool if it's not null</haxe_doc>
		</put>
		<putArray public="1" params="T" set="method" line="67" static="1">
			<f a="array">
				<c path="Array"><c path="putArray.T"/></c>
				<c path="Array"><c path="putArray.T"/></c>
			</f>
			<haxe_doc>* Puts all objects in an Array of ISpiPoolable objects back into 
	 * the pool by calling SpiDestroyUtil.put() on them
	 *
	 * @param	array	An Array of ISpiPoolable objects
	 * @return	null</haxe_doc>
		</putArray>
		<haxe_doc><![CDATA[* Handy manager for pooling and destroying objects.
 * 
 * v1.0 Initial version<br>
 * <br>
 * @version 1.0 - 18/04/2015
 * @author ratalaika / ratalaikaGames]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.util.SpiPath" params="" file="Libs/spiller/util/SpiPath.hx">
		<nodes public="1">
			<c path="Array"><c path="spiller.math.SpiPoint"/></c>
			<haxe_doc><![CDATA[* The list of <code>SpiPoint</code>s that make up the path data.]]></haxe_doc>
		</nodes>
		<debugColor public="1">
			<x path="Int"/>
			<haxe_doc>* Specify a debug display color for the path.  Default is white.</haxe_doc>
		</debugColor>
		<debugScrollFactor public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* Specify a debug display scroll factor for the path.  Default is (1,1).
	 * NOTE: does not affect world movement!  Object scroll factors take care of that.</haxe_doc>
		</debugScrollFactor>
		<ignoreDrawDebug public="1">
			<x path="Bool"/>
			<haxe_doc>* Setting this to true will prevent the object from appearing
	 * when the visual debug mode in the debugger overlay is toggled on.
	 * @default false</haxe_doc>
		</ignoreDrawDebug>
		<_point>
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* Internal helper for keeping new variable instantiations under control.</haxe_doc>
		</_point>
		<destroy public="1" set="method" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<add public="1" set="method" line="92">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a new node to the end of the path at the specified location.
	 * 
	 * @param	X	X position of the new path point in world coordinates.
	 * @param	Y	Y position of the new path point in world coordinates.</haxe_doc>
		</add>
		<addAt public="1" set="method" line="104">
			<f a="X:Y:Index">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a new node to the path at the specified location and index within the path.
	 * 
	 * @param	X		X position of the new path point in world coordinates.
	 * @param	Y		Y position of the new path point in world coordinates.
	 * @param	Index	Where within the list of path nodes to insert this new point.</haxe_doc>
		</addAt>
		<addPoint public="1" set="method" line="119">
			<f a="Node:?AsReference">
				<c path="spiller.math.SpiPoint"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * <code>SpiPoint</code> object to the path.  This allows you to do neat things, like dynamic paths.
	 * 
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.]]></haxe_doc>
		</addPoint>
		<addPointAt public="1" set="method" line="136">
			<f a="Node:Index:?AsReference">
				<c path="spiller.math.SpiPoint"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * <code>SpiPoint</code> object to the path.  This allows you to do neat things, like dynamic paths.
	 * 
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	Index			Where within the list of path nodes to insert this new point.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.]]></haxe_doc>
		</addPointAt>
		<remove public="1" set="method" line="154">
			<f a="Node">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc><![CDATA[* Remove a node from the path.
	 * NOTE: only works with points added by reference or with references from <code>nodes</code> itself!
	 * 
	 * @param	Node	The point object you want to remove from the path.
	 * 
	 * @return	The node that was excised.  Returns null if the node was not found.]]></haxe_doc>
		</remove>
		<removeAt public="1" set="method" line="170">
			<f a="Index">
				<x path="Int"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Remove a node from the path using the specified position in the list of path nodes.
	 * 
	 * @param	Index	Where within the list of path nodes you want to remove a node.
	 * 
	 * @return	The node that was excised.  Returns null if there were no nodes in the path.</haxe_doc>
		</removeAt>
		<head public="1" set="method" line="184">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* Get the first node in the list.
	 * 
	 * @return	The first node in the path.</haxe_doc>
		</head>
		<tail public="1" set="method" line="196">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* Get the last node in the list.
	 * 
	 * @return	The last node in the path.</haxe_doc>
		</tail>
		<drawDebug public="1" set="method" line="211">
			<f a="?Camera">
				<c path="spiller.SpiCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* While this doesn't override <code>SpiBasic.drawDebug()</code>, the behavior is very similar.
	 * Based on this path data, it draws a simple lines-and-boxes representation of the path
	 * if the visual debug mode was toggled in the debugger overlay.  You can use <code>debugColor</code>
	 * and <code>debugScrollFactor</code> to control the path's appearance.
	 * 
	 * @param	Camera		The camera object the path will draw to.]]></haxe_doc>
		</drawDebug>
		<new public="1" set="method" line="53">
			<f a="?Nodes">
				<c path="Array"><c path="spiller.math.SpiPoint"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new path object.
	 * 
	 * @param	Nodes	Optional, can specify all the points for the path up front if you want.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is a simple path data container.  Basically a list of points that<br>
 * a <code>SpiObject</code> can follow.  Also has code for drawing debug visuals.<br>
 * <code>SpiTilemap.findPath()</code> returns a path object, but you can<br>
 * also just make your own, using the <code>add()</code> functions below<br>
 * or by creating your own array of points.<br>
 * <br>
 * v1.0 Initial version
 * 
 * @version 1.0 - 17/07/2013
 * @author ratalaika / ratalaikaGames
 * @author	Thomas Weston
 * @author	Ka Wing Chin]]></haxe_doc>
	</class>
	<class path="spiller.util.SpiStringUtil" params="" file="Libs/spiller/util/SpiStringUtil.hx">
		<formatTicks public="1" get="inline" set="null" line="26" static="1">
			<f a="StartTicks:EndTicks">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Takes two "ticks" timestamps and formats them into the number of seconds that passed as a String.
	 * Useful for logging, debugging, the watch window, or whatever else.
	 * 
	 * @param	StartTicks	The first timestamp from the system.
	 * @param	EndTicks	The second timestamp from the system.
	 * @return	A String containing the formatted time elapsed information.</haxe_doc>
		</formatTicks>
		<formatTime public="1" get="inline" set="null" line="38" static="1">
			<f a="Seconds:?ShowMS">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Format seconds as minutes with a colon, an optionally with milliseconds too.
	 * 
	 * @param	Seconds		The number of seconds (for example, time remaining, time spent, etc).
	 * @param	ShowMS		Whether to show milliseconds after a "." as well.  Default value is false.
	 * @return	A nicely formatted String, like "1:03".</haxe_doc>
		</formatTime>
		<formatArray public="1" get="inline" set="null" line="68" static="1">
			<f a="AnyArray">
				<c path="Array"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Generate a comma-separated string from an array.
	 * Especially useful for tracing or other debug output.
	 * 
	 * @param	AnyArray	Any Array object.
	 * @return	A comma-separated String containing the .toString() output of each element in the array.</haxe_doc>
		</formatArray>
		<formatStringMap public="1" get="inline" set="null" line="90" static="1">
			<f a="AnyMap">
				<x path="Map">
					<c path="String"/>
					<d/>
				</x>
				<c path="String"/>
			</f>
			<haxe_doc>* Generate a comma-seperated string representation of the keys of a StringMap.
	 * 
	 * @param  AnyMap    A StringMap object.
	 * @return  A String formatted like this: key1, key2, ..., keyX</haxe_doc>
		</formatStringMap>
		<formatMoney public="1" get="inline" set="null" line="112" static="1">
			<f a="Amount:?ShowDecimal:?EnglishStyle">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Automatically commas and decimals in the right places for displaying money amounts.
	 * Does not include a dollar sign or anything, so doesn't really do much
	 * if you call say var results:String = SpiString.formatMoney(10,false);
	 * However, very handy for displaying large sums or decimal money values.
	 * 
	 * @param	Amount			How much moneys (in dollars, or the equivalent "main" currency - i.e. not cents).
	 * @param	ShowDecimal		Whether to show the decimals/cents component. Default value is true.
	 * @param	EnglishStyle	Major quantities (thousands, millions, etc) separated by commas, and decimal by a period.  Default value is true.
	 * @return	A nicely formatted String.  Does not include a dollar sign or anything!</haxe_doc>
		</formatMoney>
		<formatBytes public="1" set="method" line="164" static="1">
			<f a="Bytes:?Precision">
				<x path="Float"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Takes an amount of bytes and finds the fitting unit. Makes sure that the 
	 * value is below 1024. Example: formatBytes(123456789); -> 117.74MB]]></haxe_doc>
		</formatBytes>
		<filterDigits public="1" set="method" line="182" static="1">
			<f a="Input">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Takes a string and filters out everything but the digits.
	 * 
	 * @param 	Input	The input string
	 * @return 	The output string, digits-only</haxe_doc>
		</filterDigits>
		<htmlFormat public="1" set="method" line="206" static="1">
			<f a="Text:?Size:?Color:?Bold:?Italic:?Underlined">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Format a text with html tags - useful for TextField.htmlText. 
	 * Used by the log window of the debugger.
	 * 
	 * @param	Text		The text to format
	 * @param	Size		The text size, using the font-size-tag
	 * @param	Color		The text color, using font-color-tag
	 * @param	Bold		Whether the text should be bold (b-tag)
	 * @param	Italic		Whether the text should be italic (i-tag)
	 * @param	Underlined 	Whether the text should be underlined (u-tag)
	 * @return	The html-formatted text.</haxe_doc>
		</htmlFormat>
		<getDomain public="1" set="method" line="265" static="1">
			<f a="url">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns the domain of a URL.</haxe_doc>
		</getDomain>
		<sameClassName public="1" get="inline" set="null" line="285" static="1">
			<f a="Obj1:Obj2:?Simple">
				<d/>
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Helper function that uses getClassName to compare two objects' class names.
	 * 
	 * @param	Obj1	The first object
	 * @param	Obj2	The second object
	 * @param	Simple 	Only uses the class name, not the package or packages.
	 * @return	Whether they have the same class name or not</haxe_doc>
		</sameClassName>
		<toIntArray public="1" set="method" line="297" static="1">
			<f a="Data">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Split a comma-separated string into an array of ints
	 * 
	 * @param	Data 	String formatted like this: "1, 2, 5, -10, 120, 27"
	 * @return	An array of ints</haxe_doc>
		</toIntArray>
		<toFloatArray public="1" set="method" line="318" static="1">
			<f a="Data">
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Split a comma-separated string into an array of floats
	 * 
	 * @param	Data string formatted like this: "1.0,2.1,5.6,1245587.9, -0.00354"
	 * @return	An array of floats</haxe_doc>
		</toFloatArray>
		<arrayToCSV public="1" set="method" line="341" static="1">
			<f a="Data:Width:?Invert">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts a one-dimensional array of tile data to a comma-separated string.
	 * 
	 * @param	Data		An array full of integer tile references.
	 * @param	Width		The number of tiles in each row.
	 * @param	Invert		Recommended only for 1-bit arrays - changes 0s to 1s and vice versa.
	 * @return	A comma-separated string containing the level data in a SpiTilemap-friendly format.</haxe_doc>
		</arrayToCSV>
		<getDebugString public="1" set="method" line="542" static="1">
			<f a="LabelValuePairs">
				<c path="Array"><c path="spiller.util.LabelValuePair"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Helper function to create a string for toString() functions. Automatically rounds values according to SpiG.debugger.precision.
	 * Strings are formatted in the format: (x: 50 | y: 60 | visible: false)
	 * 
	 * @param	LabelValuePairs		Array with the data for the string</haxe_doc>
		</getDebugString>
		<contains public="1" get="inline" set="null" line="561" static="1"><f a="s:str">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></contains>
		<haxe_doc>* A class primarily containing functions related 
 * to formatting different data types to strings.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.util.LabelValuePairPool" params="" file="Libs/spiller/util/SpiStringUtil.hx" module="spiller.util.SpiStringUtil">
		<extends path="spiller.util.SpiPool"><c path="spiller.util.LabelValuePair"/></extends>
		<create public="1" set="method" line="606" override="1"><f a=""><c path="spiller.util.LabelValuePair"/></f></create>
		<new public="1" set="method" line="603"><f a="?StartSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.util.LabelValuePair" params="" file="Libs/spiller/util/SpiStringUtil.hx" module="spiller.util.SpiStringUtil">
		<implements path="spiller.util.interfaces.ISpiDestroyable"/>
		<_pool line="571" static="1"><c path="spiller.util.LabelValuePairPool"/></_pool>
		<weak public="1" get="inline" set="null" line="573" static="1"><f a="label:value">
	<c path="String"/>
	<d/>
	<c path="spiller.util.LabelValuePair"/>
</f></weak>
		<label public="1"><c path="String"/></label>
		<value public="1"><d/></value>
		<create public="1" get="inline" set="null" line="581"><f a="label:value">
	<c path="String"/>
	<d/>
	<c path="spiller.util.LabelValuePair"/>
</f></create>
		<put public="1" get="inline" set="null" line="588"><f a=""><x path="Void"/></f></put>
		<destroy public="1" get="inline" set="null" line="593"><f a=""><x path="Void"/></f></destroy>
		<new set="method" line="600"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>spiller.util.LabelValuePairPool</e></m>
		</meta>
	</class>
	<typedef path="sys.FileStat" params="" file="/usr/lib/haxe/std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>the user id for the file</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>the size of the file</haxe_doc>
			</size>
			<rdev><x path="Int"/></rdev>
			<nlink><x path="Int"/></nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>the last modification time for the file</haxe_doc>
			</mtime>
			<mode><x path="Int"/></mode>
			<ino><x path="Int"/></ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>the user group id for the file</haxe_doc>
			</gid>
			<dev><x path="Int"/></dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>the creation time for the file</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>the last access time for the file (when enabled by the file system)</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File informations, as given by [sys.FileSystem.stat]</haxe_doc>
	</typedef>
	<class path="sys.FileSystem" params="" file="/usr/lib/haxe/std/sys/FileSystem.hx" extern="1">
		<exists public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the file or directory specified by `path` exists.

		If `path` is null, the result is unspecified.</haxe_doc>
		</exists>
		<rename public="1" set="method" static="1">
			<f a="path:newPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Renames/moves the file or directory specified by `path` to `newPath`.

		If `path` is not a valid file system entry, or if it is not accessible,
		or if `newPath` is not accessible, an exception is thrown.

		If `path` or `newPath` are null, the result is unspecified.</haxe_doc>
		</rename>
		<stat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<t path="sys.FileStat"/>
			</f>
			<haxe_doc>Returns `FileStat` information on the file or directory specified by
		`path`.

		If `path` is null, the result is unspecified.</haxe_doc>
		</stat>
		<fullPath public="1" set="method" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. Symlinks will be
		followed and the path will be normalized.

		If `relPath` is null, the result is unspecified.</haxe_doc>
		</fullPath>
		<absolutePath public="1" set="method" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. The path doesn't
		have to exist.

		If `relPath` is null, the result is unspecified.</haxe_doc>
		</absolutePath>
		<isDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the file or directory specified by `path` is a directory.

		If `path` is not a valid file system entry or if its destination is no
		accessible, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</isDirectory>
		<createDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the file specified by `path`.

		If `path` does not denote a valid file, or if that file cannot be
		deleted, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</deleteFile>
		<deleteDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the directory specified by `path`.

		If `path` does not denote a valid directory, or if that directory cannot
		be deleted, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</deleteDirectory>
		<readDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the names of all files and directories in the directory specified
		by `path`.

		If `path` does not denote a valid directory, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</readDirectory>
		<haxe_doc>This class allows you to get information about the files and directories.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.io.File" params="" file="/usr/lib/haxe/std/sys/io/File.hx" extern="1">
		<getContent public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Retrieves the content of the file specified by `path` as a String.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getContent>
		<saveContent public="1" set="method" static="1">
			<f a="path:content">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `content` in the file specified by `path`.

		If the file cannot be written to, an exception is thrown.

		If `path` or `content` are null, the result is unspecified.</haxe_doc>
		</saveContent>
		<getBytes public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Retrieves the binary content of the file specified by `path`.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getBytes>
		<saveBytes public="1" set="method" static="1">
			<f a="path:bytes">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `bytes` in the file specified by `path` in binary mode.

		If the file cannot be written to, an exception is thrown.

		If `path` or `bytes` are null, the result is unspecified.</haxe_doc>
		</saveBytes>
		<read public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileInput"/>
			</f>
			<meta><m n=":value"><e>{binary:true}</e></m></meta>
			<haxe_doc>Returns an `FileInput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file does not exist or can not be read, an exception is thrown.

		Operations on the returned `FileInput` handle read on the opened file.

		File handles should be closed via `FileInput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</read>
		<write public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{binary:true}</e></m></meta>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file cannot be written to, an exception is thrown.

		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.

		File handles should be closed via `FileOutput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<append public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{binary:true}</e></m></meta>
			<haxe_doc>Similar to `sys.io.File.write`, but appends to the file if it exists
		instead of overwriting its contents.</haxe_doc>
		</append>
		<copy public="1" set="method" static="1">
			<f a="srcPath:dstPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the contents of the file specified by `srcPath` to the file
		specified by `dstPath`.

		If the `srcPath` does not exist or cannot be read, or if the `dstPath`
		file cannot be written to, an exception is thrown.

		If the file at `dstPath` exists, its contents are overwritten.

		If `srcPath` or `dstPath` are null, the result is unspecified.</haxe_doc>
		</copy>
		<haxe_doc>API for reading and writing to files.

	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.io.FileInput" params="" file="/usr/lib/haxe/std/sys/io/FileInput.hx" extern="1">
		<extends path="haxe.io.Input"/>
		<seek public="1" set="method"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method"><f a=""><x path="Int"/></f></tell>
		<eof public="1" set="method"><f a=""><x path="Bool"/></f></eof>
		<haxe_doc>Use [sys.io.File.read] to create a [FileInput]</haxe_doc>
	</class>
	<class path="sys.io.FileOutput" params="" file="/usr/lib/haxe/std/sys/io/FileOutput.hx" extern="1">
		<extends path="haxe.io.Output"/>
		<seek public="1" set="method"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method"><f a=""><x path="Int"/></f></tell>
		<haxe_doc>Use [sys.io.File.write] to create a [FileOutput]</haxe_doc>
	</class>
	<enum path="sys.io.FileSeek" params="" file="/usr/lib/haxe/std/sys/io/FileSeek.hx">
		<SeekBegin/>
		<SeekCur/>
		<SeekEnd/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
</haxe>