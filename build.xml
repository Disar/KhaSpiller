<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/js/_std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<iterator public="1" get="inline" set="null" line="69">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":runtime"/>
			</meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/lib/haxe/std/js/_std/Date.hx" extern="1">
		<now public="1" get="inline" set="null" line="38" static="1">
			<f a=""><c path="Date"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" get="inline" set="null" line="42" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" get="inline" set="null" line="48" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<toString public="1" get="inline" set="null" line="34">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There is some extra functions available in the `DateTools` class.

	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/js/_std/EReg.hx">
		<r><c path="_EReg.HaxeRegExp"/></r>
		<match public="1" set="method" line="31">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="38">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<new public="1" set="method" line="26">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	http://haxe.org/manual/std-regex.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="js.RegExp" params="" file="/usr/lib/haxe/std/js/RegExp.hx" extern="1">
		<global public="1" set="null"><x path="Bool"/></global>
		<ignoreCase public="1" set="null"><x path="Bool"/></ignoreCase>
		<multiline public="1" set="null"><x path="Bool"/></multiline>
		<source public="1" set="null"><c path="String"/></source>
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<exec public="1" set="method"><f a="str">
	<c path="String"/>
	<t path="Null"><c path="js.RegExpMatch"/></t>
</f></exec>
		<test public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></test>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="pattern:?flags">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Native JavaScript regular expressions.

    For cross-platform regular expressions, use haxe `EReg` class or regexp literals.</haxe_doc>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
	</class>
	<class path="_EReg.HaxeRegExp" params="" file="/usr/lib/haxe/std/js/_std/EReg.hx" private="1" module="EReg" extern="1">
		<extends path="js.RegExp"/>
		<m public="1"><c path="js.RegExpMatch"/></m>
		<s public="1"><c path="String"/></s>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"RegExp"</e></m>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="42" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.

		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<has public="1" params="A" set="method" line="98" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains `elt`.

		This function returns true as soon as an element is found which is equal
		to `elt` according to the `==` operator.

		If no such element is found, the result is false.</haxe_doc>
		</has>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="49">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<remove public="1" set="method" line="138">
			<f a="v">
				<c path="List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `v` in `this` List.

		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.

		Otherwise, false is returned.</haxe_doc>
		</remove>
		<iterator public="1" get="inline" set="null" line="161">
			<f a=""><c path="_List.ListIterator"><c path="List.T"/></c></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="_List.ListIterator" params="T" file="/usr/lib/haxe/std/List.hx" private="1" module="List">
		<head><c path="Array"><d/></c></head>
		<val><d/></val>
		<hasNext public="1" get="inline" set="null" line="249"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="253"><f a=""><c path="_List.ListIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="244"><f a="head">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Main" params="" file="Sources/Main.hx">
		<main public="1" set="method" line="18" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<gameWidth><x path="Int"/></gameWidth>
		<gameHeight><x path="Int"/></gameHeight>
		<zoom><x path="Float"/></zoom>
		<framerate><x path="Int"/></framerate>
		<skipSplash><x path="Bool"/></skipSplash>
		<startFullscreen><x path="Bool"/></startFullscreen>
		<new public="1" set="method" line="9">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><t path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</t></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"><e>K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta><m n=":deprecated"/></meta>
	</typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/js/_std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<abs public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></abs>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<ceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></ceil>
		<cos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></cos>
		<exp public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></exp>
		<floor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<log public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></log>
		<max public="1" set="method" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></max>
		<min public="1" set="method" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></min>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<round public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></round>
		<sin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></sin>
		<sqrt public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
		</meta>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/js/_std/Reflect.hx">
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="32" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.

		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<callMethod public="1" get="inline" set="null" line="46" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="50" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="61" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<deleteField public="1" set="method" line="88" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="String" params="" file="/usr/lib/haxe/std/js/_std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String "", the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<charCodeAt public="1" get="inline" set="null" line="35">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, null is returned.

		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substr public="1" get="inline" set="null" line="39">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the string literal syntax "string value".

	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/js/_std/Std.hx">
		<string public="1" set="method" line="35" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="39" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="43" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" get="inline" set="null" line="53" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.

	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.

	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.

	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.

	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.

		This method is not required to check `hasNext` first. A call to this
		method while `hasNext` is false yields unspecified behavior.

		On the other hand iterators should not require a call to `hasNext`
		before the first call to `next` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.</haxe_doc></class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<b><c path="String"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<add public="1" params="T" get="inline" set="null" line="64">
			<f a="x">
				<c path="add.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.

		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).

		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<new public="1" get="inline" set="null" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<endsWith public="1" set="method" line="153" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is null, the result is unspecified.

		If `end` is the empty String "", the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="183" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String "", or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="200" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="225" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="247" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for ltrim(rtrim(s)).</haxe_doc>
		</trim>
		<replace public="1" set="method" line="312" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String "", `by` is inserted after each character
		of `s`. If `by` is also the empty String "", `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="334" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its length equals `digits`.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="376" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of String `s`, or an
		end-of-file indicator at if `position` equals `s.length`.

		This method is faster than String.charCodeAt() on some platforms, but
		the result is unspecified if `index` is negative or greater than
		`s.length`.

		End of file status can be checked by calling `StringTools.isEof` with
		the returned value as argument.

		This operation is not guaranteed to work if `s` contains the \0
		character.</haxe_doc>
		</fastCodeAt>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/js/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/js/_std/Type.hx">
		<getClass public="1" params="T" get="inline" set="null" line="36" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getClassName public="1" set="method" line="51" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="58" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="63" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="71" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createEmptyInstance public="1" params="T" set="method" line="105" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="110" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<getEnumConstructs public="1" set="method" line="147" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="152" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="/usr/lib/haxe/std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned Int type is only defined for Flash and C#.
	Simulate it for other platforms.</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="/usr/lib/haxe/std/UInt.hx" private="1" module="UInt">
	<gt set="method" line="116" static="1">
		<f a="a:b">
			<x path="UInt"/>
			<x path="UInt"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A>B]]></e></m></meta>
	</gt>
	<gte set="method" line="124" static="1">
		<f a="a:b">
			<x path="UInt"/>
			<x path="UInt"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A>=B]]></e></m></meta>
	</gte>
	<toFloat set="method" line="278" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toFloat>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="_UInt.UInt_Impl_" params="" file="/usr/lib/haxe/std/UInt.hx" private="1" module="UInt">
		<gt set="method" line="116" static="1">
			<f a="a:b">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A>B]]></e></m></meta>
		</gt>
		<gte set="method" line="124" static="1">
			<f a="a:b">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A>=B]]></e></m></meta>
		</gte>
		<toFloat set="method" line="278" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toFloat>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Uint16Array" params="" file="Kha/Backends/HTML5/Uint16Array.hx" extern="1">
		<new public="1" set="method"><f a="data">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="haxe.Function" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1"><meta><m n=":keep"/></meta></class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is null, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array [] if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
		<match public="1" set="method" static="1">
			<f a="e:pattern">
				<x path="EnumValue"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning true if
		matching succeeded and false otherwise.

		Example usage:

		```
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
		</match>
	</class>
	<abstract path="haxe.Int32" params="" file="/usr/lib/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
 	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/usr/lib/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/usr/lib/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/usr/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/usr/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>* This typedef will fool @:coreApi into thinking that we are using
  * the same underlying type, even though it might be different on
  * specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe._Int64.___Int64" params="" file="/usr/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<high public="1"><x path="haxe.Int32"/></high>
		<low public="1"><x path="haxe.Int32"/></low>
		<new public="1" get="inline" set="null" line="440"><f a="high:low">
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Json" params="" file="/usr/lib/haxe/std/js/_std/haxe/Json.hx" extern="1">
		<parse public="1" set="method" static="1">
			<f a="text">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[Parses given JSON-encoded `text` and returns the resulting object.

		JSON objects are parsed into anonymous structures and JSON arrays
		are parsed into Array<Dynamic>.

		If given `text` is not valid JSON, an exception will be thrown.]]></haxe_doc>
		</parse>
		<stringify public="1" set="method" static="1">
			<f a="value:?replacer:?space">
				<d/>
				<f a=":">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes given `value` and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve
		actual object to be encoded. The `replacer` function two parameters,
		the key and the value being encoded. Initial key value is an empty string.
		
		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.</haxe_doc>
		</stringify>
		<haxe_doc>Crossplatform JSON API : it will automatically use the optimized native API if available.
	Use -D haxeJSON to force usage of the Haxe implementation even if a native API is found : this will provide
	extra encoding features such as enums (replaced by their index) and StringMaps.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":native"><e>"JSON"</e></m>
		</meta>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<t path="Null"><c path="Array"><d/></c></t>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Serializer" params="" file="/usr/lib/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="55" static="1">
			<x path="Bool"/>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set USE_CACHE to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of Serializer by
		setting their useCache field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="67" static="1">
			<x path="Bool"/>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of Serializer by
		setting their useEnumIndex field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="69" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="544" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

		This is a convenience function for creating a new instance of
		Serializer, serialize `v` into it and obtain the result through a call
		to toString().</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See USE_CACHE for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See USE_ENUM_INDEX for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="115">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		http://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="152"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="171">
			<f a="v">
				<unknown/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</serializeRef>
		<serializeFields set="method" line="208"><f a="v">
	<unknown/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="226">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

		All haxe-defined values and objects with the exception of functions can
		be serialized. Serialization of external/native objects is not
		guaranteed to work.

		The values of `this.useCache` and `this.useEnumIndex` may affect
		serialization output.</haxe_doc>
		</serialize>
		<new public="1" set="method" line="100">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each Serializer instance maintains its own cache if this.useCache` is
		true.</haxe_doc>
		</new>
		<haxe_doc>The Serializer class can be used to encode values and objects into a String,
	from which the Unserializer class can recreate the original representation.

	This class can be used in two ways:

	- create a new Serializer() instance, call its serialize() method with
		any argument and finally retrieve the String representation from
		toString()
	- call Serializer.run() to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	`http://haxe.org/manual/serialization/format`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Unserializer" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="60" static="1">
			<t path="haxe.TypeResolver"/>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a Class or Enum instance from a given String. By
		default, the haxe Type Api is used.

		A type resolver must provide two methods:

		1. resolveClass(name:String):Class<Dynamic> is called to determine a
				Class from a class name
		2. resolveEnum(name:String):Enum<Dynamic> is called to determine an
				Enum from an enum name

		This value is applied when a new Unserializer instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 line="62" static="1"><c path="String"/></BASE64>
		<CODES line="65" static="1"><c path="Array"><x path="Int"/></c></CODES>
		<initCodes set="method" line="67" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="459" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its unserialize() method
		once.</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" set="method" line="124">
			<f a="r">
				<t path="haxe.TypeResolver"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the type resolver of `this` Unserializer instance to `r`.

		If `r` is null, a special resolver is used which returns null for all
		input values.

		See DEFAULT_RESOLVER for more information on type resolvers.</haxe_doc>
		</setResolver>
		<get get="inline" set="null" line="143"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<readDigits set="method" line="147"><f a=""><x path="Int"/></f></readDigits>
		<readFloat set="method" line="172"><f a=""><x path="Float"/></f></readFloat>
		<unserializeObject set="method" line="185"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="200"><f a="edecl:tag">
	<x path="Enum"><unknown/></x>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="232">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from Type.createEmptyInstance, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="99">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc>The Unserializer class is the complement to the Serializer class. It parses
	a serialization String and creates objects from the contained data.

	This class can be used in two ways:

	- create a new Unserializer() instance with a given serialization
		String, then call its unserialize() method until all values are
		extracted
	- call Unserializer.run() to unserialize a single value from a given
		String</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="/usr/lib/haxe/std/js/_std/haxe/ds/IntMap.hx">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><d/></h>
		<set public="1" get="inline" set="null" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<keys public="1" set="method" line="50">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<new public="1" get="inline" set="null" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/lib/haxe/std/js/_std/haxe/ds/ObjectMap.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<count line="28" static="1"><x path="Int"/></count>
		<h><a/></h>
		<set public="1" set="method" line="45">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<keys public="1" set="method" line="67">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._StringMap.StringMapIterator" params="T" file="/usr/lib/haxe/std/js/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap">
		<map><c path="haxe.ds.StringMap"><c path="haxe.ds._StringMap.StringMapIterator.T"/></c></map>
		<keys><c path="Array"><c path="String"/></c></keys>
		<index><x path="Int"/></index>
		<count><x path="Int"/></count>
		<hasNext public="1" get="inline" set="null" line="35"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="38"><f a=""><t path="Null"><c path="haxe.ds._StringMap.StringMapIterator.T"/></t></f></next>
		<new public="1" get="inline" set="null" line="29"><f a="map:keys">
	<c path="haxe.ds.StringMap"><c path="haxe.ds._StringMap.StringMapIterator.T"/></c>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/js/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<h><d/></h>
		<rh><d/></rh>
		<set public="1" get="inline" set="null" line="56">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="63">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="69">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<setReserved set="method" line="75"><f a="key:value">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
	<x path="Void"/>
</f></setReserved>
		<getReserved set="method" line="80"><f a="key">
	<c path="String"/>
	<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
</f></getReserved>
		<existsReserved set="method" line="84">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</existsReserved>
		<remove public="1" set="method" line="89">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="103">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<arrayKeys set="method" line="107">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta><m n=":has_untyped"/></meta>
		</arrayKeys>
		<iterator public="1" get="inline" set="null" line="124">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<new public="1" get="inline" set="null" line="48">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="/usr/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="/usr/lib/haxe/std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/usr/lib/haxe/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</to>
		<haxe_doc>An abstract type allowing values to be either of `T1` or `T2` type.
    Supports implicit casts from/to either types.

    It is useful for interfacing with external code on dynamic platforms
    such as JavaScript or Python.

    Otherwise, use of this type is discouraged.</haxe_doc>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/usr/lib/haxe/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.extern.Rest" params="T" file="/usr/lib/haxe/std/haxe/extern/Rest.hx">
		<this><c path="Array"><c path="haxe.extern.Rest.T"/></c></this>
		<haxe_doc>A special abstract type that represents "rest" function argument.

    Should be used as a type for the last argument of an extern method,
    representing that arbitrary number of arguments of given type can be
    passed to that method.</haxe_doc>
		<impl><class path="haxe.extern._Rest.Rest_Impl_" params="" file="/usr/lib/haxe/std/haxe/extern/Rest.hx" private="1" module="haxe.extern.Rest"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.io.ArrayBufferViewData" params="" file="/usr/lib/haxe/std/js/_std/haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView"><c path="js.html.ArrayBufferView"/></typedef>
	<abstract path="haxe.io.ArrayBufferView" params="" file="/usr/lib/haxe/std/js/_std/haxe/io/ArrayBufferView.hx">
		<this><t path="haxe.io.ArrayBufferViewData"/></this>
		<impl><class path="haxe.io._ArrayBufferView.ArrayBufferView_Impl_" params="" file="/usr/lib/haxe/std/js/_std/haxe/io/ArrayBufferView.hx" private="1" module="haxe.io.ArrayBufferView">
	<EMULATED public="1" get="accessor" set="null" static="1"><x path="Bool"/></EMULATED>
	<buffer public="1" get="accessor" set="null" static="1">
		<c path="haxe.io.Bytes"/>
		<meta><m n=":impl"/></meta>
	</buffer>
	<byteOffset public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</byteOffset>
	<byteLength public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</byteLength>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/js/_std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="190" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="194" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="222" static="1">
			<f a="b">
				<t path="haxe.io.BytesData"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</ofData>
		<length public="1" set="null"><x path="Int"/></length>
		<b><c path="js.html.Uint8Array"/></b>
		<data><c path="js.html.DataView"/></data>
		<get public="1" get="inline" set="null" line="43"><f a="pos">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="47"><f a="pos:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<getFloat public="1" set="method" line="88">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE single precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getFloat>
		<getString public="1" set="method" line="132"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<toString public="1" set="method" line="168"><f a=""><c path="String"/></f></toString>
		<new set="method" line="33">
			<f a="data">
				<t path="haxe.io.BytesData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<b><c path="Array"><x path="Int"/></c></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<addBytes public="1" get="inline" set="null" line="160"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="191">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="js.html.ArrayBuffer"/></typedef>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<bigEndian public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when reading numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<readByte public="1" set="method" line="46">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="61">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<readFullBytes public="1" set="method" line="130">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Unlike `readBytes`, this method tries to read the exact `len` amount of bytes.</haxe_doc>
		</readFullBytes>
		<read public="1" set="method" line="141">
			<f a="nbytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return `nbytes` bytes.</haxe_doc>
		</read>
		<readInt32 public="1" set="method" line="275">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt32>
		<readString public="1" set="method" line="294">
			<f a="len">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read and `len` bytes as a string.</haxe_doc>
		</readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesInput" params="" file="/usr/lib/haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><c path="js.html.Uint8Array"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<position public="1" get="null" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<set_position set="method" line="79"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></set_position>
		<readByte public="1" set="method" line="90" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="111" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="38"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/lib/haxe/std/haxe/io/Output.hx">
		<bigEndian public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when writing numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<write public="1" set="method" line="104">
			<f a="s">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write all bytes stored in `s`.</haxe_doc>
		</write>
		<writeInt16 public="1" set="method" line="167">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt16>
		<writeUInt16 public="1" set="method" line="177">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeUInt16>
		<writeInt32 public="1" set="method" line="221">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt32>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeByte] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="/usr/lib/haxe/std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<writeByte public="1" set="method" line="51" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="59" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<getBytes public="1" set="method" line="125"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.FPHelper" params="" file="/usr/lib/haxe/std/haxe/io/FPHelper.hx">
		<i64tmp line="35" static="1"><x path="haxe.Int64"/></i64tmp>
		<i32ToFloat public="1" set="method" line="62" static="1"><f a="i">
	<x path="Int"/>
	<x path="Float"/>
</f></i32ToFloat>
		<floatToI32 public="1" set="method" line="109" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></floatToI32>
		<i64ToDouble public="1" set="method" line="149" static="1"><f a="low:high">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></i64ToDouble>
		<doubleToI64 public="1" set="method" line="208" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Returns an Int64 representing the bytes representation of the double precision IEEE float value.
		WARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.
		We still ensure that this is safe to use in a multithread environment</haxe_doc>
		</doubleToI64>
		<haxe_doc>Helper that converts between floating point and binary representation.
	Always works in low-endian encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.Float32ArrayData" params="" file="/usr/lib/haxe/std/js/_std/haxe/io/Float32Array.hx" module="haxe.io.Float32Array"><c path="js.html.Float32Array"/></typedef>
	<abstract path="haxe.io.Float32Array" params="" file="/usr/lib/haxe/std/js/_std/haxe/io/Float32Array.hx">
		<this><t path="haxe.io.Float32ArrayData"/></this>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe.io._Float32Array.Float32Array_Impl_" params="" file="/usr/lib/haxe/std/js/_std/haxe/io/Float32Array.hx" private="1" module="haxe.io.Float32Array">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<view public="1" get="accessor" set="null" static="1">
		<x path="haxe.io.ArrayBufferView"/>
		<meta><m n=":impl"/></meta>
	</view>
	<meta>
		<m n=":keep"/>
		<m n=":coreApi"/>
	</meta>
</class></impl>
	</abstract>
	<typedef path="haxe.macro.Position" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><x path="Int"/></min>
	<max><x path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<typedef path="haxe.macro.Expr" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<typedef path="haxe.macro.Case" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<guard>
		<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
		<meta><m n=":optional"/></meta>
	</guard>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Var" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Catch" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></typedef>
	<typedef path="haxe.macro.TypePath" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub>
		<t path="Null"><t path="Null"><c path="String"/></t></t>
		<meta><m n=":optional"/></meta>
	</sub>
	<params>
		<t path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<name><c path="String"/></name>
	<constraints>
		<t path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></t>
		<meta><m n=":optional"/></meta>
	</constraints>
</a></typedef>
	<typedef path="haxe.macro.Function" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value>
		<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
		<meta><m n=":optional"/></meta>
	</value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><t path="haxe.macro.MetadataEntry"/></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta>
		<t path="Null"><t path="haxe.macro.Metadata"/></t>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc>
		<t path="Null"><t path="Null"><c path="String"/></t></t>
		<meta><m n=":optional"/></meta>
	</doc>
	<access>
		<t path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></t>
		<meta><m n=":optional"/></meta>
	</access>
</a></typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta>
		<t path="Null"><t path="haxe.macro.Metadata"/></t>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<path><c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c></path>
	<mode><e path="haxe.macro.ImportMode"/></mode>
</a></typedef>
	<typedef path="haxe.macro.TExprTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools">
		<c path="haxe.macro.ExprTools"/>
		<haxe_doc>This class can be added via 'using haxe.macro.Tools' in order to enable
	'using' functionality on all macro tool classes listed below.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TComplexTypeTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools"><c path="haxe.macro.ComplexTypeTools"/></typedef>
	<typedef path="haxe.macro.TTypeTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools"><c path="haxe.macro.TypeTools"/></typedef>
	<typedef path="haxe.macro.TMacroStringTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools"><c path="haxe.macro.MacroStringTools"/></typedef>
	<typedef path="haxe.macro.TTypedExprTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools"><c path="haxe.macro.TypedExprTools"/></typedef>
	<typedef path="haxe.macro.TPositionTools" params="" file="/usr/lib/haxe/std/haxe/macro/Tools.hx" module="haxe.macro.Tools"><c path="haxe.macro.PositionTools"/></typedef>
	<typedef path="haxe.macro.Ref" params="T" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<toString set="method"><f a=""><c path="String"/></f></toString>
	<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
</a></typedef>
	<typedef path="haxe.macro.AnonType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<status><e path="haxe.macro.AnonStatus"/></status>
	<fields><c path="Array"><t path="haxe.macro.ClassField"/></c></fields>
</a></typedef>
	<typedef path="haxe.macro.TypeParameter" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.BaseType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.ClassField" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.FieldKind"/></kind>
	<isPublic><x path="Bool"/></isPublic>
	<expr set="method"><f a=""><t path="Null"><t path="haxe.macro.TypedExpr"/></t></f></expr>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.ClassType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<superClass><t path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></t></superClass>
	<statics><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></statics>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<overrides><c path="Array"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></c></overrides>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.ClassKind"/></kind>
	<isPrivate><x path="Bool"/></isPrivate>
	<isInterface><x path="Bool"/></isInterface>
	<isExtern><x path="Bool"/></isExtern>
	<interfaces><c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c></interfaces>
	<init><t path="Null"><t path="haxe.macro.TypedExpr"/></t></init>
	<fields><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></fields>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructor><t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></t></constructor>
</a></typedef>
	<typedef path="haxe.macro.EnumField" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<index><x path="Int"/></index>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.EnumType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<names><c path="Array"><c path="String"/></c></names>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructs><x path="Map">
	<c path="String"/>
	<t path="haxe.macro.EnumField"/>
</x></constructs>
</a></typedef>
	<typedef path="haxe.macro.DefType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.AbstractType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<unops><c path="Array"><a>
	<postFix><x path="Bool"/></postFix>
	<op><e path="haxe.macro.Unop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c></unops>
	<type><e path="haxe.macro.Type"/></type>
	<to><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><t path="Null"><t path="haxe.macro.ClassField"/></t></field>
</a></c></to>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<impl><t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t></impl>
	<from><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><t path="Null"><t path="haxe.macro.ClassField"/></t></field>
</a></c></from>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<binops><c path="Array"><a>
	<op><e path="haxe.macro.Binop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c></binops>
	<array><c path="Array"><t path="haxe.macro.ClassField"/></c></array>
</a></typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<remove set="method">
				<f a="name">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Removes all `name` metadata entries from the origin of `this`
		MetaAccess.

		This method might clear several metadata entries of the same name.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `remove` has no effect on that array.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</remove>
			<has set="method">
				<f a="name">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>Tells if the origin of `this` MetaAccess has a `name` metadata entry.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</has>
			<get set="method">
				<f a=""><t path="haxe.macro.Metadata"/></f>
				<haxe_doc>Return the wrapped `Metadata` array.

		Modifying this array has no effect on the origin of `this` MetaAccess.
		The `add` and `remove` methods can be used for that.</haxe_doc>
			</get>
			<extract set="method">
				<f a="name">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
				</f>
				<haxe_doc>Extract metadata entries by given `name`.

		If there's no metadata with such name, empty array is returned.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</extract>
			<add set="method">
				<f a="name:params:pos">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.Expr"/></c>
					<t path="haxe.macro.Position"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Adds the metadata specified by `name`, `params` and `pos` to the origin
		of `this` MetaAccess.

		Metadata names are not unique during compilation, so this method never
		overwrites a previous metadata.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `add` has no effect on that array.

		If any argument is null, compilation fails with an error.</haxe_doc>
			</add>
		</a>
		<haxe_doc>MetaAccess is a wrapper for the `Metadata` array. It can be used to add
	metadata to and remove metadata from its origin.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TVar" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t set="null"><e path="haxe.macro.Type"/></t>
	<name set="null"><c path="String"/></name>
	<id set="null"><x path="Int"/></id>
	<extra set="null"><t path="Null"><a>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<expr><t path="Null"><t path="haxe.macro.TypedExpr"/></t></expr>
</a></t></extra>
	<capture set="null"><x path="Bool"/></capture>
</a></typedef>
	<typedef path="haxe.macro.TFunc" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t><e path="haxe.macro.Type"/></t>
	<expr><t path="haxe.macro.TypedExpr"/></expr>
	<args><c path="Array"><a>
	<value><t path="Null"><e path="haxe.macro.TConstant"/></t></value>
	<v><t path="haxe.macro.TVar"/></v>
</a></c></args>
</a></typedef>
	<typedef path="haxe.macro.TypedExpr" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t><e path="haxe.macro.Type"/></t>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.TypedExprDef"/></expr>
</a></typedef>
	<class path="js.Error" params="" file="/usr/lib/haxe/std/js/Error.hx" extern="1">
		<message public="1"><c path="String"/></message>
		<name public="1"><c path="String"/></name>
		<stack public="1" set="null"><c path="String"/></stack>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Error"</e></m>
		</meta>
	</class>
	<class path="js._Boot.HaxeError" params="" file="/usr/lib/haxe/std/js/Boot.hx" private="1" module="js.Boot">
		<extends path="js.Error"/>
		<val><d/></val>
		<new public="1" set="method" line="28">
			<f a="val">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="js.Boot" params="" file="/usr/lib/haxe/std/js/Boot.hx">
		<__unhtml set="method" line="39" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unhtml>
		<__trace set="method" line="43" static="1">
			<f a="v:i">
				<a>
					<toString set="null"><f a=""><c path="String"/></f></toString>
					<length set="null"><x path="Int"/></length>
					<hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></hasOwnProperty>
					<__enum__ set="null"><x path="Bool"/></__enum__>
				</a>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__trace>
		<getClass set="method" line="83" static="1">
			<f a="o">
				<d/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getClass>
		<__string_rec set="method" line="98" static="1">
			<f a="o:s">
				<a>
					<toString set="null"><f a=""><c path="String"/></f></toString>
					<length set="null"><x path="Int"/></length>
					<hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></hasOwnProperty>
					<__enum__ set="null"><x path="Bool"/></__enum__>
				</a>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"has_enum"</e></m>
			</meta>
		</__string_rec>
		<__interfLoop set="method" line="170" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="185" static="1">
			<f a="o:cl">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"typed_catch"</e></m>
			</meta>
		</__instanceof>
		<__cast set="method" line="224" static="1">
			<f a="o:t">
				<d/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":ifFeature"><e>"typed_cast"</e></m></meta>
		</__cast>
		<__toStr line="229" static="1">
			<a><call set="null"><f a="">
	<d/>
	<a><slice set="null"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></slice></a>
</f></call></a>
			<meta><m n=":has_untyped"/></meta>
		</__toStr>
		<__nativeClassName set="method" line="231" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__nativeClassName>
		<__isNativeObj set="method" line="241" static="1"><f a="o">
	<d/>
	<x path="Bool"/>
</f></__isNativeObj>
		<__resolveNativeClass set="method" line="246" static="1">
			<f a="name">
				<c path="String"/>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__resolveNativeClass>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="js.Browser" params="" file="/usr/lib/haxe/std/js/Browser.hx">
		<window public="1" get="null" set="null" static="1">
			<c path="js.html.Window"/>
			<haxe_doc>The global window object.</haxe_doc>
		</window>
		<document public="1" get="null" set="null" static="1">
			<c path="js.html.HTMLDocument"/>
			<haxe_doc>Shortcut to Window.document.</haxe_doc>
		</document>
		<location public="1" get="null" set="null" static="1">
			<c path="js.html.Location"/>
			<haxe_doc>Shortcut to Window.location.</haxe_doc>
		</location>
		<navigator public="1" get="null" set="null" static="1">
			<c path="js.html.Navigator"/>
			<haxe_doc>Shortcut to Window.navigator.</haxe_doc>
		</navigator>
		<console public="1" get="null" set="null" static="1">
			<c path="js.html.Console"/>
			<haxe_doc>Shortcut to Window.console.</haxe_doc>
		</console>
		<supported public="1" get="null" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* True if a window object exists, false otherwise.
	 *
	 * This can be used to check if the code is being executed in a non-browser
	 * environment such as node.js.</haxe_doc>
		</supported>
		<alert public="1" set="method" line="105" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Display an alert message box containing the given message. See also `Window.alert()`.</haxe_doc>
		</alert>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="js.EvalError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"EvalError"</e></m></meta>
	</class>
	<class path="js.RangeError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"RangeError"</e></m></meta>
	</class>
	<class path="js.ReferenceError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"ReferenceError"</e></m></meta>
	</class>
	<class path="js.SyntaxError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"SyntaxError"</e></m></meta>
	</class>
	<class path="js.TypeError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"TypeError"</e></m></meta>
	</class>
	<class path="js.URIError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"URIError"</e></m></meta>
	</class>
	<class path="js.Promise" params="T" file="/usr/lib/haxe/std/js/Promise.hx" extern="1">
		<resolve public="1" params="T" set="method" static="1">
			<f a="value">
				<c path="resolve.T"/>
				<c path="js.Promise"><c path="resolve.T"/></c>
			</f>
			<overloads>
				<resolve public="1" params="T" set="method"><f a="promise">
	<c path="js.Promise"><c path="resolve.T"/></c>
	<c path="js.Promise"><c path="resolve.T"/></c>
</f></resolve>
				<resolve public="1" params="T" set="method"><f a="thenable">
	<t path="js.Thenable"><c path="resolve.T"/></t>
	<c path="js.Promise"><c path="resolve.T"/></c>
</f></resolve>
			</overloads>
		</resolve>
		<reject public="1" params="T" set="method" static="1"><f a="?value">
	<d/>
	<c path="js.Promise"><c path="reject.T"/></c>
</f></reject>
		<all public="1" set="method" static="1"><f a="iterable">
	<c path="Array"><d/></c>
	<c path="js.Promise"><c path="Array"><d/></c></c>
</f></all>
		<race public="1" set="method" static="1"><f a="iterable">
	<c path="Array"><d/></c>
	<c path="js.Promise"><d/></c>
</f></race>
		<then public="1" params="TOut" set="method"><f a="?fulfillCallback:?rejectCallback">
	<t path="js.PromiseCallback">
		<c path="js.Promise.T"/>
		<c path="then.TOut"/>
	</t>
	<x path="haxe.extern.EitherType">
		<f a="">
			<d/>
			<x path="Void"/>
		</f>
		<t path="js.PromiseCallback">
			<d/>
			<c path="then.TOut"/>
		</t>
	</x>
	<c path="js.Promise"><c path="then.TOut"/></c>
</f></then>
		<catchError public="1" params="TOut" set="method">
			<f a="rejectCallback">
				<x path="haxe.extern.EitherType">
					<f a="">
						<d/>
						<x path="Void"/>
					</f>
					<t path="js.PromiseCallback">
						<d/>
						<c path="catchError.TOut"/>
					</t>
				</x>
				<c path="js.Promise"><c path="catchError.TOut"/></c>
			</f>
			<meta><m n=":native"><e>"catch"</e></m></meta>
		</catchError>
		<new public="1" set="method">
			<f a="init">
				<f a=":">
					<f a="">
						<c path="js.Promise.T"/>
						<x path="Void"/>
					</f>
					<f a="">
						<d/>
						<x path="Void"/>
					</f>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Promise"</e></m></meta>
	</class>
	<typedef path="js.PromiseCallback" params="T:TOut" file="/usr/lib/haxe/std/js/Promise.hx" module="js.Promise"><x path="haxe.extern.EitherType">
	<f a="">
		<c path="js.PromiseCallback.T"/>
		<c path="js.PromiseCallback.TOut"/>
	</f>
	<f a="">
		<c path="js.PromiseCallback.T"/>
		<c path="js.Promise"><c path="js.PromiseCallback.TOut"/></c>
	</f>
</x></typedef>
	<typedef path="js.Thenable" params="T" file="/usr/lib/haxe/std/js/Promise.hx" module="js.Promise"><a><then><x path="haxe.extern.EitherType">
	<f a=":">
		<f a="">
			<c path="js.Thenable.T"/>
			<x path="Void"/>
		</f>
		<f a="">
			<d/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<f a="">
		<f a="">
			<c path="js.Thenable.T"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
</x></then></a></typedef>
	<class path="js.RegExpMatch" params="" file="/usr/lib/haxe/std/js/RegExp.hx" module="js.RegExp" extern="1">
		<extends path="Array"><c path="String"/></extends>
		<index public="1"><x path="Int"/></index>
		<input public="1"><c path="String"/></input>
	</class>
	<abstract path="js.html.AlignSetting" params="" file="/usr/lib/haxe/std/js/html/AlignSetting.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._AlignSetting.AlignSetting_Impl_" params="" file="/usr/lib/haxe/std/js/html/AlignSetting.hx" private="1" module="js.html.AlignSetting"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.EventTarget" params="" file="/usr/lib/haxe/std/js/html/EventTarget.hx" extern="1">
		<addEventListener public="1" set="method">
			<f a="type:listener:?capture" v="::false">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{capture:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><addEventListener public="1" set="method">
	<f a="type:listener:?capture:?wantsUntrusted" v="::false:">
		<c path="String"/>
		<c path="js.html.EventListener"/>
		<x path="Bool"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{capture:false}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</addEventListener></overloads>
		</addEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?capture" v="::false">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{capture:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><removeEventListener public="1" set="method">
	<f a="type:listener:?capture" v="::false">
		<c path="String"/>
		<c path="js.html.EventListener"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{capture:false}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</removeEventListener></overloads>
		</removeEventListener>
		<dispatchEvent public="1" set="method">
			<f a="event">
				<c path="js.html.Event"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</dispatchEvent>
		<meta><m n=":native"><e>"EventTarget"</e></m></meta>
	</class>
	<class path="js.html.Node" params="" file="/usr/lib/haxe/std/js/html/Node.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<ELEMENT_NODE public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ELEMENT_NODE>
		<ATTRIBUTE_NODE public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</ATTRIBUTE_NODE>
		<TEXT_NODE public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</TEXT_NODE>
		<CDATA_SECTION_NODE public="1" get="inline" set="null" expr="4" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</CDATA_SECTION_NODE>
		<ENTITY_REFERENCE_NODE public="1" get="inline" set="null" expr="5" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</ENTITY_REFERENCE_NODE>
		<ENTITY_NODE public="1" get="inline" set="null" expr="6" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</ENTITY_NODE>
		<PROCESSING_INSTRUCTION_NODE public="1" get="inline" set="null" expr="7" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</PROCESSING_INSTRUCTION_NODE>
		<COMMENT_NODE public="1" get="inline" set="null" expr="8" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</COMMENT_NODE>
		<DOCUMENT_NODE public="1" get="inline" set="null" expr="9" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</DOCUMENT_NODE>
		<DOCUMENT_TYPE_NODE public="1" get="inline" set="null" expr="10" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</DOCUMENT_TYPE_NODE>
		<DOCUMENT_FRAGMENT_NODE public="1" get="inline" set="null" expr="11" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</DOCUMENT_FRAGMENT_NODE>
		<NOTATION_NODE public="1" get="inline" set="null" expr="12" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</NOTATION_NODE>
		<DOCUMENT_POSITION_DISCONNECTED public="1" get="inline" set="null" expr="1" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</DOCUMENT_POSITION_DISCONNECTED>
		<DOCUMENT_POSITION_PRECEDING public="1" get="inline" set="null" expr="2" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</DOCUMENT_POSITION_PRECEDING>
		<DOCUMENT_POSITION_FOLLOWING public="1" get="inline" set="null" expr="4" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</DOCUMENT_POSITION_FOLLOWING>
		<DOCUMENT_POSITION_CONTAINS public="1" get="inline" set="null" expr="8" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</DOCUMENT_POSITION_CONTAINS>
		<DOCUMENT_POSITION_CONTAINED_BY public="1" get="inline" set="null" expr="16" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</DOCUMENT_POSITION_CONTAINED_BY>
		<DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC public="1" get="inline" set="null" expr="32" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC>
		<nodeType public="1" set="null"><x path="Int"/></nodeType>
		<nodeName public="1" set="null"><c path="String"/></nodeName>
		<baseURI public="1" set="null"><c path="String"/></baseURI>
		<ownerDocument public="1" set="null"><c path="js.html.HTMLDocument"/></ownerDocument>
		<parentNode public="1" set="null"><c path="js.html.Node"/></parentNode>
		<parentElement public="1" set="null"><c path="js.html.Element"/></parentElement>
		<childNodes public="1" set="null"><c path="js.html.NodeList"/></childNodes>
		<firstChild public="1" set="null"><c path="js.html.Node"/></firstChild>
		<lastChild public="1" set="null"><c path="js.html.Node"/></lastChild>
		<previousSibling public="1" set="null"><c path="js.html.Node"/></previousSibling>
		<nextSibling public="1" set="null"><c path="js.html.Node"/></nextSibling>
		<nodeValue public="1"><c path="String"/></nodeValue>
		<textContent public="1"><c path="String"/></textContent>
		<namespaceURI public="1" set="null"><c path="String"/></namespaceURI>
		<prefix public="1" set="null"><c path="String"/></prefix>
		<localName public="1" set="null"><c path="String"/></localName>
		<hasChildNodes public="1" set="method"><f a=""><x path="Bool"/></f></hasChildNodes>
		<insertBefore public="1" set="method">
			<f a="node:child">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertBefore>
		<appendChild public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</appendChild>
		<replaceChild public="1" set="method">
			<f a="node:child">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replaceChild>
		<removeChild public="1" set="method">
			<f a="child">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeChild>
		<normalize public="1" set="method"><f a=""><x path="Void"/></f></normalize>
		<cloneNode public="1" set="method">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="js.html.Node"/>
			</f>
			<meta><m n=":value"><e>{deep:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cloneNode>
		<isEqualNode public="1" set="method"><f a="node">
	<c path="js.html.Node"/>
	<x path="Bool"/>
</f></isEqualNode>
		<compareDocumentPosition public="1" set="method"><f a="other">
	<c path="js.html.Node"/>
	<x path="Int"/>
</f></compareDocumentPosition>
		<contains public="1" set="method"><f a="other">
	<c path="js.html.Node"/>
	<x path="Bool"/>
</f></contains>
		<lookupPrefix public="1" set="method"><f a="namespace_">
	<c path="String"/>
	<c path="String"/>
</f></lookupPrefix>
		<lookupNamespaceURI public="1" set="method"><f a="prefix">
	<c path="String"/>
	<c path="String"/>
</f></lookupNamespaceURI>
		<isDefaultNamespace public="1" set="method"><f a="namespace_">
	<c path="String"/>
	<x path="Bool"/>
</f></isDefaultNamespace>
		<meta><m n=":native"><e>"Node"</e></m></meta>
	</class>
	<class path="js.html.DOMElement" params="" file="/usr/lib/haxe/std/js/html/DOMElement.hx" extern="1">
		<extends path="js.html.Node"/>
		<tagName public="1" set="null"><c path="String"/></tagName>
		<id public="1"><c path="String"/></id>
		<className public="1"><c path="String"/></className>
		<classList public="1" set="null"><c path="js.html.DOMTokenList"/></classList>
		<attributes public="1" set="null"><c path="js.html.NamedNodeMap"/></attributes>
		<onwheel public="1"><x path="haxe.Function"/></onwheel>
		<title public="1"><c path="String"/></title>
		<lang public="1"><c path="String"/></lang>
		<dir public="1"><c path="String"/></dir>
		<dataset public="1" set="null"><c path="js.html.DOMStringMap"/></dataset>
		<itemScope public="1"><x path="Bool"/></itemScope>
		<itemType public="1" set="null"><c path="js.html.DOMSettableTokenList"/></itemType>
		<itemId public="1"><c path="String"/></itemId>
		<itemRef public="1" set="null"><c path="js.html.DOMSettableTokenList"/></itemRef>
		<itemProp public="1" set="null"><c path="js.html.DOMSettableTokenList"/></itemProp>
		<properties public="1" set="null"><c path="js.html.HTMLPropertiesCollection"/></properties>
		<itemValue public="1"><d/></itemValue>
		<hidden public="1"><x path="Bool"/></hidden>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<accessKey public="1"><c path="String"/></accessKey>
		<accessKeyLabel public="1" set="null"><c path="String"/></accessKeyLabel>
		<draggable public="1"><x path="Bool"/></draggable>
		<contentEditable public="1"><c path="String"/></contentEditable>
		<isContentEditable public="1" set="null"><x path="Bool"/></isContentEditable>
		<contextMenu public="1" set="null"><c path="js.html.MenuElement"/></contextMenu>
		<spellcheck public="1"><x path="Bool"/></spellcheck>
		<style public="1" set="null"><c path="js.html.CSSStyleDeclaration"/></style>
		<oncopy public="1"><x path="haxe.Function"/></oncopy>
		<oncut public="1"><x path="haxe.Function"/></oncut>
		<onpaste public="1"><x path="haxe.Function"/></onpaste>
		<innerText public="1"><c path="String"/></innerText>
		<offsetParent public="1" set="null"><c path="js.html.Element"/></offsetParent>
		<offsetTop public="1" set="null"><x path="Int"/></offsetTop>
		<offsetLeft public="1" set="null"><x path="Int"/></offsetLeft>
		<offsetWidth public="1" set="null"><x path="Int"/></offsetWidth>
		<offsetHeight public="1" set="null"><x path="Int"/></offsetHeight>
		<scrollTop public="1"><x path="Int"/></scrollTop>
		<scrollLeft public="1"><x path="Int"/></scrollLeft>
		<scrollWidth public="1" set="null"><x path="Int"/></scrollWidth>
		<scrollHeight public="1" set="null"><x path="Int"/></scrollHeight>
		<clientTop public="1" set="null"><x path="Int"/></clientTop>
		<clientLeft public="1" set="null"><x path="Int"/></clientLeft>
		<clientWidth public="1" set="null"><x path="Int"/></clientWidth>
		<clientHeight public="1" set="null"><x path="Int"/></clientHeight>
		<scrollTopMax public="1" set="null"><x path="Int"/></scrollTopMax>
		<scrollLeftMax public="1" set="null"><x path="Int"/></scrollLeftMax>
		<innerHTML public="1"><c path="String"/></innerHTML>
		<outerHTML public="1"><c path="String"/></outerHTML>
		<shadowRoot public="1" set="null"><c path="js.html.ShadowRoot"/></shadowRoot>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onblur public="1"><x path="haxe.Function"/></onblur>
		<onfocus public="1"><x path="haxe.Function"/></onfocus>
		<oncanplay public="1"><x path="haxe.Function"/></oncanplay>
		<oncanplaythrough public="1"><x path="haxe.Function"/></oncanplaythrough>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onclick public="1"><x path="haxe.Function"/></onclick>
		<oncontextmenu public="1"><x path="haxe.Function"/></oncontextmenu>
		<ondblclick public="1"><x path="haxe.Function"/></ondblclick>
		<ondrag public="1"><x path="haxe.Function"/></ondrag>
		<ondragend public="1"><x path="haxe.Function"/></ondragend>
		<ondragenter public="1"><x path="haxe.Function"/></ondragenter>
		<ondragleave public="1"><x path="haxe.Function"/></ondragleave>
		<ondragover public="1"><x path="haxe.Function"/></ondragover>
		<ondragstart public="1"><x path="haxe.Function"/></ondragstart>
		<ondrop public="1"><x path="haxe.Function"/></ondrop>
		<ondurationchange public="1"><x path="haxe.Function"/></ondurationchange>
		<onemptied public="1"><x path="haxe.Function"/></onemptied>
		<onended public="1"><x path="haxe.Function"/></onended>
		<oninput public="1"><x path="haxe.Function"/></oninput>
		<oninvalid public="1"><x path="haxe.Function"/></oninvalid>
		<onkeydown public="1"><x path="haxe.Function"/></onkeydown>
		<onkeypress public="1"><x path="haxe.Function"/></onkeypress>
		<onkeyup public="1"><x path="haxe.Function"/></onkeyup>
		<onload public="1"><x path="haxe.Function"/></onload>
		<onloadeddata public="1"><x path="haxe.Function"/></onloadeddata>
		<onloadedmetadata public="1"><x path="haxe.Function"/></onloadedmetadata>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onmousedown public="1"><x path="haxe.Function"/></onmousedown>
		<onmouseenter public="1"><x path="haxe.Function"/></onmouseenter>
		<onmouseleave public="1"><x path="haxe.Function"/></onmouseleave>
		<onmousemove public="1"><x path="haxe.Function"/></onmousemove>
		<onmouseout public="1"><x path="haxe.Function"/></onmouseout>
		<onmouseover public="1"><x path="haxe.Function"/></onmouseover>
		<onmouseup public="1"><x path="haxe.Function"/></onmouseup>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onplay public="1"><x path="haxe.Function"/></onplay>
		<onplaying public="1"><x path="haxe.Function"/></onplaying>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onratechange public="1"><x path="haxe.Function"/></onratechange>
		<onreset public="1"><x path="haxe.Function"/></onreset>
		<onscroll public="1"><x path="haxe.Function"/></onscroll>
		<onseeked public="1"><x path="haxe.Function"/></onseeked>
		<onseeking public="1"><x path="haxe.Function"/></onseeking>
		<onselect public="1"><x path="haxe.Function"/></onselect>
		<onshow public="1"><x path="haxe.Function"/></onshow>
		<onstalled public="1"><x path="haxe.Function"/></onstalled>
		<onsubmit public="1"><x path="haxe.Function"/></onsubmit>
		<onsuspend public="1"><x path="haxe.Function"/></onsuspend>
		<ontimeupdate public="1"><x path="haxe.Function"/></ontimeupdate>
		<onvolumechange public="1"><x path="haxe.Function"/></onvolumechange>
		<onwaiting public="1"><x path="haxe.Function"/></onwaiting>
		<onpointercancel public="1"><x path="haxe.Function"/></onpointercancel>
		<onpointerdown public="1"><x path="haxe.Function"/></onpointerdown>
		<onpointerup public="1"><x path="haxe.Function"/></onpointerup>
		<onpointermove public="1"><x path="haxe.Function"/></onpointermove>
		<onpointerout public="1"><x path="haxe.Function"/></onpointerout>
		<onpointerover public="1"><x path="haxe.Function"/></onpointerover>
		<onpointerenter public="1"><x path="haxe.Function"/></onpointerenter>
		<onpointerleave public="1"><x path="haxe.Function"/></onpointerleave>
		<ongotpointercapture public="1"><x path="haxe.Function"/></ongotpointercapture>
		<onlostpointercapture public="1"><x path="haxe.Function"/></onlostpointercapture>
		<onpointerlockchange public="1"><x path="haxe.Function"/></onpointerlockchange>
		<onpointerlockerror public="1"><x path="haxe.Function"/></onpointerlockerror>
		<previousElementSibling public="1" set="null"><c path="js.html.Element"/></previousElementSibling>
		<nextElementSibling public="1" set="null"><c path="js.html.Element"/></nextElementSibling>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<children public="1" set="null"><c path="js.html.HTMLCollection"/></children>
		<firstElementChild public="1" set="null"><c path="js.html.Element"/></firstElementChild>
		<lastElementChild public="1" set="null"><c path="js.html.Element"/></lastElementChild>
		<childElementCount public="1" set="null"><x path="Int"/></childElementCount>
		<ontouchstart public="1"><x path="haxe.Function"/></ontouchstart>
		<ontouchend public="1"><x path="haxe.Function"/></ontouchend>
		<ontouchmove public="1"><x path="haxe.Function"/></ontouchmove>
		<ontouchcancel public="1"><x path="haxe.Function"/></ontouchcancel>
		<getAttribute public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
		<getAttributeNS public="1" set="method"><f a="namespace_:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getAttributeNS>
		<setAttribute public="1" set="method">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttribute>
		<setAttributeNS public="1" set="method">
			<f a="namespace_:name:value">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttributeNS>
		<removeAttribute public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAttribute>
		<removeAttributeNS public="1" set="method">
			<f a="namespace_:localName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAttributeNS>
		<hasAttribute public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasAttribute>
		<hasAttributeNS public="1" set="method"><f a="namespace_:localName">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasAttributeNS>
		<hasAttributes public="1" set="method"><f a=""><x path="Bool"/></f></hasAttributes>
		<closest public="1" set="method">
			<f a="selector">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</closest>
		<matches public="1" set="method">
			<f a="selector">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</matches>
		<getElementsByTagName public="1" set="method"><f a="localName">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagName>
		<getElementsByTagNameNS public="1" set="method">
			<f a="namespace_:localName">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.HTMLCollection"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getElementsByTagNameNS>
		<getElementsByClassName public="1" set="method"><f a="classNames">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByClassName>
		<setPointerCapture public="1" set="method">
			<f a="pointerId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setPointerCapture>
		<releasePointerCapture public="1" set="method">
			<f a="pointerId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</releasePointerCapture>
		<setCapture public="1" set="method">
			<f a="?retargetToElement" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{retargetToElement:false}</e></m></meta>
		</setCapture>
		<releaseCapture public="1" set="method"><f a=""><x path="Void"/></f></releaseCapture>
		<requestPointerLock public="1" set="method"><f a=""><x path="Void"/></f></requestPointerLock>
		<getAttributeNode public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getAttributeNode>
		<setAttributeNode public="1" set="method">
			<f a="newAttr">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttributeNode>
		<removeAttributeNode public="1" set="method">
			<f a="oldAttr">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAttributeNode>
		<getAttributeNodeNS public="1" set="method"><f a="namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getAttributeNodeNS>
		<setAttributeNodeNS public="1" set="method">
			<f a="newAttr">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttributeNodeNS>
		<requestFullscreen public="1" set="method"><f a=""><x path="Void"/></f></requestFullscreen>
		<click public="1" set="method"><f a=""><x path="Void"/></f></click>
		<focus public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</focus>
		<blur public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</blur>
		<getClientRects public="1" set="method"><f a=""><c path="js.html.DOMRectList"/></f></getClientRects>
		<getBoundingClientRect public="1" set="method"><f a=""><c path="js.html.DOMRect"/></f></getBoundingClientRect>
		<scrollIntoView public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollIntoViewOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollIntoView public="1" set="method"><f a="top">
	<x path="Bool"/>
	<x path="Void"/>
</f></scrollIntoView></overloads>
		</scrollIntoView>
		<scroll public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scroll public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scroll></overloads>
		</scroll>
		<scrollTo public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollTo></overloads>
		</scrollTo>
		<scrollBy public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollBy public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollBy></overloads>
		</scrollBy>
		<insertAdjacentHTML public="1" set="method">
			<f a="position:text">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertAdjacentHTML>
		<querySelector public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelector>
		<querySelectorAll public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelectorAll>
		<createShadowRoot public="1" set="method">
			<f a=""><c path="js.html.ShadowRoot"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createShadowRoot>
		<getDestinationInsertionPoints public="1" set="method"><f a=""><c path="js.html.NodeList"/></f></getDestinationInsertionPoints>
		<getAnimationPlayers public="1" set="method"><f a=""><c path="Array"><c path="js.html.AnimationPlayer"/></c></f></getAnimationPlayers>
		<remove public="1" set="method"><f a=""><x path="Void"/></f></remove>
		<convertQuadFromNode public="1" set="method">
			<f a="quad:from:?options">
				<c path="js.html.DOMQuad"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertQuadFromNode>
		<convertRectFromNode public="1" set="method">
			<f a="rect:from:?options">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertRectFromNode>
		<convertPointFromNode public="1" set="method">
			<f a="point:from:?options">
				<t path="js.html.DOMPointInit"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMPoint"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertPointFromNode>
		<meta><m n=":native"><e>"Element"</e></m></meta>
	</class>
	<class path="js.html.Element" params="" file="/usr/lib/haxe/std/js/html/Element.hx" extern="1">
		<extends path="js.html.DOMElement"/>
		<meta><m n=":native"><e>"HTMLElement"</e></m></meta>
	</class>
	<class path="js.html.AnchorElement" params="" file="/usr/lib/haxe/std/js/html/AnchorElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<target public="1"><c path="String"/></target>
		<download public="1"><c path="String"/></download>
		<ping public="1"><c path="String"/></ping>
		<rel public="1"><c path="String"/></rel>
		<relList public="1" set="null"><c path="js.html.DOMTokenList"/></relList>
		<hreflang public="1"><c path="String"/></hreflang>
		<type public="1"><c path="String"/></type>
		<text public="1"><c path="String"/></text>
		<coords public="1"><c path="String"/></coords>
		<charset public="1"><c path="String"/></charset>
		<name public="1"><c path="String"/></name>
		<rev public="1"><c path="String"/></rev>
		<shape public="1"><c path="String"/></shape>
		<href public="1"><c path="String"/></href>
		<origin public="1" set="null"><c path="String"/></origin>
		<protocol public="1"><c path="String"/></protocol>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<hostname public="1"><c path="String"/></hostname>
		<port public="1"><c path="String"/></port>
		<pathname public="1"><c path="String"/></pathname>
		<search public="1"><c path="String"/></search>
		<hash public="1"><c path="String"/></hash>
		<searchParams public="1"><c path="js.html.URLSearchParams"/></searchParams>
		<meta><m n=":native"><e>"HTMLAnchorElement"</e></m></meta>
	</class>
	<class path="js.html.Animation" params="" file="/usr/lib/haxe/std/js/html/Animation.hx" extern="1">
		<effect public="1" set="null"><c path="js.html.AnimationEffect"/></effect>
		<target public="1" set="null"><c path="js.html.Element"/></target>
		<meta><m n=":native"><e>"Animation"</e></m></meta>
	</class>
	<class path="js.html.AnimationEffect" params="" file="/usr/lib/haxe/std/js/html/AnimationEffect.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<meta><m n=":native"><e>"AnimationEffect"</e></m></meta>
	</class>
	<abstract path="js.html.AnimationPlayState" params="" file="/usr/lib/haxe/std/js/html/AnimationPlayState.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._AnimationPlayState.AnimationPlayState_Impl_" params="" file="/usr/lib/haxe/std/js/html/AnimationPlayState.hx" private="1" module="js.html.AnimationPlayState"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.AnimationPlayer" params="" file="/usr/lib/haxe/std/js/html/AnimationPlayer.hx" extern="1">
		<source public="1" set="null"><c path="js.html.Animation"/></source>
		<timeline public="1" set="null"><c path="js.html.AnimationTimeline"/></timeline>
		<startTime public="1" set="null"><x path="Float"/></startTime>
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<playState public="1" set="null"><x path="js.html.AnimationPlayState"/></playState>
		<play public="1" set="method"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<meta><m n=":native"><e>"AnimationPlayer"</e></m></meta>
	</class>
	<class path="js.html.AnimationTimeline" params="" file="/usr/lib/haxe/std/js/html/AnimationTimeline.hx" extern="1">
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<meta><m n=":native"><e>"AnimationTimeline"</e></m></meta>
	</class>
	<class path="js.html.AppletElement" params="" file="/usr/lib/haxe/std/js/html/AppletElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<alt public="1"><c path="String"/></alt>
		<archive public="1"><c path="String"/></archive>
		<code public="1"><c path="String"/></code>
		<codeBase public="1"><c path="String"/></codeBase>
		<height public="1"><c path="String"/></height>
		<hspace public="1"><x path="Int"/></hspace>
		<name public="1"><c path="String"/></name>
		<object public="1"><c path="String"/></object>
		<vspace public="1"><x path="Int"/></vspace>
		<width public="1"><c path="String"/></width>
		<meta><m n=":native"><e>"HTMLAppletElement"</e></m></meta>
	</class>
	<class path="js.html.ApplicationCache" params="" file="/usr/lib/haxe/std/js/html/ApplicationCache.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<UNCACHED public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UNCACHED>
		<IDLE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</IDLE>
		<CHECKING public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CHECKING>
		<DOWNLOADING public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</DOWNLOADING>
		<UPDATEREADY public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</UPDATEREADY>
		<OBSOLETE public="1" get="inline" set="null" expr="5" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</OBSOLETE>
		<status public="1" set="null"><x path="Int"/></status>
		<onchecking public="1"><x path="haxe.Function"/></onchecking>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onnoupdate public="1"><x path="haxe.Function"/></onnoupdate>
		<ondownloading public="1"><x path="haxe.Function"/></ondownloading>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onupdateready public="1"><x path="haxe.Function"/></onupdateready>
		<oncached public="1"><x path="haxe.Function"/></oncached>
		<onobsolete public="1"><x path="haxe.Function"/></onobsolete>
		<update public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</update>
		<swapCache public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</swapCache>
		<meta><m n=":native"><e>"ApplicationCache"</e></m></meta>
	</class>
	<class path="js.html.AreaElement" params="" file="/usr/lib/haxe/std/js/html/AreaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<alt public="1"><c path="String"/></alt>
		<coords public="1"><c path="String"/></coords>
		<shape public="1"><c path="String"/></shape>
		<target public="1"><c path="String"/></target>
		<download public="1"><c path="String"/></download>
		<ping public="1"><c path="String"/></ping>
		<rel public="1"><c path="String"/></rel>
		<relList public="1" set="null"><c path="js.html.DOMTokenList"/></relList>
		<noHref public="1"><x path="Bool"/></noHref>
		<href public="1"><c path="String"/></href>
		<origin public="1" set="null"><c path="String"/></origin>
		<protocol public="1"><c path="String"/></protocol>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<hostname public="1"><c path="String"/></hostname>
		<port public="1"><c path="String"/></port>
		<pathname public="1"><c path="String"/></pathname>
		<search public="1"><c path="String"/></search>
		<hash public="1"><c path="String"/></hash>
		<searchParams public="1"><c path="js.html.URLSearchParams"/></searchParams>
		<meta><m n=":native"><e>"HTMLAreaElement"</e></m></meta>
	</class>
	<class path="js.html.ArrayBuffer" params="" file="/usr/lib/haxe/std/js/html/ArrayBuffer.hx" extern="1">
		<isView public="1" set="method" static="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></isView>
		<byteLength public="1" set="null"><x path="Int"/></byteLength>
		<slice public="1" set="method"><f a="begin:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBuffer"/>
</f></slice>
		<new public="1" set="method">
			<f a="length">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"ArrayBuffer"</e></m>
		</meta>
	</class>
	<class path="js.html.ArrayBufferView" params="" file="/usr/lib/haxe/std/js/html/ArrayBufferView.hx" extern="1">
		<buffer public="1" set="null"><c path="js.html.ArrayBuffer"/></buffer>
		<byteOffset public="1" set="null"><x path="Int"/></byteOffset>
		<byteLength public="1" set="null"><x path="Int"/></byteLength>
		<meta><m n=":native"><e>"ArrayBufferView"</e></m></meta>
	</class>
	<class path="js.html.Attr" params="" file="/usr/lib/haxe/std/js/html/Attr.hx" extern="1">
		<extends path="js.html.Node"/>
		<value public="1"><c path="String"/></value>
		<name public="1" set="null"><c path="String"/></name>
		<specified public="1" set="null"><x path="Bool"/></specified>
		<ownerElement public="1" set="null"><c path="js.html.Element"/></ownerElement>
		<meta><m n=":native"><e>"Attr"</e></m></meta>
	</class>
	<abstract path="js.html.AudioChannel" params="" file="/usr/lib/haxe/std/js/html/AudioChannel.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._AudioChannel.AudioChannel_Impl_" params="" file="/usr/lib/haxe/std/js/html/AudioChannel.hx" private="1" module="js.html.AudioChannel"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.MediaElement" params="" file="/usr/lib/haxe/std/js/html/MediaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<NETWORK_EMPTY public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NETWORK_EMPTY>
		<NETWORK_IDLE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</NETWORK_IDLE>
		<NETWORK_LOADING public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</NETWORK_LOADING>
		<NETWORK_NO_SOURCE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</NETWORK_NO_SOURCE>
		<HAVE_NOTHING public="1" get="inline" set="null" expr="0" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</HAVE_NOTHING>
		<HAVE_METADATA public="1" get="inline" set="null" expr="1" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</HAVE_METADATA>
		<HAVE_CURRENT_DATA public="1" get="inline" set="null" expr="2" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</HAVE_CURRENT_DATA>
		<HAVE_FUTURE_DATA public="1" get="inline" set="null" expr="3" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</HAVE_FUTURE_DATA>
		<HAVE_ENOUGH_DATA public="1" get="inline" set="null" expr="4" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</HAVE_ENOUGH_DATA>
		<error public="1" set="null"><c path="js.html.MediaError"/></error>
		<src public="1"><c path="String"/></src>
		<currentSrc public="1" set="null"><c path="String"/></currentSrc>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<networkState public="1" set="null"><x path="Int"/></networkState>
		<preload public="1"><c path="String"/></preload>
		<buffered public="1" set="null"><c path="js.html.TimeRanges"/></buffered>
		<readyState public="1" set="null"><x path="Int"/></readyState>
		<seeking public="1" set="null"><x path="Bool"/></seeking>
		<currentTime public="1"><x path="Float"/></currentTime>
		<duration public="1" set="null"><x path="Float"/></duration>
		<paused public="1" set="null"><x path="Bool"/></paused>
		<defaultPlaybackRate public="1"><x path="Float"/></defaultPlaybackRate>
		<playbackRate public="1"><x path="Float"/></playbackRate>
		<played public="1" set="null"><c path="js.html.TimeRanges"/></played>
		<seekable public="1" set="null"><c path="js.html.TimeRanges"/></seekable>
		<ended public="1" set="null"><x path="Bool"/></ended>
		<autoplay public="1"><x path="Bool"/></autoplay>
		<loop public="1"><x path="Bool"/></loop>
		<controls public="1"><x path="Bool"/></controls>
		<volume public="1"><x path="Float"/></volume>
		<muted public="1"><x path="Bool"/></muted>
		<defaultMuted public="1"><x path="Bool"/></defaultMuted>
		<audioTracks public="1" set="null"><c path="js.html.AudioTrackList"/></audioTracks>
		<videoTracks public="1" set="null"><c path="js.html.VideoTrackList"/></videoTracks>
		<textTracks public="1" set="null"><c path="js.html.TextTrackList"/></textTracks>
		<mediaKeys public="1" set="null"><c path="js.html.MediaKeys"/></mediaKeys>
		<onencrypted public="1"><x path="haxe.Function"/></onencrypted>
		<waitingFor public="1" set="null"><x path="js.html.MediaWaitingFor"/></waitingFor>
		<load public="1" set="method"><f a=""><x path="Void"/></f></load>
		<canPlayType public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="String"/>
</f></canPlayType>
		<fastSeek public="1" set="method">
			<f a="time">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</fastSeek>
		<play public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</play>
		<pause public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</pause>
		<addTextTrack public="1" set="method">
			<f a="kind:?label:?language" v=":&quot;&quot;:&quot;&quot;">
				<x path="js.html.TextTrackKind"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.TextTrack"/>
			</f>
			<meta><m n=":value"><e>{language:"",label:""}</e></m></meta>
		</addTextTrack>
		<setMediaKeys public="1" set="method"><f a="mediaKeys">
	<c path="js.html.MediaKeys"/>
	<c path="js.Promise"><x path="Void"/></c>
</f></setMediaKeys>
		<meta><m n=":native"><e>"HTMLMediaElement"</e></m></meta>
	</class>
	<class path="js.html.AudioElement" params="" file="/usr/lib/haxe/std/js/html/AudioElement.hx" extern="1">
		<extends path="js.html.MediaElement"/>
		<meta><m n=":native"><e>"HTMLAudioElement"</e></m></meta>
	</class>
	<class path="js.html.MediaStreamTrack" params="" file="/usr/lib/haxe/std/js/html/MediaStreamTrack.hx" extern="1">
		<kind public="1" set="null"><c path="String"/></kind>
		<id public="1" set="null"><c path="String"/></id>
		<label public="1" set="null"><c path="String"/></label>
		<enabled public="1"><x path="Bool"/></enabled>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<meta><m n=":native"><e>"MediaStreamTrack"</e></m></meta>
	</class>
	<class path="js.html.AudioStreamTrack" params="" file="/usr/lib/haxe/std/js/html/AudioStreamTrack.hx" extern="1">
		<extends path="js.html.MediaStreamTrack"/>
		<meta><m n=":native"><e>"AudioStreamTrack"</e></m></meta>
	</class>
	<class path="js.html.AudioTrack" params="" file="/usr/lib/haxe/std/js/html/AudioTrack.hx" extern="1">
		<id public="1" set="null"><c path="String"/></id>
		<kind public="1" set="null"><c path="String"/></kind>
		<label public="1" set="null"><c path="String"/></label>
		<language public="1" set="null"><c path="String"/></language>
		<enabled public="1"><x path="Bool"/></enabled>
		<meta><m n=":native"><e>"AudioTrack"</e></m></meta>
	</class>
	<class path="js.html.AudioTrackList" params="" file="/usr/lib/haxe/std/js/html/AudioTrackList.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<length public="1" set="null"><x path="Int"/></length>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onaddtrack public="1"><x path="haxe.Function"/></onaddtrack>
		<onremovetrack public="1"><x path="haxe.Function"/></onremovetrack>
		<getTrackById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.AudioTrack"/>
</f></getTrackById>
		<meta><m n=":native"><e>"AudioTrackList"</e></m></meta>
	</class>
	<class path="js.html.BRElement" params="" file="/usr/lib/haxe/std/js/html/BRElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<clear public="1"><c path="String"/></clear>
		<meta><m n=":native"><e>"HTMLBRElement"</e></m></meta>
	</class>
	<class path="js.html.BarProp" params="" file="/usr/lib/haxe/std/js/html/BarProp.hx" extern="1">
		<visible public="1"><x path="Bool"/></visible>
		<meta><m n=":native"><e>"BarProp"</e></m></meta>
	</class>
	<class path="js.html.BaseElement" params="" file="/usr/lib/haxe/std/js/html/BaseElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<href public="1"><c path="String"/></href>
		<target public="1"><c path="String"/></target>
		<meta><m n=":native"><e>"HTMLBaseElement"</e></m></meta>
	</class>
	<class path="js.html.BatteryManager" params="" file="/usr/lib/haxe/std/js/html/BatteryManager.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<charging public="1" set="null"><x path="Bool"/></charging>
		<chargingTime public="1" set="null"><x path="Float"/></chargingTime>
		<dischargingTime public="1" set="null"><x path="Float"/></dischargingTime>
		<level public="1" set="null"><x path="Float"/></level>
		<onchargingchange public="1"><x path="haxe.Function"/></onchargingchange>
		<onchargingtimechange public="1"><x path="haxe.Function"/></onchargingtimechange>
		<ondischargingtimechange public="1"><x path="haxe.Function"/></ondischargingtimechange>
		<onlevelchange public="1"><x path="haxe.Function"/></onlevelchange>
		<meta><m n=":native"><e>"BatteryManager"</e></m></meta>
	</class>
	<class path="js.html.Blob" params="" file="/usr/lib/haxe/std/js/html/Blob.hx" extern="1">
		<size public="1" set="null"><x path="Int"/></size>
		<type public="1" set="null"><c path="String"/></type>
		<slice public="1" set="method">
			<f a="?start:?end:?contentType" v="::&quot;&quot;">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="js.html.Blob"/>
			</f>
			<meta><m n=":value"><e>{contentType:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</slice>
		<new public="1" set="method">
			<f a="blobParts:?options">
				<c path="Array"><x path="haxe.extern.EitherType">
	<c path="js.html.ArrayBuffer"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<x path="haxe.extern.EitherType">
			<c path="js.html.Blob"/>
			<c path="String"/>
		</x>
	</x>
</x></c>
				<t path="js.html.BlobPropertyBag"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"Blob"</e></m></meta>
	</class>
	<typedef path="js.html.BlobPropertyBag" params="" file="/usr/lib/haxe/std/js/html/BlobPropertyBag.hx"><a>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<endings>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</endings>
</a></typedef>
	<class path="js.html.BodyElement" params="" file="/usr/lib/haxe/std/js/html/BodyElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<text public="1"><c path="String"/></text>
		<link public="1"><c path="String"/></link>
		<vLink public="1"><c path="String"/></vLink>
		<aLink public="1"><c path="String"/></aLink>
		<bgColor public="1"><c path="String"/></bgColor>
		<background public="1"><c path="String"/></background>
		<onafterprint public="1"><x path="haxe.Function"/></onafterprint>
		<onbeforeprint public="1"><x path="haxe.Function"/></onbeforeprint>
		<onbeforeunload public="1"><f a="">
	<c path="js.html.Event"/>
	<c path="String"/>
</f></onbeforeunload>
		<onhashchange public="1"><x path="haxe.Function"/></onhashchange>
		<onlanguagechange public="1"><x path="haxe.Function"/></onlanguagechange>
		<onmessage public="1"><x path="haxe.Function"/></onmessage>
		<onoffline public="1"><x path="haxe.Function"/></onoffline>
		<ononline public="1"><x path="haxe.Function"/></ononline>
		<onpagehide public="1"><x path="haxe.Function"/></onpagehide>
		<onpageshow public="1"><x path="haxe.Function"/></onpageshow>
		<onpopstate public="1"><x path="haxe.Function"/></onpopstate>
		<onresize public="1"><x path="haxe.Function"/></onresize>
		<onunload public="1"><x path="haxe.Function"/></onunload>
		<meta><m n=":native"><e>"HTMLBodyElement"</e></m></meta>
	</class>
	<class path="js.html.ButtonElement" params="" file="/usr/lib/haxe/std/js/html/ButtonElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<formAction public="1"><c path="String"/></formAction>
		<formEnctype public="1"><c path="String"/></formEnctype>
		<formMethod public="1"><c path="String"/></formMethod>
		<formNoValidate public="1"><x path="Bool"/></formNoValidate>
		<formTarget public="1"><c path="String"/></formTarget>
		<name public="1"><c path="String"/></name>
		<type public="1"><c path="String"/></type>
		<value public="1"><c path="String"/></value>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLButtonElement"</e></m></meta>
	</class>
	<class path="js.html.CharacterData" params="" file="/usr/lib/haxe/std/js/html/CharacterData.hx" extern="1">
		<extends path="js.html.Node"/>
		<data public="1"><c path="String"/></data>
		<length public="1" set="null"><x path="Int"/></length>
		<previousElementSibling public="1" set="null"><c path="js.html.Element"/></previousElementSibling>
		<nextElementSibling public="1" set="null"><c path="js.html.Element"/></nextElementSibling>
		<substringData public="1" set="method">
			<f a="offset:count">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</substringData>
		<appendData public="1" set="method">
			<f a="data">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</appendData>
		<insertData public="1" set="method">
			<f a="offset:data">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertData>
		<deleteData public="1" set="method">
			<f a="offset:count">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteData>
		<replaceData public="1" set="method">
			<f a="offset:count:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replaceData>
		<remove public="1" set="method"><f a=""><x path="Void"/></f></remove>
		<meta><m n=":native"><e>"CharacterData"</e></m></meta>
	</class>
	<class path="js.html.Text" params="" file="/usr/lib/haxe/std/js/html/Text.hx" extern="1">
		<extends path="js.html.CharacterData"/>
		<wholeText public="1" set="null"><c path="String"/></wholeText>
		<splitText public="1" set="method">
			<f a="offset">
				<x path="Int"/>
				<c path="js.html.Text"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</splitText>
		<convertQuadFromNode public="1" set="method">
			<f a="quad:from:?options">
				<c path="js.html.DOMQuad"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertQuadFromNode>
		<convertRectFromNode public="1" set="method">
			<f a="rect:from:?options">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertRectFromNode>
		<convertPointFromNode public="1" set="method">
			<f a="point:from:?options">
				<t path="js.html.DOMPointInit"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMPoint"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertPointFromNode>
		<new public="1" set="method">
			<f a="?data" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{data:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Text"</e></m></meta>
	</class>
	<class path="js.html.CDATASection" params="" file="/usr/lib/haxe/std/js/html/CDATASection.hx" extern="1">
		<extends path="js.html.Text"/>
		<meta><m n=":native"><e>"CDATASection"</e></m></meta>
	</class>
	<class path="js.html.CSSRule" params="" file="/usr/lib/haxe/std/js/html/CSSRule.hx" extern="1">
		<UNKNOWN_RULE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UNKNOWN_RULE>
		<STYLE_RULE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</STYLE_RULE>
		<CHARSET_RULE public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CHARSET_RULE>
		<IMPORT_RULE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</IMPORT_RULE>
		<MEDIA_RULE public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</MEDIA_RULE>
		<FONT_FACE_RULE public="1" get="inline" set="null" expr="5" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</FONT_FACE_RULE>
		<PAGE_RULE public="1" get="inline" set="null" expr="6" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</PAGE_RULE>
		<type public="1" set="null"><x path="Int"/></type>
		<cssText public="1"><c path="String"/></cssText>
		<parentStyleSheet public="1" set="null"><c path="js.html.CSSStyleSheet"/></parentStyleSheet>
		<parentRule public="1" set="null"><c path="js.html.CSSRule"/></parentRule>
		<meta><m n=":native"><e>"CSSRule"</e></m></meta>
	</class>
	<class path="js.html.CSSRuleList" params="" file="/usr/lib/haxe/std/js/html/CSSRuleList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.CSSRule"/>
</f></item>
		<meta><m n=":native"><e>"CSSRuleList"</e></m></meta>
	</class>
	<class path="js.html.CSSStyleDeclaration" params="" file="/usr/lib/haxe/std/js/html/CSSStyleDeclaration.hx" extern="1">
		<cssText public="1"><c path="String"/></cssText>
		<length public="1" set="null"><x path="Int"/></length>
		<parentRule public="1" set="null"><c path="js.html.CSSRule"/></parentRule>
		<alignContent public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "align-content" CSS property.</haxe_doc>
		</alignContent>
		<alignItems public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "align-items" CSS property.</haxe_doc>
		</alignItems>
		<alignSelf public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "align-self" CSS property.</haxe_doc>
		</alignSelf>
		<alignmentAdjust public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "alignment-adjust" CSS property.</haxe_doc>
		</alignmentAdjust>
		<alignmentBaseline public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "alignment-baseline" CSS property.</haxe_doc>
		</alignmentBaseline>
		<all public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "all" CSS property.</haxe_doc>
		</all>
		<anchorPoint public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "anchor-point" CSS property.</haxe_doc>
		</anchorPoint>
		<animation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation" CSS property.</haxe_doc>
		</animation>
		<animationDelay public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-delay" CSS property.</haxe_doc>
		</animationDelay>
		<animationDirection public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-direction" CSS property.</haxe_doc>
		</animationDirection>
		<animationDuration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-duration" CSS property.</haxe_doc>
		</animationDuration>
		<animationFillMode public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-fill-mode" CSS property.</haxe_doc>
		</animationFillMode>
		<animationIterationCount public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-iteration-count" CSS property.</haxe_doc>
		</animationIterationCount>
		<animationName public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-name" CSS property.</haxe_doc>
		</animationName>
		<animationPlayState public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-play-state" CSS property.</haxe_doc>
		</animationPlayState>
		<animationTimingFunction public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-timing-function" CSS property.</haxe_doc>
		</animationTimingFunction>
		<azimuth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "azimuth" CSS property.</haxe_doc>
		</azimuth>
		<backfaceVisibility public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "backface-visibility" CSS property.</haxe_doc>
		</backfaceVisibility>
		<background public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background" CSS property.</haxe_doc>
		</background>
		<backgroundAttachment public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-attachment" CSS property.</haxe_doc>
		</backgroundAttachment>
		<backgroundClip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-clip" CSS property.</haxe_doc>
		</backgroundClip>
		<backgroundColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-color" CSS property.</haxe_doc>
		</backgroundColor>
		<backgroundImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-image" CSS property.</haxe_doc>
		</backgroundImage>
		<backgroundOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-origin" CSS property.</haxe_doc>
		</backgroundOrigin>
		<backgroundPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-position" CSS property.</haxe_doc>
		</backgroundPosition>
		<backgroundRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-repeat" CSS property.</haxe_doc>
		</backgroundRepeat>
		<backgroundSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-size" CSS property.</haxe_doc>
		</backgroundSize>
		<baselineShift public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "baseline-shift" CSS property.</haxe_doc>
		</baselineShift>
		<binding public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "binding" CSS property.</haxe_doc>
		</binding>
		<bleed public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bleed" CSS property.</haxe_doc>
		</bleed>
		<bookmarkLabel public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bookmark-label" CSS property.</haxe_doc>
		</bookmarkLabel>
		<bookmarkLevel public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bookmark-level" CSS property.</haxe_doc>
		</bookmarkLevel>
		<bookmarkState public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bookmark-state" CSS property.</haxe_doc>
		</bookmarkState>
		<border public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border" CSS property.</haxe_doc>
		</border>
		<borderBottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom" CSS property.</haxe_doc>
		</borderBottom>
		<borderBottomColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-color" CSS property.</haxe_doc>
		</borderBottomColor>
		<borderBottomLeftRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-left-radius" CSS property.</haxe_doc>
		</borderBottomLeftRadius>
		<borderBottomRightRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-right-radius" CSS property.</haxe_doc>
		</borderBottomRightRadius>
		<borderBottomStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-style" CSS property.</haxe_doc>
		</borderBottomStyle>
		<borderBottomWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-width" CSS property.</haxe_doc>
		</borderBottomWidth>
		<borderCollapse public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-collapse" CSS property.</haxe_doc>
		</borderCollapse>
		<borderColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-color" CSS property.</haxe_doc>
		</borderColor>
		<borderImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image" CSS property.</haxe_doc>
		</borderImage>
		<borderImageOutset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-outset" CSS property.</haxe_doc>
		</borderImageOutset>
		<borderImageRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-repeat" CSS property.</haxe_doc>
		</borderImageRepeat>
		<borderImageSlice public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-slice" CSS property.</haxe_doc>
		</borderImageSlice>
		<borderImageSource public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-source" CSS property.</haxe_doc>
		</borderImageSource>
		<borderImageWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-width" CSS property.</haxe_doc>
		</borderImageWidth>
		<borderLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left" CSS property.</haxe_doc>
		</borderLeft>
		<borderLeftColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left-color" CSS property.</haxe_doc>
		</borderLeftColor>
		<borderLeftStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left-style" CSS property.</haxe_doc>
		</borderLeftStyle>
		<borderLeftWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left-width" CSS property.</haxe_doc>
		</borderLeftWidth>
		<borderRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-radius" CSS property.</haxe_doc>
		</borderRadius>
		<borderRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right" CSS property.</haxe_doc>
		</borderRight>
		<borderRightColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right-color" CSS property.</haxe_doc>
		</borderRightColor>
		<borderRightStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right-style" CSS property.</haxe_doc>
		</borderRightStyle>
		<borderRightWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right-width" CSS property.</haxe_doc>
		</borderRightWidth>
		<borderSpacing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-spacing" CSS property.</haxe_doc>
		</borderSpacing>
		<borderStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-style" CSS property.</haxe_doc>
		</borderStyle>
		<borderTop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top" CSS property.</haxe_doc>
		</borderTop>
		<borderTopColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-color" CSS property.</haxe_doc>
		</borderTopColor>
		<borderTopLeftRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-left-radius" CSS property.</haxe_doc>
		</borderTopLeftRadius>
		<borderTopRightRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-right-radius" CSS property.</haxe_doc>
		</borderTopRightRadius>
		<borderTopStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-style" CSS property.</haxe_doc>
		</borderTopStyle>
		<borderTopWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-width" CSS property.</haxe_doc>
		</borderTopWidth>
		<borderWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-width" CSS property.</haxe_doc>
		</borderWidth>
		<bottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bottom" CSS property.</haxe_doc>
		</bottom>
		<boxDecorationBreak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-decoration-break" CSS property.</haxe_doc>
		</boxDecorationBreak>
		<boxShadow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-shadow" CSS property.</haxe_doc>
		</boxShadow>
		<boxSizing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-sizing" CSS property.</haxe_doc>
		</boxSizing>
		<boxSnap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-snap" CSS property.</haxe_doc>
		</boxSnap>
		<boxSuppress public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-suppress" CSS property.</haxe_doc>
		</boxSuppress>
		<breakAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "break-after" CSS property.</haxe_doc>
		</breakAfter>
		<breakBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "break-before" CSS property.</haxe_doc>
		</breakBefore>
		<breakInside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "break-inside" CSS property.</haxe_doc>
		</breakInside>
		<captionSide public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "caption-side" CSS property.</haxe_doc>
		</captionSide>
		<chains public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "chains" CSS property.</haxe_doc>
		</chains>
		<clear public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clear" CSS property.</haxe_doc>
		</clear>
		<clip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clip" CSS property.</haxe_doc>
		</clip>
		<clipPath public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clip-path" CSS property.</haxe_doc>
		</clipPath>
		<clipRule public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clip-rule" CSS property.</haxe_doc>
		</clipRule>
		<color public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "color" CSS property.</haxe_doc>
		</color>
		<colorInterpolationFilters public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "color-interpolation-filters" CSS property.</haxe_doc>
		</colorInterpolationFilters>
		<columnCount public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-count" CSS property.</haxe_doc>
		</columnCount>
		<columnFill public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-fill" CSS property.</haxe_doc>
		</columnFill>
		<columnGap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-gap" CSS property.</haxe_doc>
		</columnGap>
		<columnRule public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule" CSS property.</haxe_doc>
		</columnRule>
		<columnRuleColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule-color" CSS property.</haxe_doc>
		</columnRuleColor>
		<columnRuleStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule-style" CSS property.</haxe_doc>
		</columnRuleStyle>
		<columnRuleWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule-width" CSS property.</haxe_doc>
		</columnRuleWidth>
		<columnSpan public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-span" CSS property.</haxe_doc>
		</columnSpan>
		<columnWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-width" CSS property.</haxe_doc>
		</columnWidth>
		<columns public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "columns" CSS property.</haxe_doc>
		</columns>
		<contain public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "contain" CSS property.</haxe_doc>
		</contain>
		<content public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "content" CSS property.</haxe_doc>
		</content>
		<counterIncrement public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "counter-increment" CSS property.</haxe_doc>
		</counterIncrement>
		<counterReset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "counter-reset" CSS property.</haxe_doc>
		</counterReset>
		<counterSet public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "counter-set" CSS property.</haxe_doc>
		</counterSet>
		<crop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "crop" CSS property.</haxe_doc>
		</crop>
		<cue public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cue" CSS property.</haxe_doc>
		</cue>
		<cueAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cue-after" CSS property.</haxe_doc>
		</cueAfter>
		<cueBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cue-before" CSS property.</haxe_doc>
		</cueBefore>
		<cursor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cursor" CSS property.</haxe_doc>
		</cursor>
		<direction public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "direction" CSS property.</haxe_doc>
		</direction>
		<display public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display" CSS property.</haxe_doc>
		</display>
		<displayInside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display-inside" CSS property.</haxe_doc>
		</displayInside>
		<displayList public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display-list" CSS property.</haxe_doc>
		</displayList>
		<displayOutside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display-outside" CSS property.</haxe_doc>
		</displayOutside>
		<dominantBaseline public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "dominant-baseline" CSS property.</haxe_doc>
		</dominantBaseline>
		<elevation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "elevation" CSS property.</haxe_doc>
		</elevation>
		<emptyCells public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "empty-cells" CSS property.</haxe_doc>
		</emptyCells>
		<filter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "filter" CSS property.</haxe_doc>
		</filter>
		<flex public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex" CSS property.</haxe_doc>
		</flex>
		<flexBasis public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-basis" CSS property.</haxe_doc>
		</flexBasis>
		<flexDirection public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-direction" CSS property.</haxe_doc>
		</flexDirection>
		<flexFlow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-flow" CSS property.</haxe_doc>
		</flexFlow>
		<flexGrow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-grow" CSS property.</haxe_doc>
		</flexGrow>
		<flexShrink public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-shrink" CSS property.</haxe_doc>
		</flexShrink>
		<flexWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-wrap" CSS property.</haxe_doc>
		</flexWrap>
		<float public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "float" CSS property.</haxe_doc>
		</float>
		<floatOffset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "float-offset" CSS property.</haxe_doc>
		</floatOffset>
		<floodColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flood-color" CSS property.</haxe_doc>
		</floodColor>
		<floodOpacity public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flood-opacity" CSS property.</haxe_doc>
		</floodOpacity>
		<flowFrom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flow-from" CSS property.</haxe_doc>
		</flowFrom>
		<flowInto public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flow-into" CSS property.</haxe_doc>
		</flowInto>
		<font public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font" CSS property.</haxe_doc>
		</font>
		<fontFamily public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-family" CSS property.</haxe_doc>
		</fontFamily>
		<fontFeatureSettings public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-feature-settings" CSS property.</haxe_doc>
		</fontFeatureSettings>
		<fontKerning public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-kerning" CSS property.</haxe_doc>
		</fontKerning>
		<fontLanguageOverride public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-language-override" CSS property.</haxe_doc>
		</fontLanguageOverride>
		<fontSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-size" CSS property.</haxe_doc>
		</fontSize>
		<fontSizeAdjust public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-size-adjust" CSS property.</haxe_doc>
		</fontSizeAdjust>
		<fontStretch public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-stretch" CSS property.</haxe_doc>
		</fontStretch>
		<fontStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-style" CSS property.</haxe_doc>
		</fontStyle>
		<fontSynthesis public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-synthesis" CSS property.</haxe_doc>
		</fontSynthesis>
		<fontVariant public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant" CSS property.</haxe_doc>
		</fontVariant>
		<fontVariantAlternates public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-alternates" CSS property.</haxe_doc>
		</fontVariantAlternates>
		<fontVariantCaps public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-caps" CSS property.</haxe_doc>
		</fontVariantCaps>
		<fontVariantEastAsian public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-east-asian" CSS property.</haxe_doc>
		</fontVariantEastAsian>
		<fontVariantLigatures public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-ligatures" CSS property.</haxe_doc>
		</fontVariantLigatures>
		<fontVariantNumeric public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-numeric" CSS property.</haxe_doc>
		</fontVariantNumeric>
		<fontVariantPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-position" CSS property.</haxe_doc>
		</fontVariantPosition>
		<fontWeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-weight" CSS property.</haxe_doc>
		</fontWeight>
		<grid public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid" CSS property.</haxe_doc>
		</grid>
		<gridArea public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-area" CSS property.</haxe_doc>
		</gridArea>
		<gridAutoColumns public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-auto-columns" CSS property.</haxe_doc>
		</gridAutoColumns>
		<gridAutoFlow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-auto-flow" CSS property.</haxe_doc>
		</gridAutoFlow>
		<gridAutoRows public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-auto-rows" CSS property.</haxe_doc>
		</gridAutoRows>
		<gridColumn public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-column" CSS property.</haxe_doc>
		</gridColumn>
		<gridColumnEnd public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-column-end" CSS property.</haxe_doc>
		</gridColumnEnd>
		<gridColumnStart public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-column-start" CSS property.</haxe_doc>
		</gridColumnStart>
		<gridRow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-row" CSS property.</haxe_doc>
		</gridRow>
		<gridRowEnd public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-row-end" CSS property.</haxe_doc>
		</gridRowEnd>
		<gridRowStart public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-row-start" CSS property.</haxe_doc>
		</gridRowStart>
		<gridTemplate public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template" CSS property.</haxe_doc>
		</gridTemplate>
		<gridTemplateAreas public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template-areas" CSS property.</haxe_doc>
		</gridTemplateAreas>
		<gridTemplateColumns public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template-columns" CSS property.</haxe_doc>
		</gridTemplateColumns>
		<gridTemplateRows public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template-rows" CSS property.</haxe_doc>
		</gridTemplateRows>
		<hangingPunctuation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "hanging-punctuation" CSS property.</haxe_doc>
		</hangingPunctuation>
		<height public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "height" CSS property.</haxe_doc>
		</height>
		<hyphens public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "hyphens" CSS property.</haxe_doc>
		</hyphens>
		<icon public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "icon" CSS property.</haxe_doc>
		</icon>
		<imageOrientation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "image-orientation" CSS property.</haxe_doc>
		</imageOrientation>
		<imageResolution public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "image-resolution" CSS property.</haxe_doc>
		</imageResolution>
		<imeMode public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ime-mode" CSS property.</haxe_doc>
		</imeMode>
		<initialLetters public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "initial-letters" CSS property.</haxe_doc>
		</initialLetters>
		<inlineBoxAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "inline-box-align" CSS property.</haxe_doc>
		</inlineBoxAlign>
		<justifyContent public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "justify-content" CSS property.</haxe_doc>
		</justifyContent>
		<justifyItems public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "justify-items" CSS property.</haxe_doc>
		</justifyItems>
		<justifySelf public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "justify-self" CSS property.</haxe_doc>
		</justifySelf>
		<left public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "left" CSS property.</haxe_doc>
		</left>
		<letterSpacing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "letter-spacing" CSS property.</haxe_doc>
		</letterSpacing>
		<lightingColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "lighting-color" CSS property.</haxe_doc>
		</lightingColor>
		<lineBoxContain public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-box-contain" CSS property.</haxe_doc>
		</lineBoxContain>
		<lineBreak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-break" CSS property.</haxe_doc>
		</lineBreak>
		<lineGrid public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-grid" CSS property.</haxe_doc>
		</lineGrid>
		<lineHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-height" CSS property.</haxe_doc>
		</lineHeight>
		<lineSnap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-snap" CSS property.</haxe_doc>
		</lineSnap>
		<lineStacking public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking" CSS property.</haxe_doc>
		</lineStacking>
		<lineStackingRuby public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking-ruby" CSS property.</haxe_doc>
		</lineStackingRuby>
		<lineStackingShift public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking-shift" CSS property.</haxe_doc>
		</lineStackingShift>
		<lineStackingStrategy public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking-strategy" CSS property.</haxe_doc>
		</lineStackingStrategy>
		<listStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style" CSS property.</haxe_doc>
		</listStyle>
		<listStyleImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style-image" CSS property.</haxe_doc>
		</listStyleImage>
		<listStylePosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style-position" CSS property.</haxe_doc>
		</listStylePosition>
		<listStyleType public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style-type" CSS property.</haxe_doc>
		</listStyleType>
		<margin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin" CSS property.</haxe_doc>
		</margin>
		<marginBottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-bottom" CSS property.</haxe_doc>
		</marginBottom>
		<marginLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-left" CSS property.</haxe_doc>
		</marginLeft>
		<marginRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-right" CSS property.</haxe_doc>
		</marginRight>
		<marginTop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-top" CSS property.</haxe_doc>
		</marginTop>
		<markerOffset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "marker-offset" CSS property.</haxe_doc>
		</markerOffset>
		<markerSide public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "marker-side" CSS property.</haxe_doc>
		</markerSide>
		<marks public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "marks" CSS property.</haxe_doc>
		</marks>
		<mask public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask" CSS property.</haxe_doc>
		</mask>
		<maskBox public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box" CSS property.</haxe_doc>
		</maskBox>
		<maskBoxOutset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-outset" CSS property.</haxe_doc>
		</maskBoxOutset>
		<maskBoxRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-repeat" CSS property.</haxe_doc>
		</maskBoxRepeat>
		<maskBoxSlice public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-slice" CSS property.</haxe_doc>
		</maskBoxSlice>
		<maskBoxSource public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-source" CSS property.</haxe_doc>
		</maskBoxSource>
		<maskBoxWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-width" CSS property.</haxe_doc>
		</maskBoxWidth>
		<maskClip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-clip" CSS property.</haxe_doc>
		</maskClip>
		<maskImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-image" CSS property.</haxe_doc>
		</maskImage>
		<maskOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-origin" CSS property.</haxe_doc>
		</maskOrigin>
		<maskPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-position" CSS property.</haxe_doc>
		</maskPosition>
		<maskRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-repeat" CSS property.</haxe_doc>
		</maskRepeat>
		<maskSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-size" CSS property.</haxe_doc>
		</maskSize>
		<maskSourceType public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-source-type" CSS property.</haxe_doc>
		</maskSourceType>
		<maskType public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-type" CSS property.</haxe_doc>
		</maskType>
		<maxHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "max-height" CSS property.</haxe_doc>
		</maxHeight>
		<maxLines public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "max-lines" CSS property.</haxe_doc>
		</maxLines>
		<maxWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "max-width" CSS property.</haxe_doc>
		</maxWidth>
		<minHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "min-height" CSS property.</haxe_doc>
		</minHeight>
		<minWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "min-width" CSS property.</haxe_doc>
		</minWidth>
		<moveTo public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "move-to" CSS property.</haxe_doc>
		</moveTo>
		<navDown public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-down" CSS property.</haxe_doc>
		</navDown>
		<navIndex public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-index" CSS property.</haxe_doc>
		</navIndex>
		<navLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-left" CSS property.</haxe_doc>
		</navLeft>
		<navRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-right" CSS property.</haxe_doc>
		</navRight>
		<navUp public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-up" CSS property.</haxe_doc>
		</navUp>
		<objectFit public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "object-fit" CSS property.</haxe_doc>
		</objectFit>
		<objectPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "object-position" CSS property.</haxe_doc>
		</objectPosition>
		<opacity public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "opacity" CSS property.</haxe_doc>
		</opacity>
		<order public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "order" CSS property.</haxe_doc>
		</order>
		<orphans public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "orphans" CSS property.</haxe_doc>
		</orphans>
		<outline public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline" CSS property.</haxe_doc>
		</outline>
		<outlineColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-color" CSS property.</haxe_doc>
		</outlineColor>
		<outlineOffset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-offset" CSS property.</haxe_doc>
		</outlineOffset>
		<outlineStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-style" CSS property.</haxe_doc>
		</outlineStyle>
		<outlineWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-width" CSS property.</haxe_doc>
		</outlineWidth>
		<overflow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow" CSS property.</haxe_doc>
		</overflow>
		<overflowWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow-wrap" CSS property.</haxe_doc>
		</overflowWrap>
		<overflowX public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow-x" CSS property.</haxe_doc>
		</overflowX>
		<overflowY public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow-y" CSS property.</haxe_doc>
		</overflowY>
		<padding public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding" CSS property.</haxe_doc>
		</padding>
		<paddingBottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-bottom" CSS property.</haxe_doc>
		</paddingBottom>
		<paddingLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-left" CSS property.</haxe_doc>
		</paddingLeft>
		<paddingRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-right" CSS property.</haxe_doc>
		</paddingRight>
		<paddingTop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-top" CSS property.</haxe_doc>
		</paddingTop>
		<page public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page" CSS property.</haxe_doc>
		</page>
		<pageBreakAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-break-after" CSS property.</haxe_doc>
		</pageBreakAfter>
		<pageBreakBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-break-before" CSS property.</haxe_doc>
		</pageBreakBefore>
		<pageBreakInside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-break-inside" CSS property.</haxe_doc>
		</pageBreakInside>
		<pagePolicy public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-policy" CSS property.</haxe_doc>
		</pagePolicy>
		<pause public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pause" CSS property.</haxe_doc>
		</pause>
		<pauseAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pause-after" CSS property.</haxe_doc>
		</pauseAfter>
		<pauseBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pause-before" CSS property.</haxe_doc>
		</pauseBefore>
		<perspective public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "perspective" CSS property.</haxe_doc>
		</perspective>
		<perspectiveOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "perspective-origin" CSS property.</haxe_doc>
		</perspectiveOrigin>
		<pitch public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pitch" CSS property.</haxe_doc>
		</pitch>
		<pitchRange public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pitch-range" CSS property.</haxe_doc>
		</pitchRange>
		<playDuring public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "play-during" CSS property.</haxe_doc>
		</playDuring>
		<position public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "position" CSS property.</haxe_doc>
		</position>
		<presentationLevel public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "presentation-level" CSS property.</haxe_doc>
		</presentationLevel>
		<quotes public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "quotes" CSS property.</haxe_doc>
		</quotes>
		<regionFragment public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "region-fragment" CSS property.</haxe_doc>
		</regionFragment>
		<resize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "resize" CSS property.</haxe_doc>
		</resize>
		<rest public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rest" CSS property.</haxe_doc>
		</rest>
		<restAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rest-after" CSS property.</haxe_doc>
		</restAfter>
		<restBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rest-before" CSS property.</haxe_doc>
		</restBefore>
		<richness public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "richness" CSS property.</haxe_doc>
		</richness>
		<right public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "right" CSS property.</haxe_doc>
		</right>
		<rotation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rotation" CSS property.</haxe_doc>
		</rotation>
		<rotationPoint public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rotation-point" CSS property.</haxe_doc>
		</rotationPoint>
		<rubyAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ruby-align" CSS property.</haxe_doc>
		</rubyAlign>
		<rubyMerge public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ruby-merge" CSS property.</haxe_doc>
		</rubyMerge>
		<rubyPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ruby-position" CSS property.</haxe_doc>
		</rubyPosition>
		<shapeImageThreshold public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "shape-image-threshold" CSS property.</haxe_doc>
		</shapeImageThreshold>
		<shapeOutside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "shape-outside" CSS property.</haxe_doc>
		</shapeOutside>
		<shapeMargin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "shape-margin" CSS property.</haxe_doc>
		</shapeMargin>
		<size public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "size" CSS property.</haxe_doc>
		</size>
		<speak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak" CSS property.</haxe_doc>
		</speak>
		<speakAs public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-as" CSS property.</haxe_doc>
		</speakAs>
		<speakHeader public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-header" CSS property.</haxe_doc>
		</speakHeader>
		<speakNumeral public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-numeral" CSS property.</haxe_doc>
		</speakNumeral>
		<speakPunctuation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-punctuation" CSS property.</haxe_doc>
		</speakPunctuation>
		<speechRate public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speech-rate" CSS property.</haxe_doc>
		</speechRate>
		<stress public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "stress" CSS property.</haxe_doc>
		</stress>
		<stringSet public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "string-set" CSS property.</haxe_doc>
		</stringSet>
		<tabSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "tab-size" CSS property.</haxe_doc>
		</tabSize>
		<tableLayout public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "table-layout" CSS property.</haxe_doc>
		</tableLayout>
		<textAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-align" CSS property.</haxe_doc>
		</textAlign>
		<textAlignLast public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-align-last" CSS property.</haxe_doc>
		</textAlignLast>
		<textCombineUpright public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-combine-upright" CSS property.</haxe_doc>
		</textCombineUpright>
		<textDecoration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration" CSS property.</haxe_doc>
		</textDecoration>
		<textDecorationColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-color" CSS property.</haxe_doc>
		</textDecorationColor>
		<textDecorationLine public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-line" CSS property.</haxe_doc>
		</textDecorationLine>
		<textDecorationSkip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-skip" CSS property.</haxe_doc>
		</textDecorationSkip>
		<textDecorationStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-style" CSS property.</haxe_doc>
		</textDecorationStyle>
		<textEmphasis public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis" CSS property.</haxe_doc>
		</textEmphasis>
		<textEmphasisColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis-color" CSS property.</haxe_doc>
		</textEmphasisColor>
		<textEmphasisPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis-position" CSS property.</haxe_doc>
		</textEmphasisPosition>
		<textEmphasisStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis-style" CSS property.</haxe_doc>
		</textEmphasisStyle>
		<textHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-height" CSS property.</haxe_doc>
		</textHeight>
		<textIndent public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-indent" CSS property.</haxe_doc>
		</textIndent>
		<textJustify public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-justify" CSS property.</haxe_doc>
		</textJustify>
		<textOrientation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-orientation" CSS property.</haxe_doc>
		</textOrientation>
		<textOverflow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-overflow" CSS property.</haxe_doc>
		</textOverflow>
		<textShadow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-shadow" CSS property.</haxe_doc>
		</textShadow>
		<textSpaceCollapse public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-space-collapse" CSS property.</haxe_doc>
		</textSpaceCollapse>
		<textTransform public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-transform" CSS property.</haxe_doc>
		</textTransform>
		<textUnderlinePosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-underline-position" CSS property.</haxe_doc>
		</textUnderlinePosition>
		<textWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-wrap" CSS property.</haxe_doc>
		</textWrap>
		<top public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "top" CSS property.</haxe_doc>
		</top>
		<transform public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transform" CSS property.</haxe_doc>
		</transform>
		<transformOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transform-origin" CSS property.</haxe_doc>
		</transformOrigin>
		<transformStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transform-style" CSS property.</haxe_doc>
		</transformStyle>
		<transition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition" CSS property.</haxe_doc>
		</transition>
		<transitionDelay public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-delay" CSS property.</haxe_doc>
		</transitionDelay>
		<transitionDuration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-duration" CSS property.</haxe_doc>
		</transitionDuration>
		<transitionProperty public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-property" CSS property.</haxe_doc>
		</transitionProperty>
		<transitionTimingFunction public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-timing-function" CSS property.</haxe_doc>
		</transitionTimingFunction>
		<unicodeBidi public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "unicode-bidi" CSS property.</haxe_doc>
		</unicodeBidi>
		<verticalAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "vertical-align" CSS property.</haxe_doc>
		</verticalAlign>
		<visibility public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "visibility" CSS property.</haxe_doc>
		</visibility>
		<voiceBalance public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-balance" CSS property.</haxe_doc>
		</voiceBalance>
		<voiceDuration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-duration" CSS property.</haxe_doc>
		</voiceDuration>
		<voiceFamily public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-family" CSS property.</haxe_doc>
		</voiceFamily>
		<voicePitch public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-pitch" CSS property.</haxe_doc>
		</voicePitch>
		<voiceRange public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-range" CSS property.</haxe_doc>
		</voiceRange>
		<voiceRate public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-rate" CSS property.</haxe_doc>
		</voiceRate>
		<voiceStress public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-stress" CSS property.</haxe_doc>
		</voiceStress>
		<voiceVolume public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-volume" CSS property.</haxe_doc>
		</voiceVolume>
		<volume public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "volume" CSS property.</haxe_doc>
		</volume>
		<whiteSpace public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "white-space" CSS property.</haxe_doc>
		</whiteSpace>
		<widows public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "widows" CSS property.</haxe_doc>
		</widows>
		<width public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "width" CSS property.</haxe_doc>
		</width>
		<willChange public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "will-change" CSS property.</haxe_doc>
		</willChange>
		<wordBreak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "word-break" CSS property.</haxe_doc>
		</wordBreak>
		<wordSpacing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "word-spacing" CSS property.</haxe_doc>
		</wordSpacing>
		<wordWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "word-wrap" CSS property.</haxe_doc>
		</wordWrap>
		<wrapFlow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "wrap-flow" CSS property.</haxe_doc>
		</wrapFlow>
		<wrapThrough public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "wrap-through" CSS property.</haxe_doc>
		</wrapThrough>
		<writingMode public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "writing-mode" CSS property.</haxe_doc>
		</writingMode>
		<zIndex public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "z-index" CSS property.</haxe_doc>
		</zIndex>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<getPropertyValue public="1" set="method">
			<f a="property">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getPropertyValue>
		<getPropertyCSSValue public="1" set="method">
			<f a="property">
				<c path="String"/>
				<c path="js.html.CSSValue"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getPropertyCSSValue>
		<getPropertyPriority public="1" set="method"><f a="property">
	<c path="String"/>
	<c path="String"/>
</f></getPropertyPriority>
		<setProperty public="1" set="method">
			<f a="property:value:?priority" v="::&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{priority:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setProperty>
		<removeProperty public="1" set="method">
			<f a="property">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeProperty>
		<meta><m n=":native"><e>"CSSStyleDeclaration"</e></m></meta>
	</class>
	<class path="js.html.StyleSheet" params="" file="/usr/lib/haxe/std/js/html/StyleSheet.hx" extern="1">
		<type public="1" set="null"><c path="String"/></type>
		<href public="1" set="null"><c path="String"/></href>
		<ownerNode public="1" set="null"><c path="js.html.Node"/></ownerNode>
		<parentStyleSheet public="1" set="null"><c path="js.html.StyleSheet"/></parentStyleSheet>
		<title public="1" set="null"><c path="String"/></title>
		<media public="1" set="null"><c path="js.html.MediaList"/></media>
		<disabled public="1"><x path="Bool"/></disabled>
		<meta><m n=":native"><e>"StyleSheet"</e></m></meta>
	</class>
	<class path="js.html.CSSStyleSheet" params="" file="/usr/lib/haxe/std/js/html/CSSStyleSheet.hx" extern="1">
		<extends path="js.html.StyleSheet"/>
		<ownerRule public="1" set="null"><c path="js.html.CSSRule"/></ownerRule>
		<cssRules public="1" set="null"><c path="js.html.CSSRuleList"/></cssRules>
		<insertRule public="1" set="method">
			<f a="rule:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertRule>
		<deleteRule public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteRule>
		<meta><m n=":native"><e>"CSSStyleSheet"</e></m></meta>
	</class>
	<class path="js.html.CSSValue" params="" file="/usr/lib/haxe/std/js/html/CSSValue.hx" extern="1">
		<CSS_INHERIT public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</CSS_INHERIT>
		<CSS_PRIMITIVE_VALUE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CSS_PRIMITIVE_VALUE>
		<CSS_VALUE_LIST public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CSS_VALUE_LIST>
		<CSS_CUSTOM public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</CSS_CUSTOM>
		<cssText public="1"><c path="String"/></cssText>
		<cssValueType public="1" set="null"><x path="Int"/></cssValueType>
		<meta><m n=":native"><e>"CSSValue"</e></m></meta>
	</class>
	<class path="js.html.CanvasElement" params="" file="/usr/lib/haxe/std/js/html/CanvasElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<getContext public="1" set="method">
			<f a="contextId:?contextOptions">
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getContext>
		<toDataURL public="1" set="method">
			<f a="?type:?encoderOptions" v="&quot;&quot;:">
				<c path="String"/>
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{type:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</toDataURL>
		<toBlob public="1" set="method">
			<f a="callback:?type:?encoderOptions" v=":&quot;&quot;:">
				<f a="">
					<c path="js.html.Blob"/>
					<x path="Void"/>
				</f>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{type:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</toBlob>
		<getContext2d public="1" get="inline" set="null" line="41">
			<f a="?attribs">
				<a/>
				<c path="js.html.CanvasRenderingContext2D"/>
			</f>
			<haxe_doc>Shorthand for getting a CanvasRenderingContext2D.</haxe_doc>
		</getContext2d>
		<getContextWebGL public="1" get="inline" set="null" line="45">
			<f a="?attribs">
				<t path="js.html.webgl.ContextAttributes"/>
				<c path="js.html.webgl.RenderingContext"/>
			</f>
			<haxe_doc>Shorthand for getting a js.html.webgl.RenderingContext.</haxe_doc>
		</getContextWebGL>
		<meta><m n=":native"><e>"HTMLCanvasElement"</e></m></meta>
	</class>
	<class path="js.html.CanvasGradient" params="" file="/usr/lib/haxe/std/js/html/CanvasGradient.hx" extern="1">
		<addColorStop public="1" set="method">
			<f a="offset:color">
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</addColorStop>
		<meta><m n=":native"><e>"CanvasGradient"</e></m></meta>
	</class>
	<class path="js.html.CanvasPattern" params="" file="/usr/lib/haxe/std/js/html/CanvasPattern.hx" extern="1">
		<setTransform public="1" set="method"><f a="matrix">
	<c path="js.html.svg.Matrix"/>
	<x path="Void"/>
</f></setTransform>
		<meta><m n=":native"><e>"CanvasPattern"</e></m></meta>
	</class>
	<class path="js.html.CanvasRenderingContext2D" params="" file="/usr/lib/haxe/std/js/html/CanvasRenderingContext2D.hx" extern="1">
		<canvas public="1" set="null"><c path="js.html.CanvasElement"/></canvas>
		<globalAlpha public="1"><x path="Float"/></globalAlpha>
		<globalCompositeOperation public="1"><c path="String"/></globalCompositeOperation>
		<strokeStyle public="1"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.CanvasGradient"/>
		<c path="js.html.CanvasPattern"/>
	</x>
</x></strokeStyle>
		<fillStyle public="1"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.CanvasGradient"/>
		<c path="js.html.CanvasPattern"/>
	</x>
</x></fillStyle>
		<shadowOffsetX public="1"><x path="Float"/></shadowOffsetX>
		<shadowOffsetY public="1"><x path="Float"/></shadowOffsetY>
		<shadowBlur public="1"><x path="Float"/></shadowBlur>
		<shadowColor public="1"><c path="String"/></shadowColor>
		<filter public="1"><c path="String"/></filter>
		<imageSmoothingEnabled public="1"><x path="Bool"/></imageSmoothingEnabled>
		<lineWidth public="1"><x path="Float"/></lineWidth>
		<lineCap public="1"><c path="String"/></lineCap>
		<lineJoin public="1"><c path="String"/></lineJoin>
		<miterLimit public="1"><x path="Float"/></miterLimit>
		<lineDashOffset public="1"><x path="Float"/></lineDashOffset>
		<font public="1"><c path="String"/></font>
		<textAlign public="1"><c path="String"/></textAlign>
		<textBaseline public="1"><c path="String"/></textBaseline>
		<save public="1" set="method"><f a=""><x path="Void"/></f></save>
		<restore public="1" set="method"><f a=""><x path="Void"/></f></restore>
		<scale public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</scale>
		<rotate public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</rotate>
		<translate public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</translate>
		<transform public="1" set="method">
			<f a="a:b:c:d:e:f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</transform>
		<setTransform public="1" set="method">
			<f a="a:b:c:d:e:f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setTransform>
		<resetTransform public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</resetTransform>
		<createLinearGradient public="1" set="method"><f a="x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.CanvasGradient"/>
</f></createLinearGradient>
		<createRadialGradient public="1" set="method">
			<f a="x0:y0:r0:x1:y1:r1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.CanvasGradient"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createRadialGradient>
		<createPattern public="1" set="method">
			<f a="image:repetition">
				<x path="haxe.extern.EitherType">
					<c path="js.html.ImageElement"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.CanvasElement"/>
						<c path="js.html.VideoElement"/>
					</x>
				</x>
				<c path="String"/>
				<c path="js.html.CanvasPattern"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createPattern>
		<clearRect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearRect>
		<fillRect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<strokeRect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></strokeRect>
		<beginPath public="1" set="method"><f a=""><x path="Void"/></f></beginPath>
		<fill public="1" set="method">
			<f a="path:?winding" v=":&quot;nonzero&quot;">
				<c path="js.html.Path2D"/>
				<x path="js.html.CanvasWindingRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
			<overloads><fill public="1" set="method">
	<f a="?winding" v="&quot;nonzero&quot;">
		<x path="js.html.CanvasWindingRule"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
</fill></overloads>
		</fill>
		<stroke public="1" set="method">
			<f a="path">
				<c path="js.html.Path2D"/>
				<x path="Void"/>
			</f>
			<overloads><stroke public="1" set="method"><f a=""><x path="Void"/></f></stroke></overloads>
		</stroke>
		<drawFocusIfNeeded public="1" set="method"><f a="element">
	<c path="js.html.Element"/>
	<x path="Void"/>
</f></drawFocusIfNeeded>
		<drawCustomFocusRing public="1" set="method"><f a="element">
	<c path="js.html.Element"/>
	<x path="Bool"/>
</f></drawCustomFocusRing>
		<clip public="1" set="method">
			<f a="path:?winding" v=":&quot;nonzero&quot;">
				<c path="js.html.Path2D"/>
				<x path="js.html.CanvasWindingRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
			<overloads><clip public="1" set="method">
	<f a="?winding" v="&quot;nonzero&quot;">
		<x path="js.html.CanvasWindingRule"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
</clip></overloads>
		</clip>
		<isPointInPath public="1" set="method">
			<f a="path:x:y:?winding" v=":::&quot;nonzero&quot;">
				<c path="js.html.Path2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="js.html.CanvasWindingRule"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
			<overloads><isPointInPath public="1" set="method">
	<f a="x:y:?winding" v="::&quot;nonzero&quot;">
		<x path="Float"/>
		<x path="Float"/>
		<x path="js.html.CanvasWindingRule"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
</isPointInPath></overloads>
		</isPointInPath>
		<isPointInStroke public="1" set="method">
			<f a="path:x:y">
				<c path="js.html.Path2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<overloads><isPointInStroke public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isPointInStroke></overloads>
		</isPointInStroke>
		<fillText public="1" set="method">
			<f a="text:x:y:?maxWidth">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</fillText>
		<strokeText public="1" set="method">
			<f a="text:x:y:?maxWidth">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</strokeText>
		<measureText public="1" set="method">
			<f a="text">
				<c path="String"/>
				<c path="js.html.TextMetrics"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</measureText>
		<drawImage public="1" set="method">
			<f a="image:sx:sy:sw:sh:dx:dy:dw:dh">
				<x path="haxe.extern.EitherType">
					<c path="js.html.ImageElement"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.CanvasElement"/>
						<c path="js.html.VideoElement"/>
					</x>
				</x>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<drawImage public="1" set="method">
					<f a="image:dx:dy">
						<x path="haxe.extern.EitherType">
							<c path="js.html.ImageElement"/>
							<x path="haxe.extern.EitherType">
								<c path="js.html.CanvasElement"/>
								<c path="js.html.VideoElement"/>
							</x>
						</x>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</drawImage>
				<drawImage public="1" set="method">
					<f a="image:dx:dy:dw:dh">
						<x path="haxe.extern.EitherType">
							<c path="js.html.ImageElement"/>
							<x path="haxe.extern.EitherType">
								<c path="js.html.CanvasElement"/>
								<c path="js.html.VideoElement"/>
							</x>
						</x>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</drawImage>
			</overloads>
		</drawImage>
		<addHitRegion public="1" set="method">
			<f a="?options">
				<t path="js.html.HitRegionOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</addHitRegion>
		<removeHitRegion public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></removeHitRegion>
		<clearHitRegions public="1" set="method"><f a=""><x path="Void"/></f></clearHitRegions>
		<createImageData public="1" set="method">
			<f a="imagedata">
				<c path="js.html.ImageData"/>
				<c path="js.html.ImageData"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createImageData public="1" set="method">
	<f a="sw:sh">
		<x path="Float"/>
		<x path="Float"/>
		<c path="js.html.ImageData"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createImageData></overloads>
		</createImageData>
		<getImageData public="1" set="method">
			<f a="sx:sy:sw:sh">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.ImageData"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getImageData>
		<putImageData public="1" set="method">
			<f a="imagedata:dx:dy:dirtyX:dirtyY:dirtyWidth:dirtyHeight">
				<c path="js.html.ImageData"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><putImageData public="1" set="method">
	<f a="imagedata:dx:dy">
		<c path="js.html.ImageData"/>
		<x path="Float"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</putImageData></overloads>
		</putImageData>
		<setLineDash public="1" set="method"><f a="segments">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setLineDash>
		<getLineDash public="1" set="method"><f a=""><c path="Array"><x path="Float"/></c></f></getLineDash>
		<closePath public="1" set="method"><f a=""><x path="Void"/></f></closePath>
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<quadraticCurveTo public="1" set="method"><f a="cpx:cpy:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadraticCurveTo>
		<bezierCurveTo public="1" set="method"><f a="cp1x:cp1y:cp2x:cp2y:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bezierCurveTo>
		<arcTo public="1" set="method">
			<f a="x1:y1:x2:y2:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arcTo>
		<rect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rect>
		<arc public="1" set="method">
			<f a="x:y:radius:startAngle:endAngle:?anticlockwise" v=":::::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{anticlockwise:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arc>
		<meta><m n=":native"><e>"CanvasRenderingContext2D"</e></m></meta>
	</class>
	<abstract path="js.html.CanvasWindingRule" params="" file="/usr/lib/haxe/std/js/html/CanvasWindingRule.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._CanvasWindingRule.CanvasWindingRule_Impl_" params="" file="/usr/lib/haxe/std/js/html/CanvasWindingRule.hx" private="1" module="js.html.CanvasWindingRule"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.CaretPosition" params="" file="/usr/lib/haxe/std/js/html/CaretPosition.hx" extern="1">
		<offsetNode public="1" set="null"><c path="js.html.Node"/></offsetNode>
		<offset public="1" set="null"><x path="Int"/></offset>
		<getClientRect public="1" set="method"><f a=""><c path="js.html.DOMRect"/></f></getClientRect>
		<meta><m n=":native"><e>"CaretPosition"</e></m></meta>
	</class>
	<typedef path="js.html.ChromeFilePropertyBag" params="" file="/usr/lib/haxe/std/js/html/ChromeFilePropertyBag.hx"><a>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<temporary>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</temporary>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<lastModified>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</lastModified>
</a></typedef>
	<class path="js.html.Comment" params="" file="/usr/lib/haxe/std/js/html/Comment.hx" extern="1">
		<extends path="js.html.CharacterData"/>
		<new public="1" set="method">
			<f a="?data" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{data:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Comment"</e></m></meta>
	</class>
	<class path="js.html.Console" params="" file="/usr/lib/haxe/std/js/html/Console.hx" extern="1">
		<log public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></log>
		<info public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></info>
		<warn public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></warn>
		<error public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></error>
		<exception public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></exception>
		<debug public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></debug>
		<table public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></table>
		<trace public="1" set="method"><f a=""><x path="Void"/></f></trace>
		<dir public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></dir>
		<group public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></group>
		<groupCollapsed public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></groupCollapsed>
		<groupEnd public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></groupEnd>
		<time public="1" set="method"><f a="?time">
	<d/>
	<x path="Void"/>
</f></time>
		<timeEnd public="1" set="method"><f a="?time">
	<d/>
	<x path="Void"/>
</f></timeEnd>
		<profile public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></profile>
		<profileEnd public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></profileEnd>
		<assert public="1" set="method"><f a="condition:data">
	<x path="Bool"/>
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></assert>
		<count public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></count>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<meta><m n=":native"><e>"Console"</e></m></meta>
	</class>
	<class path="js.html.ContentElement" params="" file="/usr/lib/haxe/std/js/html/ContentElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<select public="1"><c path="String"/></select>
		<getDistributedNodes public="1" set="method"><f a=""><c path="js.html.NodeList"/></f></getDistributedNodes>
		<meta><m n=":native"><e>"HTMLContentElement"</e></m></meta>
	</class>
	<typedef path="js.html.ConvertCoordinateOptions" params="" file="/usr/lib/haxe/std/js/html/ConvertCoordinateOptions.hx"><a>
	<toBox>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</toBox>
	<fromBox>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</fromBox>
</a></typedef>
	<class path="js.html.Coordinates" params="" file="/usr/lib/haxe/std/js/html/Coordinates.hx" extern="1">
		<latitude public="1" set="null"><x path="Float"/></latitude>
		<longitude public="1" set="null"><x path="Float"/></longitude>
		<altitude public="1" set="null"><x path="Float"/></altitude>
		<accuracy public="1" set="null"><x path="Float"/></accuracy>
		<altitudeAccuracy public="1" set="null"><x path="Float"/></altitudeAccuracy>
		<heading public="1" set="null"><x path="Float"/></heading>
		<speed public="1" set="null"><x path="Float"/></speed>
		<meta><m n=":native"><e>"Coordinates"</e></m></meta>
	</class>
	<class path="js.html.DListElement" params="" file="/usr/lib/haxe/std/js/html/DListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLDListElement"</e></m></meta>
	</class>
	<class path="js.html.DOMError" params="" file="/usr/lib/haxe/std/js/html/DOMError.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<message public="1" set="null"><c path="String"/></message>
		<new public="1" set="method">
			<f a="name:?message" v=":&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{message:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"DOMError"</e></m></meta>
	</class>
	<class path="js.html.DOMImplementation" params="" file="/usr/lib/haxe/std/js/html/DOMImplementation.hx" extern="1">
		<hasFeature public="1" set="method"><f a="feature:version">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasFeature>
		<createDocumentType public="1" set="method">
			<f a="qualifiedName:publicId:systemId">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.DocumentType"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createDocumentType>
		<createDocument public="1" set="method">
			<f a="namespace_:qualifiedName:?doctype">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.DocumentType"/>
				<c path="js.html.HTMLDocument"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createDocument>
		<createHTMLDocument public="1" set="method">
			<f a="?title">
				<c path="String"/>
				<c path="js.html.HTMLDocument"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createHTMLDocument>
		<meta><m n=":native"><e>"DOMImplementation"</e></m></meta>
	</class>
	<class path="js.html.DOMPointReadOnly" params="" file="/usr/lib/haxe/std/js/html/DOMPointReadOnly.hx" extern="1">
		<x public="1" set="null"><x path="Float"/></x>
		<y public="1" set="null"><x path="Float"/></y>
		<z public="1" set="null"><x path="Float"/></z>
		<w public="1" set="null"><x path="Float"/></w>
		<meta><m n=":native"><e>"DOMPointReadOnly"</e></m></meta>
	</class>
	<class path="js.html.DOMPoint" params="" file="/usr/lib/haxe/std/js/html/DOMPoint.hx" extern="1">
		<extends path="js.html.DOMPointReadOnly"/>
		<new public="1" set="method">
			<f a="x:y:?z:?w" v="::0.0:1.0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{w:1.0,z:0.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?point">
		<t path="js.html.DOMPointInit"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"DOMPoint"</e></m></meta>
	</class>
	<typedef path="js.html.DOMPointInit" params="" file="/usr/lib/haxe/std/js/html/DOMPointInit.hx"><a>
	<z>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</z>
	<y>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</y>
	<x>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</x>
	<w>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</w>
</a></typedef>
	<class path="js.html.DOMQuad" params="" file="/usr/lib/haxe/std/js/html/DOMQuad.hx" extern="1">
		<p1 public="1" set="null"><c path="js.html.DOMPoint"/></p1>
		<p2 public="1" set="null"><c path="js.html.DOMPoint"/></p2>
		<p3 public="1" set="null"><c path="js.html.DOMPoint"/></p3>
		<p4 public="1" set="null"><c path="js.html.DOMPoint"/></p4>
		<bounds public="1" set="null"><c path="js.html.DOMRectReadOnly"/></bounds>
		<new public="1" set="method">
			<f a="rect">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?p1:?p2:?p3:?p4">
		<t path="js.html.DOMPointInit"/>
		<t path="js.html.DOMPointInit"/>
		<t path="js.html.DOMPointInit"/>
		<t path="js.html.DOMPointInit"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"DOMQuad"</e></m></meta>
	</class>
	<class path="js.html.DOMRectReadOnly" params="" file="/usr/lib/haxe/std/js/html/DOMRectReadOnly.hx" extern="1">
		<x public="1" set="null"><x path="Float"/></x>
		<y public="1" set="null"><x path="Float"/></y>
		<width public="1" set="null"><x path="Float"/></width>
		<height public="1" set="null"><x path="Float"/></height>
		<top public="1" set="null"><x path="Float"/></top>
		<right public="1" set="null"><x path="Float"/></right>
		<bottom public="1" set="null"><x path="Float"/></bottom>
		<left public="1" set="null"><x path="Float"/></left>
		<meta><m n=":native"><e>"DOMRectReadOnly"</e></m></meta>
	</class>
	<class path="js.html.DOMRect" params="" file="/usr/lib/haxe/std/js/html/DOMRect.hx" extern="1">
		<extends path="js.html.DOMRectReadOnly"/>
		<new public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"DOMRect"</e></m></meta>
	</class>
	<class path="js.html.DOMRectList" params="" file="/usr/lib/haxe/std/js/html/DOMRectList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.DOMRect"/>
</f></item>
		<meta><m n=":native"><e>"DOMRectList"</e></m></meta>
	</class>
	<class path="js.html.DOMTokenList" params="" file="/usr/lib/haxe/std/js/html/DOMTokenList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<contains public="1" set="method">
			<f a="token">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</contains>
		<add public="1" set="method">
			<f a="tokens">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<remove public="1" set="method">
			<f a="tokens">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</remove>
		<toggle public="1" set="method">
			<f a="token:?force">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</toggle>
		<meta><m n=":native"><e>"DOMTokenList"</e></m></meta>
	</class>
	<class path="js.html.DOMSettableTokenList" params="" file="/usr/lib/haxe/std/js/html/DOMSettableTokenList.hx" extern="1">
		<extends path="js.html.DOMTokenList"/>
		<value public="1"><c path="String"/></value>
		<meta><m n=":native"><e>"DOMSettableTokenList"</e></m></meta>
	</class>
	<class path="js.html.DOMStringList" params="" file="/usr/lib/haxe/std/js/html/DOMStringList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<contains public="1" set="method"><f a="string">
	<c path="String"/>
	<x path="Bool"/>
</f></contains>
		<meta><m n=":native"><e>"DOMStringList"</e></m></meta>
	</class>
	<class path="js.html.DOMStringMap" params="" file="/usr/lib/haxe/std/js/html/DOMStringMap.hx" extern="1">
		<meta><m n=":native"><e>"DOMStringMap"</e></m></meta>
		<haxe_dynamic><c path="String"/></haxe_dynamic>
	</class>
	<typedef path="js.html.DOMWindow" params="" file="/usr/lib/haxe/std/js/html/DOMWindow.hx">
		<c path="js.html.Window"/>
		<haxe_doc>@deprecated Use Window instead.</haxe_doc>
		<meta><m n=":deprecated"><e>"DOMWindow is deprecated, use Window instead"</e></m></meta>
	</typedef>
	<class path="js.html.DataListElement" params="" file="/usr/lib/haxe/std/js/html/DataListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<options public="1" set="null"><c path="js.html.HTMLCollection"/></options>
		<meta><m n=":native"><e>"HTMLDataListElement"</e></m></meta>
	</class>
	<class path="js.html.DataView" params="" file="/usr/lib/haxe/std/js/html/DataView.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<getInt8 public="1" set="method"><f a="byteOffset">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt8>
		<getUint8 public="1" set="method"><f a="byteOffset">
	<x path="Int"/>
	<x path="Int"/>
</f></getUint8>
		<getInt16 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getInt16>
		<getUint16 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getUint16>
		<getInt32 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getInt32>
		<getUint32 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getUint32>
		<getFloat32 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></getFloat32>
		<getFloat64 public="1" set="method"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></getFloat64>
		<setInt8 public="1" set="method"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt8>
		<setUint8 public="1" set="method"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setUint8>
		<setInt16 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setInt16>
		<setUint16 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setUint16>
		<setInt32 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setInt32>
		<setUint32 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setUint32>
		<setFloat32 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setFloat32>
		<setFloat64 public="1" set="method"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setFloat64>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?byteLength">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"DataView"</e></m>
		</meta>
	</class>
	<abstract path="js.html.DirectionSetting" params="" file="/usr/lib/haxe/std/js/html/DirectionSetting.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._DirectionSetting.DirectionSetting_Impl_" params="" file="/usr/lib/haxe/std/js/html/DirectionSetting.hx" private="1" module="js.html.DirectionSetting"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.DirectoryElement" params="" file="/usr/lib/haxe/std/js/html/DirectoryElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLDirectoryElement"</e></m></meta>
	</class>
	<class path="js.html.DivElement" params="" file="/usr/lib/haxe/std/js/html/DivElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLDivElement"</e></m></meta>
	</class>
	<class path="js.html.Document" params="" file="/usr/lib/haxe/std/js/html/Document.hx" extern="1">
		<extends path="js.html.Node"/>
		<implementation public="1" set="null"><c path="js.html.DOMImplementation"/></implementation>
		<URL public="1" set="null"><c path="String"/></URL>
		<documentURI public="1" set="null"><c path="String"/></documentURI>
		<compatMode public="1" set="null"><c path="String"/></compatMode>
		<characterSet public="1" set="null"><c path="String"/></characterSet>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<doctype public="1" set="null"><c path="js.html.DocumentType"/></doctype>
		<documentElement public="1" set="null"><c path="js.html.Element"/></documentElement>
		<inputEncoding public="1" set="null"><c path="String"/></inputEncoding>
		<fullscreenEnabled public="1" set="null"><x path="Bool"/></fullscreenEnabled>
		<fullscreenElement public="1" set="null"><c path="js.html.Element"/></fullscreenElement>
		<onfullscreenchange public="1"><x path="haxe.Function"/></onfullscreenchange>
		<onfullscreenerror public="1"><x path="haxe.Function"/></onfullscreenerror>
		<location public="1" set="null"><c path="js.html.Location"/></location>
		<referrer public="1" set="null"><c path="String"/></referrer>
		<lastModified public="1" set="null"><c path="String"/></lastModified>
		<readyState public="1" set="null"><c path="String"/></readyState>
		<title public="1"><c path="String"/></title>
		<dir public="1"><c path="String"/></dir>
		<defaultView public="1" set="null"><c path="js.html.Window"/></defaultView>
		<activeElement public="1" set="null"><c path="js.html.Element"/></activeElement>
		<onreadystatechange public="1"><x path="haxe.Function"/></onreadystatechange>
		<onwheel public="1"><x path="haxe.Function"/></onwheel>
		<oncopy public="1"><x path="haxe.Function"/></oncopy>
		<oncut public="1"><x path="haxe.Function"/></oncut>
		<onpaste public="1"><x path="haxe.Function"/></onpaste>
		<onbeforescriptexecute public="1"><x path="haxe.Function"/></onbeforescriptexecute>
		<onafterscriptexecute public="1"><x path="haxe.Function"/></onafterscriptexecute>
		<currentScript public="1" set="null"><c path="js.html.Element"/></currentScript>
		<pointerLockElement public="1" set="null"><c path="js.html.Element"/></pointerLockElement>
		<hidden public="1" set="null"><x path="Bool"/></hidden>
		<visibilityState public="1" set="null"><x path="js.html.VisibilityState"/></visibilityState>
		<styleSheets public="1" set="null"><c path="js.html.StyleSheetList"/></styleSheets>
		<selectedStyleSheetSet public="1"><c path="String"/></selectedStyleSheetSet>
		<lastStyleSheetSet public="1" set="null"><c path="String"/></lastStyleSheetSet>
		<preferredStyleSheetSet public="1" set="null"><c path="String"/></preferredStyleSheetSet>
		<styleSheetSets public="1" set="null"><c path="js.html.DOMStringList"/></styleSheetSets>
		<timeline public="1" set="null"><c path="js.html.AnimationTimeline"/></timeline>
		<fonts public="1" set="null"><c path="js.html.FontFaceSet"/></fonts>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onblur public="1"><x path="haxe.Function"/></onblur>
		<onfocus public="1"><x path="haxe.Function"/></onfocus>
		<oncanplay public="1"><x path="haxe.Function"/></oncanplay>
		<oncanplaythrough public="1"><x path="haxe.Function"/></oncanplaythrough>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onclick public="1"><x path="haxe.Function"/></onclick>
		<oncontextmenu public="1"><x path="haxe.Function"/></oncontextmenu>
		<ondblclick public="1"><x path="haxe.Function"/></ondblclick>
		<ondrag public="1"><x path="haxe.Function"/></ondrag>
		<ondragend public="1"><x path="haxe.Function"/></ondragend>
		<ondragenter public="1"><x path="haxe.Function"/></ondragenter>
		<ondragleave public="1"><x path="haxe.Function"/></ondragleave>
		<ondragover public="1"><x path="haxe.Function"/></ondragover>
		<ondragstart public="1"><x path="haxe.Function"/></ondragstart>
		<ondrop public="1"><x path="haxe.Function"/></ondrop>
		<ondurationchange public="1"><x path="haxe.Function"/></ondurationchange>
		<onemptied public="1"><x path="haxe.Function"/></onemptied>
		<onended public="1"><x path="haxe.Function"/></onended>
		<oninput public="1"><x path="haxe.Function"/></oninput>
		<oninvalid public="1"><x path="haxe.Function"/></oninvalid>
		<onkeydown public="1"><x path="haxe.Function"/></onkeydown>
		<onkeypress public="1"><x path="haxe.Function"/></onkeypress>
		<onkeyup public="1"><x path="haxe.Function"/></onkeyup>
		<onload public="1"><x path="haxe.Function"/></onload>
		<onloadeddata public="1"><x path="haxe.Function"/></onloadeddata>
		<onloadedmetadata public="1"><x path="haxe.Function"/></onloadedmetadata>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onmousedown public="1"><x path="haxe.Function"/></onmousedown>
		<onmouseenter public="1"><x path="haxe.Function"/></onmouseenter>
		<onmouseleave public="1"><x path="haxe.Function"/></onmouseleave>
		<onmousemove public="1"><x path="haxe.Function"/></onmousemove>
		<onmouseout public="1"><x path="haxe.Function"/></onmouseout>
		<onmouseover public="1"><x path="haxe.Function"/></onmouseover>
		<onmouseup public="1"><x path="haxe.Function"/></onmouseup>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onplay public="1"><x path="haxe.Function"/></onplay>
		<onplaying public="1"><x path="haxe.Function"/></onplaying>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onratechange public="1"><x path="haxe.Function"/></onratechange>
		<onreset public="1"><x path="haxe.Function"/></onreset>
		<onscroll public="1"><x path="haxe.Function"/></onscroll>
		<onseeked public="1"><x path="haxe.Function"/></onseeked>
		<onseeking public="1"><x path="haxe.Function"/></onseeking>
		<onselect public="1"><x path="haxe.Function"/></onselect>
		<onshow public="1"><x path="haxe.Function"/></onshow>
		<onstalled public="1"><x path="haxe.Function"/></onstalled>
		<onsubmit public="1"><x path="haxe.Function"/></onsubmit>
		<onsuspend public="1"><x path="haxe.Function"/></onsuspend>
		<ontimeupdate public="1"><x path="haxe.Function"/></ontimeupdate>
		<onvolumechange public="1"><x path="haxe.Function"/></onvolumechange>
		<onwaiting public="1"><x path="haxe.Function"/></onwaiting>
		<onpointercancel public="1"><x path="haxe.Function"/></onpointercancel>
		<onpointerdown public="1"><x path="haxe.Function"/></onpointerdown>
		<onpointerup public="1"><x path="haxe.Function"/></onpointerup>
		<onpointermove public="1"><x path="haxe.Function"/></onpointermove>
		<onpointerout public="1"><x path="haxe.Function"/></onpointerout>
		<onpointerover public="1"><x path="haxe.Function"/></onpointerover>
		<onpointerenter public="1"><x path="haxe.Function"/></onpointerenter>
		<onpointerleave public="1"><x path="haxe.Function"/></onpointerleave>
		<ongotpointercapture public="1"><x path="haxe.Function"/></ongotpointercapture>
		<onlostpointercapture public="1"><x path="haxe.Function"/></onlostpointercapture>
		<onpointerlockchange public="1"><x path="haxe.Function"/></onpointerlockchange>
		<onpointerlockerror public="1"><x path="haxe.Function"/></onpointerlockerror>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<children public="1" set="null"><c path="js.html.HTMLCollection"/></children>
		<firstElementChild public="1" set="null"><c path="js.html.Element"/></firstElementChild>
		<lastElementChild public="1" set="null"><c path="js.html.Element"/></lastElementChild>
		<childElementCount public="1" set="null"><x path="Int"/></childElementCount>
		<ontouchstart public="1"><x path="haxe.Function"/></ontouchstart>
		<ontouchend public="1"><x path="haxe.Function"/></ontouchend>
		<ontouchmove public="1"><x path="haxe.Function"/></ontouchmove>
		<ontouchcancel public="1"><x path="haxe.Function"/></ontouchcancel>
		<getElementsByTagName public="1" set="method"><f a="localName">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagName>
		<getElementsByTagNameNS public="1" set="method">
			<f a="namespace_:localName">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.HTMLCollection"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getElementsByTagNameNS>
		<getElementsByClassName public="1" set="method"><f a="classNames">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByClassName>
		<getElementById public="1" set="method"><f a="elementId">
	<c path="String"/>
	<c path="js.html.Element"/>
</f></getElementById>
		<createElement public="1" set="method">
			<f a="localName:typeExtension">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createElement public="1" set="method">
	<f a="localName">
		<c path="String"/>
		<c path="js.html.Element"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createElement></overloads>
		</createElement>
		<createElementNS public="1" set="method">
			<f a="namespace_:qualifiedName:typeExtension">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createElementNS public="1" set="method">
	<f a="namespace_:qualifiedName">
		<c path="String"/>
		<c path="String"/>
		<c path="js.html.Element"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createElementNS></overloads>
		</createElementNS>
		<createDocumentFragment public="1" set="method"><f a=""><c path="js.html.DocumentFragment"/></f></createDocumentFragment>
		<createTextNode public="1" set="method"><f a="data">
	<c path="String"/>
	<c path="js.html.Text"/>
</f></createTextNode>
		<createComment public="1" set="method"><f a="data">
	<c path="String"/>
	<c path="js.html.Comment"/>
</f></createComment>
		<createProcessingInstruction public="1" set="method">
			<f a="target:data">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.ProcessingInstruction"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createProcessingInstruction>
		<importNode public="1" set="method">
			<f a="node:?deep" v=":false">
				<c path="js.html.Node"/>
				<x path="Bool"/>
				<c path="js.html.Node"/>
			</f>
			<meta><m n=":value"><e>{deep:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</importNode>
		<adoptNode public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</adoptNode>
		<createEvent public="1" set="method">
			<f a="interface_">
				<c path="String"/>
				<c path="js.html.Event"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createEvent>
		<createRange public="1" set="method">
			<f a=""><c path="js.html.Range"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createRange>
		<createNodeIterator public="1" set="method">
			<f a="root:?whatToShow:?filter" v=":&apos;???&apos;:">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<c path="js.html.NodeFilter"/>
				<c path="js.html.NodeIterator"/>
			</f>
			<meta><m n=":value"><e>{whatToShow:'???'}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createNodeIterator>
		<createTreeWalker public="1" set="method">
			<f a="root:?whatToShow:?filter" v=":&apos;???&apos;:">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<c path="js.html.NodeFilter"/>
				<c path="js.html.TreeWalker"/>
			</f>
			<meta><m n=":value"><e>{whatToShow:'???'}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createTreeWalker>
		<createCDATASection public="1" set="method">
			<f a="data">
				<c path="String"/>
				<c path="js.html.CDATASection"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createCDATASection>
		<createAttribute public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createAttribute>
		<createAttributeNS public="1" set="method">
			<f a="namespace_:name">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createAttributeNS>
		<exitFullscreen public="1" set="method"><f a=""><x path="Void"/></f></exitFullscreen>
		<hasFocus public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</hasFocus>
		<releaseCapture public="1" set="method"><f a=""><x path="Void"/></f></releaseCapture>
		<exitPointerLock public="1" set="method"><f a=""><x path="Void"/></f></exitPointerLock>
		<registerElement public="1" set="method">
			<f a="name:?options">
				<c path="String"/>
				<t path="js.html.ElementRegistrationOptions"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</registerElement>
		<enableStyleSheetsForSet public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></enableStyleSheetsForSet>
		<elementFromPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.Element"/>
</f></elementFromPoint>
		<caretPositionFromPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.CaretPosition"/>
</f></caretPositionFromPoint>
		<querySelector public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelector>
		<querySelectorAll public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelectorAll>
		<createTouch public="1" set="method">
			<f a="?view:?target:?identifier:?pageX:?pageY:?screenX:?screenY:?clientX:?clientY:?radiusX:?radiusY:?rotationAngle:?force" v="::0:0:0:0:0:0:0:0:0:0.0:0.0">
				<c path="js.html.Window"/>
				<c path="js.html.EventTarget"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.Touch"/>
			</f>
			<meta><m n=":value"><e>{force:0.0,rotationAngle:0.0,radiusY:0,radiusX:0,clientY:0,clientX:0,screenY:0,screenX:0,pageY:0,pageX:0,identifier:0}</e></m></meta>
		</createTouch>
		<createTouchList public="1" set="method">
			<f a="touches">
				<c path="Array"><c path="js.html.Touch"/></c>
				<c path="js.html.TouchList"/>
			</f>
			<overloads>
				<createTouchList public="1" set="method"><f a="touch:touches">
	<c path="js.html.Touch"/>
	<x path="haxe.extern.Rest"><c path="js.html.Touch"/></x>
	<c path="js.html.TouchList"/>
</f></createTouchList>
				<createTouchList public="1" set="method"><f a=""><c path="js.html.TouchList"/></f></createTouchList>
			</overloads>
		</createTouchList>
		<convertQuadFromNode public="1" set="method">
			<f a="quad:from:?options">
				<c path="js.html.DOMQuad"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertQuadFromNode>
		<convertRectFromNode public="1" set="method">
			<f a="rect:from:?options">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertRectFromNode>
		<convertPointFromNode public="1" set="method">
			<f a="point:from:?options">
				<t path="js.html.DOMPointInit"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMPoint"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertPointFromNode>
		<createExpression public="1" set="method">
			<f a="expression:resolver">
				<c path="String"/>
				<c path="js.html.XPathNSResolver"/>
				<c path="js.html.XPathExpression"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createExpression>
		<createNSResolver public="1" set="method"><f a="nodeResolver">
	<c path="js.html.Node"/>
	<c path="js.html.Node"/>
</f></createNSResolver>
		<evaluate public="1" set="method">
			<f a="expression:contextNode:resolver:type:result">
				<c path="String"/>
				<c path="js.html.Node"/>
				<c path="js.html.XPathNSResolver"/>
				<x path="Int"/>
				<d/>
				<c path="js.html.XPathResult"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</evaluate>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Document"</e></m></meta>
	</class>
	<class path="js.html.DocumentFragment" params="" file="/usr/lib/haxe/std/js/html/DocumentFragment.hx" extern="1">
		<extends path="js.html.Node"/>
		<children public="1" set="null"><c path="js.html.HTMLCollection"/></children>
		<firstElementChild public="1" set="null"><c path="js.html.Element"/></firstElementChild>
		<lastElementChild public="1" set="null"><c path="js.html.Element"/></lastElementChild>
		<childElementCount public="1" set="null"><x path="Int"/></childElementCount>
		<getElementById public="1" set="method"><f a="elementId">
	<c path="String"/>
	<c path="js.html.Element"/>
</f></getElementById>
		<querySelector public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelector>
		<querySelectorAll public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelectorAll>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"DocumentFragment"</e></m></meta>
	</class>
	<class path="js.html.DocumentType" params="" file="/usr/lib/haxe/std/js/html/DocumentType.hx" extern="1">
		<extends path="js.html.Node"/>
		<name public="1" set="null"><c path="String"/></name>
		<publicId public="1" set="null"><c path="String"/></publicId>
		<systemId public="1" set="null"><c path="String"/></systemId>
		<internalSubset public="1" set="null"><c path="String"/></internalSubset>
		<remove public="1" set="method"><f a=""><x path="Void"/></f></remove>
		<meta><m n=":native"><e>"DocumentType"</e></m></meta>
	</class>
	<typedef path="js.html.ElementRegistrationOptions" params="" file="/usr/lib/haxe/std/js/html/ElementRegistrationOptions.hx"><a>
	<prototype>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</prototype>
	<extends_>
		<t path="Null"><c path="String"/></t>
		<meta>
			<m n=":native"><e>"extends"</e></m>
			<m n=":optional"/>
		</meta>
	</extends_>
</a></typedef>
	<class path="js.html.EmbedElement" params="" file="/usr/lib/haxe/std/js/html/EmbedElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<type public="1"><c path="String"/></type>
		<width public="1"><c path="String"/></width>
		<height public="1"><c path="String"/></height>
		<align public="1"><c path="String"/></align>
		<name public="1"><c path="String"/></name>
		<getSVGDocument public="1" set="method"><f a=""><c path="js.html.HTMLDocument"/></f></getSVGDocument>
		<meta><m n=":native"><e>"HTMLEmbedElement"</e></m></meta>
	</class>
	<class path="js.html.Event" params="" file="/usr/lib/haxe/std/js/html/Event.hx" extern="1">
		<NONE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<CAPTURING_PHASE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CAPTURING_PHASE>
		<AT_TARGET public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</AT_TARGET>
		<BUBBLING_PHASE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</BUBBLING_PHASE>
		<ALT_MASK public="1" get="inline" set="null" expr="1" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ALT_MASK>
		<CONTROL_MASK public="1" get="inline" set="null" expr="2" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CONTROL_MASK>
		<SHIFT_MASK public="1" get="inline" set="null" expr="4" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</SHIFT_MASK>
		<META_MASK public="1" get="inline" set="null" expr="8" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</META_MASK>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><c path="js.html.EventTarget"/></target>
		<currentTarget public="1" set="null"><c path="js.html.EventTarget"/></currentTarget>
		<eventPhase public="1" set="null"><x path="Int"/></eventPhase>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<cancelable public="1" set="null"><x path="Bool"/></cancelable>
		<defaultPrevented public="1" set="null"><x path="Bool"/></defaultPrevented>
		<isTrusted public="1" set="null"><x path="Bool"/></isTrusted>
		<timeStamp public="1" set="null"><x path="Float"/></timeStamp>
		<originalTarget public="1" set="null"><c path="js.html.EventTarget"/></originalTarget>
		<explicitOriginalTarget public="1" set="null"><c path="js.html.EventTarget"/></explicitOriginalTarget>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><x path="Void"/></f></preventDefault>
		<initEvent public="1" set="method">
			<f a="type:bubbles:cancelable">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</initEvent>
		<getPreventDefault public="1" set="method"><f a=""><x path="Bool"/></f></getPreventDefault>
		<new public="1" set="method">
			<f a="type:?eventInitDict">
				<c path="String"/>
				<t path="js.html.EventInit"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Event"</e></m></meta>
	</class>
	<class path="js.html.ErrorEvent" params="" file="/usr/lib/haxe/std/js/html/ErrorEvent.hx" extern="1">
		<extends path="js.html.Event"/>
		<message public="1" set="null"><c path="String"/></message>
		<filename public="1" set="null"><c path="String"/></filename>
		<lineno public="1" set="null"><x path="Int"/></lineno>
		<colno public="1" set="null"><x path="Int"/></colno>
		<error public="1" set="null"><d/></error>
		<new public="1" set="method">
			<f a="type:?eventInitDict">
				<c path="String"/>
				<t path="js.html.ErrorEventInit"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"ErrorEvent"</e></m></meta>
	</class>
	<typedef path="js.html.ErrorEventInit" params="" file="/usr/lib/haxe/std/js/html/ErrorEventInit.hx"><a>
	<message>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</message>
	<lineno>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</lineno>
	<filename>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</filename>
	<error>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</error>
	<colno>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</colno>
	<cancelable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</cancelable>
	<bubbles>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</bubbles>
</a></typedef>
	<typedef path="js.html.EventInit" params="" file="/usr/lib/haxe/std/js/html/EventInit.hx"><a>
	<cancelable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</cancelable>
	<bubbles>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</bubbles>
</a></typedef>
	<class path="js.html.EventListener" params="" file="/usr/lib/haxe/std/js/html/EventListener.hx" extern="1">
		<handleEvent public="1" set="method"><f a="event">
	<c path="js.html.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<meta><m n=":native"><e>"EventListener"</e></m></meta>
	</class>
	<class path="js.html.FieldSetElement" params="" file="/usr/lib/haxe/std/js/html/FieldSetElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<name public="1"><c path="String"/></name>
		<type public="1" set="null"><c path="String"/></type>
		<elements public="1" set="null"><c path="js.html.HTMLCollection"/></elements>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLFieldSetElement"</e></m></meta>
	</class>
	<class path="js.html.File" params="" file="/usr/lib/haxe/std/js/html/File.hx" extern="1">
		<extends path="js.html.Blob"/>
		<name public="1" set="null"><c path="String"/></name>
		<lastModified public="1" set="null"><x path="Int"/></lastModified>
		<lastModifiedDate public="1" set="null"><c path="Date"/></lastModifiedDate>
		<new public="1" set="method">
			<f a="fileBits:?options">
				<c path="String"/>
				<t path="js.html.ChromeFilePropertyBag"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="fileBits:fileName:?options">
						<c path="Array"><x path="haxe.extern.EitherType">
	<c path="js.html.ArrayBuffer"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<x path="haxe.extern.EitherType">
			<c path="js.html.Blob"/>
			<c path="String"/>
		</x>
	</x>
</x></c>
						<c path="String"/>
						<t path="js.html.FilePropertyBag"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="fileBits:?options">
						<c path="js.html.Blob"/>
						<t path="js.html.ChromeFilePropertyBag"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="fileBits:?options">
						<d/>
						<t path="js.html.ChromeFilePropertyBag"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"File"</e></m></meta>
	</class>
	<class path="js.html.FileList" params="" file="/usr/lib/haxe/std/js/html/FileList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.File"/>
</f></item>
		<meta><m n=":native"><e>"FileList"</e></m></meta>
	</class>
	<typedef path="js.html.FilePropertyBag" params="" file="/usr/lib/haxe/std/js/html/FilePropertyBag.hx"><a>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<lastModified>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</lastModified>
</a></typedef>
	<class path="js.html.Float32Array" params="" file="/usr/lib/haxe/std/js/html/Float32Array.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
				<set public="1" set="method"><f a="array:?offset">
	<c path="js.html.Float32Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
			</overloads>
		</set>
		<subarray public="1" set="method"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
</f></subarray>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="js.html.Float32Array"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Float"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Float32Array"</e></m>
		</meta>
	</class>
	<class path="js.html.FontElement" params="" file="/usr/lib/haxe/std/js/html/FontElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<color public="1"><c path="String"/></color>
		<face public="1"><c path="String"/></face>
		<size public="1"><c path="String"/></size>
		<meta><m n=":native"><e>"HTMLFontElement"</e></m></meta>
	</class>
	<class path="js.html.FontFace" params="" file="/usr/lib/haxe/std/js/html/FontFace.hx" extern="1">
		<family public="1"><c path="String"/></family>
		<style public="1"><c path="String"/></style>
		<weight public="1"><c path="String"/></weight>
		<stretch public="1"><c path="String"/></stretch>
		<unicodeRange public="1"><c path="String"/></unicodeRange>
		<variant public="1"><c path="String"/></variant>
		<featureSettings public="1"><c path="String"/></featureSettings>
		<status public="1" set="null"><x path="js.html.FontFaceLoadStatus"/></status>
		<loaded public="1" set="null"><c path="js.Promise"><c path="js.html.FontFace"/></c></loaded>
		<load public="1" set="method">
			<f a=""><c path="js.Promise"><c path="js.html.FontFace"/></c></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</load>
		<new public="1" set="method">
			<f a="family:source:?descriptors">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.ArrayBuffer"/>
						<c path="js.html.ArrayBufferView"/>
					</x>
				</x>
				<t path="js.html.FontFaceDescriptors"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"FontFace"</e></m></meta>
	</class>
	<typedef path="js.html.FontFaceDescriptors" params="" file="/usr/lib/haxe/std/js/html/FontFaceDescriptors.hx"><a>
	<weight>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</weight>
	<variant>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</variant>
	<unicodeRange>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</unicodeRange>
	<style>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</style>
	<stretch>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</stretch>
	<featureSettings>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</featureSettings>
</a></typedef>
	<abstract path="js.html.FontFaceLoadStatus" params="" file="/usr/lib/haxe/std/js/html/FontFaceLoadStatus.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._FontFaceLoadStatus.FontFaceLoadStatus_Impl_" params="" file="/usr/lib/haxe/std/js/html/FontFaceLoadStatus.hx" private="1" module="js.html.FontFaceLoadStatus"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.FontFaceSet" params="" file="/usr/lib/haxe/std/js/html/FontFaceSet.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<onloading public="1"><x path="haxe.Function"/></onloading>
		<onloadingdone public="1"><x path="haxe.Function"/></onloadingdone>
		<onloadingerror public="1"><x path="haxe.Function"/></onloadingerror>
		<ready public="1" set="null"><c path="js.Promise"><x path="Void"/></c></ready>
		<status public="1" set="null"><x path="js.html.FontFaceSetLoadStatus"/></status>
		<length public="1" set="null"><x path="Int"/></length>
		<add public="1" set="method">
			<f a="font">
				<c path="js.html.FontFace"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<has public="1" set="method"><f a="font">
	<c path="js.html.FontFace"/>
	<x path="Bool"/>
</f></has>
		<delete_ public="1" set="method">
			<f a="font">
				<c path="js.html.FontFace"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</delete_>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<load public="1" set="method">
			<f a="font:?text" v=":&quot; &quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="js.Promise"><c path="Array"><c path="js.html.FontFace"/></c></c>
			</f>
			<meta><m n=":value"><e>{text:" "}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</load>
		<meta><m n=":native"><e>"FontFaceSet"</e></m></meta>
	</class>
	<abstract path="js.html.FontFaceSetLoadStatus" params="" file="/usr/lib/haxe/std/js/html/FontFaceSetLoadStatus.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._FontFaceSetLoadStatus.FontFaceSetLoadStatus_Impl_" params="" file="/usr/lib/haxe/std/js/html/FontFaceSetLoadStatus.hx" private="1" module="js.html.FontFaceSetLoadStatus"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.FormData" params="" file="/usr/lib/haxe/std/js/html/FormData.hx" extern="1">
		<append public="1" set="method">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><append public="1" set="method"><f a="name:value:?filename">
	<c path="String"/>
	<c path="js.html.Blob"/>
	<c path="String"/>
	<x path="Void"/>
</f></append></overloads>
		</append>
		<new public="1" set="method">
			<f a="?form">
				<c path="js.html.FormElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"FormData"</e></m></meta>
	</class>
	<class path="js.html.FormElement" params="" file="/usr/lib/haxe/std/js/html/FormElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<acceptCharset public="1"><c path="String"/></acceptCharset>
		<action public="1"><c path="String"/></action>
		<autocomplete public="1"><c path="String"/></autocomplete>
		<enctype public="1"><c path="String"/></enctype>
		<encoding public="1"><c path="String"/></encoding>
		<method public="1"><c path="String"/></method>
		<name public="1"><c path="String"/></name>
		<noValidate public="1"><x path="Bool"/></noValidate>
		<target public="1"><c path="String"/></target>
		<elements public="1" set="null"><c path="js.html.HTMLCollection"/></elements>
		<length public="1" set="null"><x path="Int"/></length>
		<submit public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</submit>
		<reset public="1" set="method"><f a=""><x path="Void"/></f></reset>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<meta><m n=":native"><e>"HTMLFormElement"</e></m></meta>
	</class>
	<class path="js.html.FrameElement" params="" file="/usr/lib/haxe/std/js/html/FrameElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<scrolling public="1"><c path="String"/></scrolling>
		<src public="1"><c path="String"/></src>
		<frameBorder public="1"><c path="String"/></frameBorder>
		<longDesc public="1"><c path="String"/></longDesc>
		<noResize public="1"><x path="Bool"/></noResize>
		<contentDocument public="1" set="null"><c path="js.html.HTMLDocument"/></contentDocument>
		<contentWindow public="1" set="null"><c path="js.html.Window"/></contentWindow>
		<marginHeight public="1"><c path="String"/></marginHeight>
		<marginWidth public="1"><c path="String"/></marginWidth>
		<meta><m n=":native"><e>"HTMLFrameElement"</e></m></meta>
	</class>
	<class path="js.html.FrameSetElement" params="" file="/usr/lib/haxe/std/js/html/FrameSetElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<cols public="1"><c path="String"/></cols>
		<rows public="1"><c path="String"/></rows>
		<onafterprint public="1"><x path="haxe.Function"/></onafterprint>
		<onbeforeprint public="1"><x path="haxe.Function"/></onbeforeprint>
		<onbeforeunload public="1"><f a="">
	<c path="js.html.Event"/>
	<c path="String"/>
</f></onbeforeunload>
		<onhashchange public="1"><x path="haxe.Function"/></onhashchange>
		<onlanguagechange public="1"><x path="haxe.Function"/></onlanguagechange>
		<onmessage public="1"><x path="haxe.Function"/></onmessage>
		<onoffline public="1"><x path="haxe.Function"/></onoffline>
		<ononline public="1"><x path="haxe.Function"/></ononline>
		<onpagehide public="1"><x path="haxe.Function"/></onpagehide>
		<onpageshow public="1"><x path="haxe.Function"/></onpageshow>
		<onpopstate public="1"><x path="haxe.Function"/></onpopstate>
		<onresize public="1"><x path="haxe.Function"/></onresize>
		<onunload public="1"><x path="haxe.Function"/></onunload>
		<meta><m n=":native"><e>"HTMLFrameSetElement"</e></m></meta>
	</class>
	<class path="js.html.Gamepad" params="" file="/usr/lib/haxe/std/js/html/Gamepad.hx" extern="1">
		<id public="1" set="null"><c path="String"/></id>
		<index public="1" set="null"><x path="Int"/></index>
		<mapping public="1" set="null"><x path="js.html.GamepadMappingType"/></mapping>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<buttons public="1" set="null"><c path="Array"><c path="js.html.GamepadButton"/></c></buttons>
		<axes public="1" set="null"><c path="Array"><x path="Float"/></c></axes>
		<timestamp public="1" set="null"><x path="Float"/></timestamp>
		<meta><m n=":native"><e>"Gamepad"</e></m></meta>
	</class>
	<class path="js.html.GamepadButton" params="" file="/usr/lib/haxe/std/js/html/GamepadButton.hx" extern="1">
		<pressed public="1" set="null"><x path="Bool"/></pressed>
		<value public="1" set="null"><x path="Float"/></value>
		<meta><m n=":native"><e>"GamepadButton"</e></m></meta>
	</class>
	<abstract path="js.html.GamepadMappingType" params="" file="/usr/lib/haxe/std/js/html/GamepadMappingType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._GamepadMappingType.GamepadMappingType_Impl_" params="" file="/usr/lib/haxe/std/js/html/GamepadMappingType.hx" private="1" module="js.html.GamepadMappingType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.Geolocation" params="" file="/usr/lib/haxe/std/js/html/Geolocation.hx" extern="1">
		<getCurrentPosition public="1" set="method">
			<f a="successCallback:?errorCallback:?options">
				<f a="">
					<c path="js.html.Position"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="js.html.PositionError"/>
					<x path="Void"/>
				</f>
				<t path="js.html.PositionOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getCurrentPosition>
		<watchPosition public="1" set="method">
			<f a="successCallback:?errorCallback:?options">
				<f a="">
					<c path="js.html.Position"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="js.html.PositionError"/>
					<x path="Void"/>
				</f>
				<t path="js.html.PositionOptions"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</watchPosition>
		<clearWatch public="1" set="method"><f a="watchId">
	<x path="Int"/>
	<x path="Void"/>
</f></clearWatch>
		<meta><m n=":native"><e>"Geolocation"</e></m></meta>
	</class>
	<class path="js.html.HRElement" params="" file="/usr/lib/haxe/std/js/html/HRElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<color public="1"><c path="String"/></color>
		<noShade public="1"><x path="Bool"/></noShade>
		<size public="1"><c path="String"/></size>
		<width public="1"><c path="String"/></width>
		<meta><m n=":native"><e>"HTMLHRElement"</e></m></meta>
	</class>
	<class path="js.html.HTMLAllCollection" params="" file="/usr/lib/haxe/std/js/html/HTMLAllCollection.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Node"/>
					<c path="js.html.HTMLCollection"/>
				</x>
			</f>
			<overloads><item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Node"/>
</f></item></overloads>
		</item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.Node"/>
		<c path="js.html.HTMLCollection"/>
	</x>
</f></namedItem>
		<meta><m n=":native"><e>"HTMLAllCollection"</e></m></meta>
	</class>
	<class path="js.html.HTMLCollection" params="" file="/usr/lib/haxe/std/js/html/HTMLCollection.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Element"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Element"/>
</f></namedItem>
		<meta><m n=":native"><e>"HTMLCollection"</e></m></meta>
	</class>
	<class path="js.html.HTMLDocument" params="" file="/usr/lib/haxe/std/js/html/HTMLDocument.hx" extern="1">
		<extends path="js.html.Document"/>
		<domain public="1"><c path="String"/></domain>
		<cookie public="1"><c path="String"/></cookie>
		<body public="1"><c path="js.html.Element"/></body>
		<head public="1" set="null"><c path="js.html.HeadElement"/></head>
		<images public="1" set="null"><c path="js.html.HTMLCollection"/></images>
		<embeds public="1" set="null"><c path="js.html.HTMLCollection"/></embeds>
		<plugins public="1" set="null"><c path="js.html.HTMLCollection"/></plugins>
		<links public="1" set="null"><c path="js.html.HTMLCollection"/></links>
		<forms public="1" set="null"><c path="js.html.HTMLCollection"/></forms>
		<scripts public="1" set="null"><c path="js.html.HTMLCollection"/></scripts>
		<designMode public="1"><c path="String"/></designMode>
		<fgColor public="1"><c path="String"/></fgColor>
		<linkColor public="1"><c path="String"/></linkColor>
		<vlinkColor public="1"><c path="String"/></vlinkColor>
		<alinkColor public="1"><c path="String"/></alinkColor>
		<bgColor public="1"><c path="String"/></bgColor>
		<anchors public="1" set="null"><c path="js.html.HTMLCollection"/></anchors>
		<applets public="1" set="null"><c path="js.html.HTMLCollection"/></applets>
		<all public="1" set="null"><c path="js.html.HTMLAllCollection"/></all>
		<getElementsByName public="1" set="method"><f a="elementName">
	<c path="String"/>
	<c path="js.html.NodeList"/>
</f></getElementsByName>
		<getItems public="1" set="method">
			<f a="?typeNames" v="&quot;&quot;">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<meta><m n=":value"><e>{typeNames:""}</e></m></meta>
		</getItems>
		<open public="1" set="method">
			<f a="url:name:features:?replace" v=":::false">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="js.html.Window"/>
			</f>
			<meta><m n=":value"><e>{replace:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><open public="1" set="method">
	<f a="?type:?replace" v="&quot;text/html&quot;:&quot;&quot;">
		<c path="String"/>
		<c path="String"/>
		<c path="js.html.HTMLDocument"/>
	</f>
	<meta><m n=":value"><e>{replace:"",type:"text/html"}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</open></overloads>
		</open>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</close>
		<write public="1" set="method">
			<f a="text">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</write>
		<writeln public="1" set="method">
			<f a="text">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</writeln>
		<execCommand public="1" set="method">
			<f a="commandId:?showUI:?value" v=":false:&quot;&quot;">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{value:"",showUI:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</execCommand>
		<queryCommandEnabled public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandEnabled>
		<queryCommandIndeterm public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandIndeterm>
		<queryCommandState public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandState>
		<queryCommandSupported public="1" set="method"><f a="commandId">
	<c path="String"/>
	<x path="Bool"/>
</f></queryCommandSupported>
		<queryCommandValue public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandValue>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<getSelection public="1" set="method">
			<f a=""><c path="js.html.Selection"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getSelection>
		<captureEvents public="1" set="method"><f a=""><x path="Void"/></f></captureEvents>
		<releaseEvents public="1" set="method"><f a=""><x path="Void"/></f></releaseEvents>
		<createTableCellElement public="1" get="inline" set="null" line="78">
			<f a=""><c path="js.html.TableCellElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <td> element.]]></haxe_doc>
		</createTableCellElement>
		<createHRElement public="1" get="inline" set="null" line="80">
			<f a=""><c path="js.html.HRElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <hr> element.]]></haxe_doc>
		</createHRElement>
		<createSelectElement public="1" get="inline" set="null" line="82">
			<f a=""><c path="js.html.SelectElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <select> element.]]></haxe_doc>
		</createSelectElement>
		<createMapElement public="1" get="inline" set="null" line="84">
			<f a=""><c path="js.html.MapElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <map> element.]]></haxe_doc>
		</createMapElement>
		<createFormElement public="1" get="inline" set="null" line="86">
			<f a=""><c path="js.html.FormElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <form> element.]]></haxe_doc>
		</createFormElement>
		<createOptionElement public="1" get="inline" set="null" line="88">
			<f a=""><c path="js.html.OptionElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <option> element.]]></haxe_doc>
		</createOptionElement>
		<createLabelElement public="1" get="inline" set="null" line="90">
			<f a=""><c path="js.html.LabelElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <label> element.]]></haxe_doc>
		</createLabelElement>
		<createMetaElement public="1" get="inline" set="null" line="92">
			<f a=""><c path="js.html.MetaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <meta> element.]]></haxe_doc>
		</createMetaElement>
		<createImageElement public="1" get="inline" set="null" line="94">
			<f a=""><c path="js.html.ImageElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <img> element.]]></haxe_doc>
		</createImageElement>
		<createDListElement public="1" get="inline" set="null" line="96">
			<f a=""><c path="js.html.DListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <dl> element.]]></haxe_doc>
		</createDListElement>
		<createFrameElement public="1" get="inline" set="null" line="98">
			<f a=""><c path="js.html.FrameElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <frame> element.]]></haxe_doc>
		</createFrameElement>
		<createModElement public="1" get="inline" set="null" line="100">
			<f a=""><c path="js.html.ModElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <mod> element.]]></haxe_doc>
		</createModElement>
		<createUListElement public="1" get="inline" set="null" line="102">
			<f a=""><c path="js.html.UListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <ul> element.]]></haxe_doc>
		</createUListElement>
		<createOutputElement public="1" get="inline" set="null" line="104">
			<f a=""><c path="js.html.OutputElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <output> element.]]></haxe_doc>
		</createOutputElement>
		<createOListElement public="1" get="inline" set="null" line="106">
			<f a=""><c path="js.html.OListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <ol> element.]]></haxe_doc>
		</createOListElement>
		<createShadowElement public="1" get="inline" set="null" line="108">
			<f a=""><c path="js.html.ShadowElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <shadow> element.]]></haxe_doc>
		</createShadowElement>
		<createLIElement public="1" get="inline" set="null" line="110">
			<f a=""><c path="js.html.LIElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <li> element.]]></haxe_doc>
		</createLIElement>
		<createDataListElement public="1" get="inline" set="null" line="112">
			<f a=""><c path="js.html.DataListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <datalist> element.]]></haxe_doc>
		</createDataListElement>
		<createParamElement public="1" get="inline" set="null" line="114">
			<f a=""><c path="js.html.ParamElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <param> element.]]></haxe_doc>
		</createParamElement>
		<createFontElement public="1" get="inline" set="null" line="116">
			<f a=""><c path="js.html.FontElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <font> element.]]></haxe_doc>
		</createFontElement>
		<createTrackElement public="1" get="inline" set="null" line="118">
			<f a=""><c path="js.html.TrackElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <track> element.]]></haxe_doc>
		</createTrackElement>
		<createAppletElement public="1" get="inline" set="null" line="120">
			<f a=""><c path="js.html.AppletElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <applet> element.]]></haxe_doc>
		</createAppletElement>
		<createAreaElement public="1" get="inline" set="null" line="122">
			<f a=""><c path="js.html.AreaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <area> element.]]></haxe_doc>
		</createAreaElement>
		<createLinkElement public="1" get="inline" set="null" line="124">
			<f a=""><c path="js.html.LinkElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <link> element.]]></haxe_doc>
		</createLinkElement>
		<createDivElement public="1" get="inline" set="null" line="126">
			<f a=""><c path="js.html.DivElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <div> element.]]></haxe_doc>
		</createDivElement>
		<createTitleElement public="1" get="inline" set="null" line="128">
			<f a=""><c path="js.html.TitleElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <title> element.]]></haxe_doc>
		</createTitleElement>
		<createStyleElement public="1" get="inline" set="null" line="130">
			<f a=""><c path="js.html.StyleElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <style> element.]]></haxe_doc>
		</createStyleElement>
		<createProgressElement public="1" get="inline" set="null" line="132">
			<f a=""><c path="js.html.ProgressElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <progress> element.]]></haxe_doc>
		</createProgressElement>
		<createButtonElement public="1" get="inline" set="null" line="134">
			<f a=""><c path="js.html.ButtonElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <button> element.]]></haxe_doc>
		</createButtonElement>
		<createFieldSetElement public="1" get="inline" set="null" line="136">
			<f a=""><c path="js.html.FieldSetElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <fieldset> element.]]></haxe_doc>
		</createFieldSetElement>
		<createAnchorElement public="1" get="inline" set="null" line="138">
			<f a=""><c path="js.html.AnchorElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <a> element.]]></haxe_doc>
		</createAnchorElement>
		<createIFrameElement public="1" get="inline" set="null" line="140">
			<f a=""><c path="js.html.IFrameElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <iframe> element.]]></haxe_doc>
		</createIFrameElement>
		<createSpanElement public="1" get="inline" set="null" line="142">
			<f a=""><c path="js.html.SpanElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <span> element.]]></haxe_doc>
		</createSpanElement>
		<createBodyElement public="1" get="inline" set="null" line="144">
			<f a=""><c path="js.html.BodyElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <body> element.]]></haxe_doc>
		</createBodyElement>
		<createInputElement public="1" get="inline" set="null" line="146">
			<f a=""><c path="js.html.InputElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <input> element.]]></haxe_doc>
		</createInputElement>
		<createEmbedElement public="1" get="inline" set="null" line="148">
			<f a=""><c path="js.html.EmbedElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <embed> element.]]></haxe_doc>
		</createEmbedElement>
		<createMeterElement public="1" get="inline" set="null" line="150">
			<f a=""><c path="js.html.MeterElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <meter> element.]]></haxe_doc>
		</createMeterElement>
		<createPictureElement public="1" get="inline" set="null" line="152">
			<f a=""><c path="js.html.PictureElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <picture> element.]]></haxe_doc>
		</createPictureElement>
		<createPreElement public="1" get="inline" set="null" line="154">
			<f a=""><c path="js.html.PreElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <pre> element.]]></haxe_doc>
		</createPreElement>
		<createTableSectionElement public="1" get="inline" set="null" line="156">
			<f a=""><c path="js.html.TableSectionElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <thead> element.]]></haxe_doc>
		</createTableSectionElement>
		<createHeadElement public="1" get="inline" set="null" line="158">
			<f a=""><c path="js.html.HeadElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <head> element.]]></haxe_doc>
		</createHeadElement>
		<createBaseElement public="1" get="inline" set="null" line="160">
			<f a=""><c path="js.html.BaseElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <base> element.]]></haxe_doc>
		</createBaseElement>
		<createOptGroupElement public="1" get="inline" set="null" line="162">
			<f a=""><c path="js.html.OptGroupElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <optgroup> element.]]></haxe_doc>
		</createOptGroupElement>
		<createQuoteElement public="1" get="inline" set="null" line="164">
			<f a=""><c path="js.html.QuoteElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <quote> element.]]></haxe_doc>
		</createQuoteElement>
		<createAudioElement public="1" get="inline" set="null" line="166">
			<f a=""><c path="js.html.AudioElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <audio> element.]]></haxe_doc>
		</createAudioElement>
		<createVideoElement public="1" get="inline" set="null" line="168">
			<f a=""><c path="js.html.VideoElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <video> element.]]></haxe_doc>
		</createVideoElement>
		<createLegendElement public="1" get="inline" set="null" line="170">
			<f a=""><c path="js.html.LegendElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <legend> element.]]></haxe_doc>
		</createLegendElement>
		<createMenuElement public="1" get="inline" set="null" line="172">
			<f a=""><c path="js.html.MenuElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <menu> element.]]></haxe_doc>
		</createMenuElement>
		<createFrameSetElement public="1" get="inline" set="null" line="174">
			<f a=""><c path="js.html.FrameSetElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <frameset> element.]]></haxe_doc>
		</createFrameSetElement>
		<createCanvasElement public="1" get="inline" set="null" line="176">
			<f a=""><c path="js.html.CanvasElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <canvas> element.]]></haxe_doc>
		</createCanvasElement>
		<createParagraphElement public="1" get="inline" set="null" line="178">
			<f a=""><c path="js.html.ParagraphElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <p> element.]]></haxe_doc>
		</createParagraphElement>
		<createTableColElement public="1" get="inline" set="null" line="180">
			<f a=""><c path="js.html.TableColElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <col> element.]]></haxe_doc>
		</createTableColElement>
		<createDirectoryElement public="1" get="inline" set="null" line="182">
			<f a=""><c path="js.html.DirectoryElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <dir> element.]]></haxe_doc>
		</createDirectoryElement>
		<createTableElement public="1" get="inline" set="null" line="184">
			<f a=""><c path="js.html.TableElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <table> element.]]></haxe_doc>
		</createTableElement>
		<createTableRowElement public="1" get="inline" set="null" line="186">
			<f a=""><c path="js.html.TableRowElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <tr> element.]]></haxe_doc>
		</createTableRowElement>
		<createScriptElement public="1" get="inline" set="null" line="188">
			<f a=""><c path="js.html.ScriptElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <script> element.]]></haxe_doc>
		</createScriptElement>
		<createSourceElement public="1" get="inline" set="null" line="190">
			<f a=""><c path="js.html.SourceElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <source> element.]]></haxe_doc>
		</createSourceElement>
		<createContentElement public="1" get="inline" set="null" line="192">
			<f a=""><c path="js.html.ContentElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <content> element.]]></haxe_doc>
		</createContentElement>
		<createBRElement public="1" get="inline" set="null" line="194">
			<f a=""><c path="js.html.BRElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <br> element.]]></haxe_doc>
		</createBRElement>
		<createHtmlElement public="1" get="inline" set="null" line="196">
			<f a=""><c path="js.html.HtmlElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <html> element.]]></haxe_doc>
		</createHtmlElement>
		<createTextAreaElement public="1" get="inline" set="null" line="198">
			<f a=""><c path="js.html.TextAreaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <textarea> element.]]></haxe_doc>
		</createTextAreaElement>
		<createMediaElement public="1" get="inline" set="null" line="200">
			<f a=""><c path="js.html.MediaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <media> element.]]></haxe_doc>
		</createMediaElement>
		<createObjectElement public="1" get="inline" set="null" line="202">
			<f a=""><c path="js.html.ObjectElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <object> element.]]></haxe_doc>
		</createObjectElement>
		<createTableCaptionElement public="1" get="inline" set="null" line="204">
			<f a=""><c path="js.html.TableCaptionElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <caption> element.]]></haxe_doc>
		</createTableCaptionElement>
		<meta><m n=":native"><e>"HTMLDocument"</e></m></meta>
	</class>
	<class path="js.html.HTMLOptionsCollection" params="" file="/usr/lib/haxe/std/js/html/HTMLOptionsCollection.hx" extern="1">
		<extends path="js.html.HTMLCollection"/>
		<selectedIndex public="1"><x path="Int"/></selectedIndex>
		<add public="1" set="method">
			<f a="element:?before">
				<x path="haxe.extern.EitherType">
					<c path="js.html.OptionElement"/>
					<c path="js.html.OptGroupElement"/>
				</x>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Element"/>
					<x path="Int"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<remove public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</remove>
		<meta><m n=":native"><e>"HTMLOptionsCollection"</e></m></meta>
	</class>
	<class path="js.html.HTMLPropertiesCollection" params="" file="/usr/lib/haxe/std/js/html/HTMLPropertiesCollection.hx" extern="1">
		<extends path="js.html.HTMLCollection"/>
		<names public="1" set="null"><c path="js.html.DOMStringList"/></names>
		<meta><m n=":native"><e>"HTMLPropertiesCollection"</e></m></meta>
	</class>
	<class path="js.html.HeadElement" params="" file="/usr/lib/haxe/std/js/html/HeadElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<meta><m n=":native"><e>"HTMLHeadElement"</e></m></meta>
	</class>
	<class path="js.html.History" params="" file="/usr/lib/haxe/std/js/html/History.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<state public="1" set="null"><d/></state>
		<go public="1" set="method">
			<f a="?delta" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{delta:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</go>
		<back public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</back>
		<forward public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</forward>
		<pushState public="1" set="method">
			<f a="data:title:?url">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</pushState>
		<replaceState public="1" set="method">
			<f a="data:title:?url">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replaceState>
		<meta><m n=":native"><e>"History"</e></m></meta>
	</class>
	<typedef path="js.html.HitRegionOptions" params="" file="/usr/lib/haxe/std/js/html/HitRegionOptions.hx"><a>
	<id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</id>
	<control>
		<t path="Null"><c path="js.html.Element"/></t>
		<meta><m n=":optional"/></meta>
	</control>
</a></typedef>
	<class path="js.html.HtmlElement" params="" file="/usr/lib/haxe/std/js/html/HtmlElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<version public="1"><c path="String"/></version>
		<meta><m n=":native"><e>"HTMLHtmlElement"</e></m></meta>
	</class>
	<class path="js.html.IFrameElement" params="" file="/usr/lib/haxe/std/js/html/IFrameElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<srcdoc public="1"><c path="String"/></srcdoc>
		<name public="1"><c path="String"/></name>
		<sandbox public="1" set="null"><c path="js.html.DOMSettableTokenList"/></sandbox>
		<allowFullscreen public="1"><x path="Bool"/></allowFullscreen>
		<width public="1"><c path="String"/></width>
		<height public="1"><c path="String"/></height>
		<contentDocument public="1" set="null"><c path="js.html.HTMLDocument"/></contentDocument>
		<contentWindow public="1" set="null"><c path="js.html.Window"/></contentWindow>
		<align public="1"><c path="String"/></align>
		<scrolling public="1"><c path="String"/></scrolling>
		<frameBorder public="1"><c path="String"/></frameBorder>
		<longDesc public="1"><c path="String"/></longDesc>
		<marginHeight public="1"><c path="String"/></marginHeight>
		<marginWidth public="1"><c path="String"/></marginWidth>
		<getSVGDocument public="1" set="method"><f a=""><c path="js.html.HTMLDocument"/></f></getSVGDocument>
		<meta><m n=":native"><e>"HTMLIFrameElement"</e></m></meta>
	</class>
	<class path="js.html.ImageData" params="" file="/usr/lib/haxe/std/js/html/ImageData.hx" extern="1">
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<data public="1" set="null"><c path="js.html.Uint8ClampedArray"/></data>
		<new public="1" set="method">
			<f a="data:sw:?sh">
				<c path="js.html.Uint8ClampedArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="sw:sh">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"ImageData"</e></m></meta>
	</class>
	<class path="js.html.ImageElement" params="" file="/usr/lib/haxe/std/js/html/ImageElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<alt public="1"><c path="String"/></alt>
		<src public="1"><c path="String"/></src>
		<srcset public="1"><c path="String"/></srcset>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<useMap public="1"><c path="String"/></useMap>
		<isMap public="1"><x path="Bool"/></isMap>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<naturalWidth public="1" set="null"><x path="Int"/></naturalWidth>
		<naturalHeight public="1" set="null"><x path="Int"/></naturalHeight>
		<complete public="1" set="null"><x path="Bool"/></complete>
		<name public="1"><c path="String"/></name>
		<align public="1"><c path="String"/></align>
		<hspace public="1"><x path="Int"/></hspace>
		<vspace public="1"><x path="Int"/></vspace>
		<longDesc public="1"><c path="String"/></longDesc>
		<border public="1"><c path="String"/></border>
		<sizes public="1"><c path="String"/></sizes>
		<currentSrc public="1" set="null"><c path="String"/></currentSrc>
		<lowsrc public="1"><c path="String"/></lowsrc>
		<x public="1" set="null"><x path="Int"/></x>
		<y public="1" set="null"><x path="Int"/></y>
		<meta><m n=":native"><e>"HTMLImageElement"</e></m></meta>
	</class>
	<class path="js.html.InputElement" params="" file="/usr/lib/haxe/std/js/html/InputElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<accept public="1"><c path="String"/></accept>
		<alt public="1"><c path="String"/></alt>
		<autocomplete public="1"><c path="String"/></autocomplete>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<defaultChecked public="1"><x path="Bool"/></defaultChecked>
		<checked public="1"><x path="Bool"/></checked>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<files public="1" set="null"><c path="js.html.FileList"/></files>
		<formAction public="1"><c path="String"/></formAction>
		<formEnctype public="1"><c path="String"/></formEnctype>
		<formMethod public="1"><c path="String"/></formMethod>
		<formNoValidate public="1"><x path="Bool"/></formNoValidate>
		<formTarget public="1"><c path="String"/></formTarget>
		<height public="1"><x path="Int"/></height>
		<indeterminate public="1"><x path="Bool"/></indeterminate>
		<list public="1" set="null"><c path="js.html.Element"/></list>
		<max public="1"><c path="String"/></max>
		<maxLength public="1"><x path="Int"/></maxLength>
		<min public="1"><c path="String"/></min>
		<multiple public="1"><x path="Bool"/></multiple>
		<name public="1"><c path="String"/></name>
		<pattern public="1"><c path="String"/></pattern>
		<placeholder public="1"><c path="String"/></placeholder>
		<readOnly public="1"><x path="Bool"/></readOnly>
		<required public="1"><x path="Bool"/></required>
		<size public="1"><x path="Int"/></size>
		<src public="1"><c path="String"/></src>
		<step public="1"><c path="String"/></step>
		<type public="1"><c path="String"/></type>
		<defaultValue public="1"><c path="String"/></defaultValue>
		<value public="1"><c path="String"/></value>
		<valueAsNumber public="1"><x path="Float"/></valueAsNumber>
		<width public="1"><x path="Int"/></width>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<selectionStart public="1"><x path="Int"/></selectionStart>
		<selectionEnd public="1"><x path="Int"/></selectionEnd>
		<selectionDirection public="1"><c path="String"/></selectionDirection>
		<align public="1"><c path="String"/></align>
		<useMap public="1"><c path="String"/></useMap>
		<textLength public="1" set="null"><x path="Int"/></textLength>
		<stepUp public="1" set="method">
			<f a="?n" v="1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{n:1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stepUp>
		<stepDown public="1" set="method">
			<f a="?n" v="1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{n:1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stepDown>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<select public="1" set="method"><f a=""><x path="Void"/></f></select>
		<setRangeText public="1" set="method">
			<f a="replacement:start:end:?selectionMode" v=":::&quot;preserve&quot;">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="js.html.SelectionMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{selectionMode:"preserve"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setRangeText public="1" set="method">
	<f a="replacement">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</setRangeText></overloads>
		</setRangeText>
		<setSelectionRange public="1" set="method">
			<f a="start:end:?direction">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setSelectionRange>
		<meta><m n=":native"><e>"HTMLInputElement"</e></m></meta>
	</class>
	<class path="js.html.Int32Array" params="" file="/usr/lib/haxe/std/js/html/Int32Array.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
				<set public="1" set="method"><f a="array:?offset">
	<c path="js.html.Int32Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
			</overloads>
		</set>
		<subarray public="1" set="method"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.Int32Array"/>
</f></subarray>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="js.html.Int32Array"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Int"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Int32Array"</e></m></meta>
	</class>
	<class path="js.html.UIEvent" params="" file="/usr/lib/haxe/std/js/html/UIEvent.hx" extern="1">
		<extends path="js.html.Event"/>
		<SCROLL_PAGE_UP public="1" get="inline" set="null" expr="-32768" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-32768</e></m></meta>
		</SCROLL_PAGE_UP>
		<SCROLL_PAGE_DOWN public="1" get="inline" set="null" expr="32768" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32768</e></m></meta>
		</SCROLL_PAGE_DOWN>
		<view public="1" set="null"><c path="js.html.Window"/></view>
		<detail public="1" set="null"><x path="Int"/></detail>
		<layerX public="1" set="null"><x path="Int"/></layerX>
		<layerY public="1" set="null"><x path="Int"/></layerY>
		<pageX public="1" set="null"><x path="Int"/></pageX>
		<pageY public="1" set="null"><x path="Int"/></pageY>
		<which public="1" set="null"><x path="Int"/></which>
		<rangeParent public="1" set="null"><c path="js.html.Node"/></rangeParent>
		<rangeOffset public="1" set="null"><x path="Int"/></rangeOffset>
		<cancelBubble public="1"><x path="Bool"/></cancelBubble>
		<isChar public="1" set="null"><x path="Bool"/></isChar>
		<initUIEvent public="1" set="method"><f a="aType:aCanBubble:aCancelable:aView:aDetail">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="js.html.Window"/>
	<x path="Int"/>
	<x path="Void"/>
</f></initUIEvent>
		<new public="1" set="method">
			<f a="type:?eventInitDict">
				<c path="String"/>
				<t path="js.html.UIEventInit"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"UIEvent"</e></m></meta>
	</class>
	<class path="js.html.KeyboardEvent" params="" file="/usr/lib/haxe/std/js/html/KeyboardEvent.hx" extern="1">
		<extends path="js.html.UIEvent"/>
		<DOM_KEY_LOCATION_STANDARD public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</DOM_KEY_LOCATION_STANDARD>
		<DOM_KEY_LOCATION_LEFT public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</DOM_KEY_LOCATION_LEFT>
		<DOM_KEY_LOCATION_RIGHT public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</DOM_KEY_LOCATION_RIGHT>
		<DOM_KEY_LOCATION_NUMPAD public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</DOM_KEY_LOCATION_NUMPAD>
		<DOM_KEY_LOCATION_MOBILE public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</DOM_KEY_LOCATION_MOBILE>
		<DOM_KEY_LOCATION_JOYSTICK public="1" get="inline" set="null" expr="5" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</DOM_KEY_LOCATION_JOYSTICK>
		<DOM_VK_CANCEL public="1" get="inline" set="null" expr="3" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</DOM_VK_CANCEL>
		<DOM_VK_HELP public="1" get="inline" set="null" expr="6" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</DOM_VK_HELP>
		<DOM_VK_BACK_SPACE public="1" get="inline" set="null" expr="8" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</DOM_VK_BACK_SPACE>
		<DOM_VK_TAB public="1" get="inline" set="null" expr="9" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</DOM_VK_TAB>
		<DOM_VK_CLEAR public="1" get="inline" set="null" expr="12" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</DOM_VK_CLEAR>
		<DOM_VK_RETURN public="1" get="inline" set="null" expr="13" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</DOM_VK_RETURN>
		<DOM_VK_SHIFT public="1" get="inline" set="null" expr="16" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</DOM_VK_SHIFT>
		<DOM_VK_CONTROL public="1" get="inline" set="null" expr="17" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</DOM_VK_CONTROL>
		<DOM_VK_ALT public="1" get="inline" set="null" expr="18" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</DOM_VK_ALT>
		<DOM_VK_PAUSE public="1" get="inline" set="null" expr="19" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</DOM_VK_PAUSE>
		<DOM_VK_CAPS_LOCK public="1" get="inline" set="null" expr="20" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</DOM_VK_CAPS_LOCK>
		<DOM_VK_KANA public="1" get="inline" set="null" expr="21" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>21</e></m></meta>
		</DOM_VK_KANA>
		<DOM_VK_HANGUL public="1" get="inline" set="null" expr="21" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>21</e></m></meta>
		</DOM_VK_HANGUL>
		<DOM_VK_EISU public="1" get="inline" set="null" expr="22" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>22</e></m></meta>
		</DOM_VK_EISU>
		<DOM_VK_JUNJA public="1" get="inline" set="null" expr="23" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>23</e></m></meta>
		</DOM_VK_JUNJA>
		<DOM_VK_FINAL public="1" get="inline" set="null" expr="24" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>24</e></m></meta>
		</DOM_VK_FINAL>
		<DOM_VK_HANJA public="1" get="inline" set="null" expr="25" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</DOM_VK_HANJA>
		<DOM_VK_KANJI public="1" get="inline" set="null" expr="25" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</DOM_VK_KANJI>
		<DOM_VK_ESCAPE public="1" get="inline" set="null" expr="27" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>27</e></m></meta>
		</DOM_VK_ESCAPE>
		<DOM_VK_CONVERT public="1" get="inline" set="null" expr="28" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>28</e></m></meta>
		</DOM_VK_CONVERT>
		<DOM_VK_NONCONVERT public="1" get="inline" set="null" expr="29" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>29</e></m></meta>
		</DOM_VK_NONCONVERT>
		<DOM_VK_ACCEPT public="1" get="inline" set="null" expr="30" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</DOM_VK_ACCEPT>
		<DOM_VK_MODECHANGE public="1" get="inline" set="null" expr="31" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>31</e></m></meta>
		</DOM_VK_MODECHANGE>
		<DOM_VK_SPACE public="1" get="inline" set="null" expr="32" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</DOM_VK_SPACE>
		<DOM_VK_PAGE_UP public="1" get="inline" set="null" expr="33" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33</e></m></meta>
		</DOM_VK_PAGE_UP>
		<DOM_VK_PAGE_DOWN public="1" get="inline" set="null" expr="34" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34</e></m></meta>
		</DOM_VK_PAGE_DOWN>
		<DOM_VK_END public="1" get="inline" set="null" expr="35" line="62" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35</e></m></meta>
		</DOM_VK_END>
		<DOM_VK_HOME public="1" get="inline" set="null" expr="36" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36</e></m></meta>
		</DOM_VK_HOME>
		<DOM_VK_LEFT public="1" get="inline" set="null" expr="37" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37</e></m></meta>
		</DOM_VK_LEFT>
		<DOM_VK_UP public="1" get="inline" set="null" expr="38" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>38</e></m></meta>
		</DOM_VK_UP>
		<DOM_VK_RIGHT public="1" get="inline" set="null" expr="39" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>39</e></m></meta>
		</DOM_VK_RIGHT>
		<DOM_VK_DOWN public="1" get="inline" set="null" expr="40" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>40</e></m></meta>
		</DOM_VK_DOWN>
		<DOM_VK_SELECT public="1" get="inline" set="null" expr="41" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>41</e></m></meta>
		</DOM_VK_SELECT>
		<DOM_VK_PRINT public="1" get="inline" set="null" expr="42" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>42</e></m></meta>
		</DOM_VK_PRINT>
		<DOM_VK_EXECUTE public="1" get="inline" set="null" expr="43" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>43</e></m></meta>
		</DOM_VK_EXECUTE>
		<DOM_VK_PRINTSCREEN public="1" get="inline" set="null" expr="44" line="71" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>44</e></m></meta>
		</DOM_VK_PRINTSCREEN>
		<DOM_VK_INSERT public="1" get="inline" set="null" expr="45" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>45</e></m></meta>
		</DOM_VK_INSERT>
		<DOM_VK_DELETE public="1" get="inline" set="null" expr="46" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>46</e></m></meta>
		</DOM_VK_DELETE>
		<DOM_VK_0 public="1" get="inline" set="null" expr="48" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>48</e></m></meta>
		</DOM_VK_0>
		<DOM_VK_1 public="1" get="inline" set="null" expr="49" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>49</e></m></meta>
		</DOM_VK_1>
		<DOM_VK_2 public="1" get="inline" set="null" expr="50" line="76" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>50</e></m></meta>
		</DOM_VK_2>
		<DOM_VK_3 public="1" get="inline" set="null" expr="51" line="77" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>51</e></m></meta>
		</DOM_VK_3>
		<DOM_VK_4 public="1" get="inline" set="null" expr="52" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>52</e></m></meta>
		</DOM_VK_4>
		<DOM_VK_5 public="1" get="inline" set="null" expr="53" line="79" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>53</e></m></meta>
		</DOM_VK_5>
		<DOM_VK_6 public="1" get="inline" set="null" expr="54" line="80" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>54</e></m></meta>
		</DOM_VK_6>
		<DOM_VK_7 public="1" get="inline" set="null" expr="55" line="81" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>55</e></m></meta>
		</DOM_VK_7>
		<DOM_VK_8 public="1" get="inline" set="null" expr="56" line="82" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>56</e></m></meta>
		</DOM_VK_8>
		<DOM_VK_9 public="1" get="inline" set="null" expr="57" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>57</e></m></meta>
		</DOM_VK_9>
		<DOM_VK_COLON public="1" get="inline" set="null" expr="58" line="84" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>58</e></m></meta>
		</DOM_VK_COLON>
		<DOM_VK_SEMICOLON public="1" get="inline" set="null" expr="59" line="85" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>59</e></m></meta>
		</DOM_VK_SEMICOLON>
		<DOM_VK_LESS_THAN public="1" get="inline" set="null" expr="60" line="86" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>60</e></m></meta>
		</DOM_VK_LESS_THAN>
		<DOM_VK_EQUALS public="1" get="inline" set="null" expr="61" line="87" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>61</e></m></meta>
		</DOM_VK_EQUALS>
		<DOM_VK_GREATER_THAN public="1" get="inline" set="null" expr="62" line="88" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>62</e></m></meta>
		</DOM_VK_GREATER_THAN>
		<DOM_VK_QUESTION_MARK public="1" get="inline" set="null" expr="63" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>63</e></m></meta>
		</DOM_VK_QUESTION_MARK>
		<DOM_VK_AT public="1" get="inline" set="null" expr="64" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>64</e></m></meta>
		</DOM_VK_AT>
		<DOM_VK_A public="1" get="inline" set="null" expr="65" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65</e></m></meta>
		</DOM_VK_A>
		<DOM_VK_B public="1" get="inline" set="null" expr="66" line="92" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>66</e></m></meta>
		</DOM_VK_B>
		<DOM_VK_C public="1" get="inline" set="null" expr="67" line="93" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>67</e></m></meta>
		</DOM_VK_C>
		<DOM_VK_D public="1" get="inline" set="null" expr="68" line="94" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>68</e></m></meta>
		</DOM_VK_D>
		<DOM_VK_E public="1" get="inline" set="null" expr="69" line="95" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>69</e></m></meta>
		</DOM_VK_E>
		<DOM_VK_F public="1" get="inline" set="null" expr="70" line="96" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>70</e></m></meta>
		</DOM_VK_F>
		<DOM_VK_G public="1" get="inline" set="null" expr="71" line="97" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>71</e></m></meta>
		</DOM_VK_G>
		<DOM_VK_H public="1" get="inline" set="null" expr="72" line="98" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>72</e></m></meta>
		</DOM_VK_H>
		<DOM_VK_I public="1" get="inline" set="null" expr="73" line="99" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>73</e></m></meta>
		</DOM_VK_I>
		<DOM_VK_J public="1" get="inline" set="null" expr="74" line="100" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>74</e></m></meta>
		</DOM_VK_J>
		<DOM_VK_K public="1" get="inline" set="null" expr="75" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>75</e></m></meta>
		</DOM_VK_K>
		<DOM_VK_L public="1" get="inline" set="null" expr="76" line="102" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>76</e></m></meta>
		</DOM_VK_L>
		<DOM_VK_M public="1" get="inline" set="null" expr="77" line="103" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>77</e></m></meta>
		</DOM_VK_M>
		<DOM_VK_N public="1" get="inline" set="null" expr="78" line="104" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>78</e></m></meta>
		</DOM_VK_N>
		<DOM_VK_O public="1" get="inline" set="null" expr="79" line="105" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>79</e></m></meta>
		</DOM_VK_O>
		<DOM_VK_P public="1" get="inline" set="null" expr="80" line="106" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>80</e></m></meta>
		</DOM_VK_P>
		<DOM_VK_Q public="1" get="inline" set="null" expr="81" line="107" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>81</e></m></meta>
		</DOM_VK_Q>
		<DOM_VK_R public="1" get="inline" set="null" expr="82" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>82</e></m></meta>
		</DOM_VK_R>
		<DOM_VK_S public="1" get="inline" set="null" expr="83" line="109" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>83</e></m></meta>
		</DOM_VK_S>
		<DOM_VK_T public="1" get="inline" set="null" expr="84" line="110" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>84</e></m></meta>
		</DOM_VK_T>
		<DOM_VK_U public="1" get="inline" set="null" expr="85" line="111" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>85</e></m></meta>
		</DOM_VK_U>
		<DOM_VK_V public="1" get="inline" set="null" expr="86" line="112" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>86</e></m></meta>
		</DOM_VK_V>
		<DOM_VK_W public="1" get="inline" set="null" expr="87" line="113" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>87</e></m></meta>
		</DOM_VK_W>
		<DOM_VK_X public="1" get="inline" set="null" expr="88" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>88</e></m></meta>
		</DOM_VK_X>
		<DOM_VK_Y public="1" get="inline" set="null" expr="89" line="115" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>89</e></m></meta>
		</DOM_VK_Y>
		<DOM_VK_Z public="1" get="inline" set="null" expr="90" line="116" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>90</e></m></meta>
		</DOM_VK_Z>
		<DOM_VK_WIN public="1" get="inline" set="null" expr="91" line="117" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>91</e></m></meta>
		</DOM_VK_WIN>
		<DOM_VK_CONTEXT_MENU public="1" get="inline" set="null" expr="93" line="118" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>93</e></m></meta>
		</DOM_VK_CONTEXT_MENU>
		<DOM_VK_SLEEP public="1" get="inline" set="null" expr="95" line="119" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>95</e></m></meta>
		</DOM_VK_SLEEP>
		<DOM_VK_NUMPAD0 public="1" get="inline" set="null" expr="96" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>96</e></m></meta>
		</DOM_VK_NUMPAD0>
		<DOM_VK_NUMPAD1 public="1" get="inline" set="null" expr="97" line="121" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>97</e></m></meta>
		</DOM_VK_NUMPAD1>
		<DOM_VK_NUMPAD2 public="1" get="inline" set="null" expr="98" line="122" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>98</e></m></meta>
		</DOM_VK_NUMPAD2>
		<DOM_VK_NUMPAD3 public="1" get="inline" set="null" expr="99" line="123" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>99</e></m></meta>
		</DOM_VK_NUMPAD3>
		<DOM_VK_NUMPAD4 public="1" get="inline" set="null" expr="100" line="124" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>100</e></m></meta>
		</DOM_VK_NUMPAD4>
		<DOM_VK_NUMPAD5 public="1" get="inline" set="null" expr="101" line="125" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>101</e></m></meta>
		</DOM_VK_NUMPAD5>
		<DOM_VK_NUMPAD6 public="1" get="inline" set="null" expr="102" line="126" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>102</e></m></meta>
		</DOM_VK_NUMPAD6>
		<DOM_VK_NUMPAD7 public="1" get="inline" set="null" expr="103" line="127" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>103</e></m></meta>
		</DOM_VK_NUMPAD7>
		<DOM_VK_NUMPAD8 public="1" get="inline" set="null" expr="104" line="128" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>104</e></m></meta>
		</DOM_VK_NUMPAD8>
		<DOM_VK_NUMPAD9 public="1" get="inline" set="null" expr="105" line="129" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>105</e></m></meta>
		</DOM_VK_NUMPAD9>
		<DOM_VK_MULTIPLY public="1" get="inline" set="null" expr="106" line="130" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>106</e></m></meta>
		</DOM_VK_MULTIPLY>
		<DOM_VK_ADD public="1" get="inline" set="null" expr="107" line="131" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>107</e></m></meta>
		</DOM_VK_ADD>
		<DOM_VK_SEPARATOR public="1" get="inline" set="null" expr="108" line="132" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>108</e></m></meta>
		</DOM_VK_SEPARATOR>
		<DOM_VK_SUBTRACT public="1" get="inline" set="null" expr="109" line="133" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>109</e></m></meta>
		</DOM_VK_SUBTRACT>
		<DOM_VK_DECIMAL public="1" get="inline" set="null" expr="110" line="134" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>110</e></m></meta>
		</DOM_VK_DECIMAL>
		<DOM_VK_DIVIDE public="1" get="inline" set="null" expr="111" line="135" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>111</e></m></meta>
		</DOM_VK_DIVIDE>
		<DOM_VK_F1 public="1" get="inline" set="null" expr="112" line="136" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>112</e></m></meta>
		</DOM_VK_F1>
		<DOM_VK_F2 public="1" get="inline" set="null" expr="113" line="137" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>113</e></m></meta>
		</DOM_VK_F2>
		<DOM_VK_F3 public="1" get="inline" set="null" expr="114" line="138" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>114</e></m></meta>
		</DOM_VK_F3>
		<DOM_VK_F4 public="1" get="inline" set="null" expr="115" line="139" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>115</e></m></meta>
		</DOM_VK_F4>
		<DOM_VK_F5 public="1" get="inline" set="null" expr="116" line="140" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>116</e></m></meta>
		</DOM_VK_F5>
		<DOM_VK_F6 public="1" get="inline" set="null" expr="117" line="141" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>117</e></m></meta>
		</DOM_VK_F6>
		<DOM_VK_F7 public="1" get="inline" set="null" expr="118" line="142" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>118</e></m></meta>
		</DOM_VK_F7>
		<DOM_VK_F8 public="1" get="inline" set="null" expr="119" line="143" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>119</e></m></meta>
		</DOM_VK_F8>
		<DOM_VK_F9 public="1" get="inline" set="null" expr="120" line="144" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</DOM_VK_F9>
		<DOM_VK_F10 public="1" get="inline" set="null" expr="121" line="145" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>121</e></m></meta>
		</DOM_VK_F10>
		<DOM_VK_F11 public="1" get="inline" set="null" expr="122" line="146" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>122</e></m></meta>
		</DOM_VK_F11>
		<DOM_VK_F12 public="1" get="inline" set="null" expr="123" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>123</e></m></meta>
		</DOM_VK_F12>
		<DOM_VK_F13 public="1" get="inline" set="null" expr="124" line="148" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>124</e></m></meta>
		</DOM_VK_F13>
		<DOM_VK_F14 public="1" get="inline" set="null" expr="125" line="149" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>125</e></m></meta>
		</DOM_VK_F14>
		<DOM_VK_F15 public="1" get="inline" set="null" expr="126" line="150" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>126</e></m></meta>
		</DOM_VK_F15>
		<DOM_VK_F16 public="1" get="inline" set="null" expr="127" line="151" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>127</e></m></meta>
		</DOM_VK_F16>
		<DOM_VK_F17 public="1" get="inline" set="null" expr="128" line="152" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
		</DOM_VK_F17>
		<DOM_VK_F18 public="1" get="inline" set="null" expr="129" line="153" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>129</e></m></meta>
		</DOM_VK_F18>
		<DOM_VK_F19 public="1" get="inline" set="null" expr="130" line="154" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>130</e></m></meta>
		</DOM_VK_F19>
		<DOM_VK_F20 public="1" get="inline" set="null" expr="131" line="155" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>131</e></m></meta>
		</DOM_VK_F20>
		<DOM_VK_F21 public="1" get="inline" set="null" expr="132" line="156" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>132</e></m></meta>
		</DOM_VK_F21>
		<DOM_VK_F22 public="1" get="inline" set="null" expr="133" line="157" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>133</e></m></meta>
		</DOM_VK_F22>
		<DOM_VK_F23 public="1" get="inline" set="null" expr="134" line="158" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>134</e></m></meta>
		</DOM_VK_F23>
		<DOM_VK_F24 public="1" get="inline" set="null" expr="135" line="159" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>135</e></m></meta>
		</DOM_VK_F24>
		<DOM_VK_NUM_LOCK public="1" get="inline" set="null" expr="144" line="160" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>144</e></m></meta>
		</DOM_VK_NUM_LOCK>
		<DOM_VK_SCROLL_LOCK public="1" get="inline" set="null" expr="145" line="161" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>145</e></m></meta>
		</DOM_VK_SCROLL_LOCK>
		<DOM_VK_WIN_OEM_FJ_JISHO public="1" get="inline" set="null" expr="146" line="162" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>146</e></m></meta>
		</DOM_VK_WIN_OEM_FJ_JISHO>
		<DOM_VK_WIN_OEM_FJ_MASSHOU public="1" get="inline" set="null" expr="147" line="163" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>147</e></m></meta>
		</DOM_VK_WIN_OEM_FJ_MASSHOU>
		<DOM_VK_WIN_OEM_FJ_TOUROKU public="1" get="inline" set="null" expr="148" line="164" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>148</e></m></meta>
		</DOM_VK_WIN_OEM_FJ_TOUROKU>
		<DOM_VK_WIN_OEM_FJ_LOYA public="1" get="inline" set="null" expr="149" line="165" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>149</e></m></meta>
		</DOM_VK_WIN_OEM_FJ_LOYA>
		<DOM_VK_WIN_OEM_FJ_ROYA public="1" get="inline" set="null" expr="150" line="166" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>150</e></m></meta>
		</DOM_VK_WIN_OEM_FJ_ROYA>
		<DOM_VK_CIRCUMFLEX public="1" get="inline" set="null" expr="160" line="167" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>160</e></m></meta>
		</DOM_VK_CIRCUMFLEX>
		<DOM_VK_EXCLAMATION public="1" get="inline" set="null" expr="161" line="168" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>161</e></m></meta>
		</DOM_VK_EXCLAMATION>
		<DOM_VK_DOUBLE_QUOTE public="1" get="inline" set="null" expr="162" line="169" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>162</e></m></meta>
		</DOM_VK_DOUBLE_QUOTE>
		<DOM_VK_HASH public="1" get="inline" set="null" expr="163" line="170" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>163</e></m></meta>
		</DOM_VK_HASH>
		<DOM_VK_DOLLAR public="1" get="inline" set="null" expr="164" line="171" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>164</e></m></meta>
		</DOM_VK_DOLLAR>
		<DOM_VK_PERCENT public="1" get="inline" set="null" expr="165" line="172" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>165</e></m></meta>
		</DOM_VK_PERCENT>
		<DOM_VK_AMPERSAND public="1" get="inline" set="null" expr="166" line="173" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>166</e></m></meta>
		</DOM_VK_AMPERSAND>
		<DOM_VK_UNDERSCORE public="1" get="inline" set="null" expr="167" line="174" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>167</e></m></meta>
		</DOM_VK_UNDERSCORE>
		<DOM_VK_OPEN_PAREN public="1" get="inline" set="null" expr="168" line="175" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>168</e></m></meta>
		</DOM_VK_OPEN_PAREN>
		<DOM_VK_CLOSE_PAREN public="1" get="inline" set="null" expr="169" line="176" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>169</e></m></meta>
		</DOM_VK_CLOSE_PAREN>
		<DOM_VK_ASTERISK public="1" get="inline" set="null" expr="170" line="177" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>170</e></m></meta>
		</DOM_VK_ASTERISK>
		<DOM_VK_PLUS public="1" get="inline" set="null" expr="171" line="178" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>171</e></m></meta>
		</DOM_VK_PLUS>
		<DOM_VK_PIPE public="1" get="inline" set="null" expr="172" line="179" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>172</e></m></meta>
		</DOM_VK_PIPE>
		<DOM_VK_HYPHEN_MINUS public="1" get="inline" set="null" expr="173" line="180" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>173</e></m></meta>
		</DOM_VK_HYPHEN_MINUS>
		<DOM_VK_OPEN_CURLY_BRACKET public="1" get="inline" set="null" expr="174" line="181" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>174</e></m></meta>
		</DOM_VK_OPEN_CURLY_BRACKET>
		<DOM_VK_CLOSE_CURLY_BRACKET public="1" get="inline" set="null" expr="175" line="182" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>175</e></m></meta>
		</DOM_VK_CLOSE_CURLY_BRACKET>
		<DOM_VK_TILDE public="1" get="inline" set="null" expr="176" line="183" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>176</e></m></meta>
		</DOM_VK_TILDE>
		<DOM_VK_VOLUME_MUTE public="1" get="inline" set="null" expr="181" line="184" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>181</e></m></meta>
		</DOM_VK_VOLUME_MUTE>
		<DOM_VK_VOLUME_DOWN public="1" get="inline" set="null" expr="182" line="185" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>182</e></m></meta>
		</DOM_VK_VOLUME_DOWN>
		<DOM_VK_VOLUME_UP public="1" get="inline" set="null" expr="183" line="186" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>183</e></m></meta>
		</DOM_VK_VOLUME_UP>
		<DOM_VK_COMMA public="1" get="inline" set="null" expr="188" line="187" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>188</e></m></meta>
		</DOM_VK_COMMA>
		<DOM_VK_PERIOD public="1" get="inline" set="null" expr="190" line="188" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>190</e></m></meta>
		</DOM_VK_PERIOD>
		<DOM_VK_SLASH public="1" get="inline" set="null" expr="191" line="189" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>191</e></m></meta>
		</DOM_VK_SLASH>
		<DOM_VK_BACK_QUOTE public="1" get="inline" set="null" expr="192" line="190" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>192</e></m></meta>
		</DOM_VK_BACK_QUOTE>
		<DOM_VK_OPEN_BRACKET public="1" get="inline" set="null" expr="219" line="191" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>219</e></m></meta>
		</DOM_VK_OPEN_BRACKET>
		<DOM_VK_BACK_SLASH public="1" get="inline" set="null" expr="220" line="192" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>220</e></m></meta>
		</DOM_VK_BACK_SLASH>
		<DOM_VK_CLOSE_BRACKET public="1" get="inline" set="null" expr="221" line="193" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>221</e></m></meta>
		</DOM_VK_CLOSE_BRACKET>
		<DOM_VK_QUOTE public="1" get="inline" set="null" expr="222" line="194" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>222</e></m></meta>
		</DOM_VK_QUOTE>
		<DOM_VK_META public="1" get="inline" set="null" expr="224" line="195" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>224</e></m></meta>
		</DOM_VK_META>
		<DOM_VK_ALTGR public="1" get="inline" set="null" expr="225" line="196" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>225</e></m></meta>
		</DOM_VK_ALTGR>
		<DOM_VK_WIN_ICO_HELP public="1" get="inline" set="null" expr="227" line="197" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>227</e></m></meta>
		</DOM_VK_WIN_ICO_HELP>
		<DOM_VK_WIN_ICO_00 public="1" get="inline" set="null" expr="228" line="198" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>228</e></m></meta>
		</DOM_VK_WIN_ICO_00>
		<DOM_VK_WIN_ICO_CLEAR public="1" get="inline" set="null" expr="230" line="199" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>230</e></m></meta>
		</DOM_VK_WIN_ICO_CLEAR>
		<DOM_VK_WIN_OEM_RESET public="1" get="inline" set="null" expr="233" line="200" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>233</e></m></meta>
		</DOM_VK_WIN_OEM_RESET>
		<DOM_VK_WIN_OEM_JUMP public="1" get="inline" set="null" expr="234" line="201" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>234</e></m></meta>
		</DOM_VK_WIN_OEM_JUMP>
		<DOM_VK_WIN_OEM_PA1 public="1" get="inline" set="null" expr="235" line="202" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>235</e></m></meta>
		</DOM_VK_WIN_OEM_PA1>
		<DOM_VK_WIN_OEM_PA2 public="1" get="inline" set="null" expr="236" line="203" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>236</e></m></meta>
		</DOM_VK_WIN_OEM_PA2>
		<DOM_VK_WIN_OEM_PA3 public="1" get="inline" set="null" expr="237" line="204" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>237</e></m></meta>
		</DOM_VK_WIN_OEM_PA3>
		<DOM_VK_WIN_OEM_WSCTRL public="1" get="inline" set="null" expr="238" line="205" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>238</e></m></meta>
		</DOM_VK_WIN_OEM_WSCTRL>
		<DOM_VK_WIN_OEM_CUSEL public="1" get="inline" set="null" expr="239" line="206" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>239</e></m></meta>
		</DOM_VK_WIN_OEM_CUSEL>
		<DOM_VK_WIN_OEM_ATTN public="1" get="inline" set="null" expr="240" line="207" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>240</e></m></meta>
		</DOM_VK_WIN_OEM_ATTN>
		<DOM_VK_WIN_OEM_FINISH public="1" get="inline" set="null" expr="241" line="208" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>241</e></m></meta>
		</DOM_VK_WIN_OEM_FINISH>
		<DOM_VK_WIN_OEM_COPY public="1" get="inline" set="null" expr="242" line="209" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>242</e></m></meta>
		</DOM_VK_WIN_OEM_COPY>
		<DOM_VK_WIN_OEM_AUTO public="1" get="inline" set="null" expr="243" line="210" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>243</e></m></meta>
		</DOM_VK_WIN_OEM_AUTO>
		<DOM_VK_WIN_OEM_ENLW public="1" get="inline" set="null" expr="244" line="211" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>244</e></m></meta>
		</DOM_VK_WIN_OEM_ENLW>
		<DOM_VK_WIN_OEM_BACKTAB public="1" get="inline" set="null" expr="245" line="212" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>245</e></m></meta>
		</DOM_VK_WIN_OEM_BACKTAB>
		<DOM_VK_ATTN public="1" get="inline" set="null" expr="246" line="213" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>246</e></m></meta>
		</DOM_VK_ATTN>
		<DOM_VK_CRSEL public="1" get="inline" set="null" expr="247" line="214" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>247</e></m></meta>
		</DOM_VK_CRSEL>
		<DOM_VK_EXSEL public="1" get="inline" set="null" expr="248" line="215" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>248</e></m></meta>
		</DOM_VK_EXSEL>
		<DOM_VK_EREOF public="1" get="inline" set="null" expr="249" line="216" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>249</e></m></meta>
		</DOM_VK_EREOF>
		<DOM_VK_PLAY public="1" get="inline" set="null" expr="250" line="217" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>250</e></m></meta>
		</DOM_VK_PLAY>
		<DOM_VK_ZOOM public="1" get="inline" set="null" expr="251" line="218" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>251</e></m></meta>
		</DOM_VK_ZOOM>
		<DOM_VK_PA1 public="1" get="inline" set="null" expr="253" line="219" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>253</e></m></meta>
		</DOM_VK_PA1>
		<DOM_VK_WIN_OEM_CLEAR public="1" get="inline" set="null" expr="254" line="220" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>254</e></m></meta>
		</DOM_VK_WIN_OEM_CLEAR>
		<charCode public="1" set="null"><x path="Int"/></charCode>
		<keyCode public="1" set="null"><x path="Int"/></keyCode>
		<altKey public="1" set="null"><x path="Bool"/></altKey>
		<ctrlKey public="1" set="null"><x path="Bool"/></ctrlKey>
		<shiftKey public="1" set="null"><x path="Bool"/></shiftKey>
		<metaKey public="1" set="null"><x path="Bool"/></metaKey>
		<location public="1" set="null"><x path="Int"/></location>
		<repeat public="1" set="null"><x path="Bool"/></repeat>
		<isComposing public="1" set="null"><x path="Bool"/></isComposing>
		<key public="1" set="null"><c path="String"/></key>
		<getModifierState public="1" set="method"><f a="key">
	<c path="String"/>
	<x path="Bool"/>
</f></getModifierState>
		<initKeyEvent public="1" set="method">
			<f a="type:canBubble:cancelable:view:ctrlKey:altKey:shiftKey:metaKey:keyCode:charCode">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="js.html.Window"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</initKeyEvent>
		<new public="1" set="method">
			<f a="typeArg:?keyboardEventInitDict">
				<c path="String"/>
				<t path="js.html.KeyboardEventInit"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"KeyboardEvent"</e></m></meta>
	</class>
	<typedef path="js.html.KeyboardEventInit" params="" file="/usr/lib/haxe/std/js/html/KeyboardEventInit.hx"><a>
	<which>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</which>
	<view>
		<t path="Null"><c path="js.html.Window"/></t>
		<meta><m n=":optional"/></meta>
	</view>
	<shiftKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</shiftKey>
	<repeat>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</repeat>
	<metaKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</metaKey>
	<location>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</location>
	<keyCode>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</keyCode>
	<key>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</key>
	<isComposing>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</isComposing>
	<detail>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</detail>
	<ctrlKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</ctrlKey>
	<code>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</code>
	<charCode>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</charCode>
	<cancelable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</cancelable>
	<bubbles>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</bubbles>
	<altKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</altKey>
</a></typedef>
	<class path="js.html.LIElement" params="" file="/usr/lib/haxe/std/js/html/LIElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<value public="1"><x path="Int"/></value>
		<type public="1"><c path="String"/></type>
		<meta><m n=":native"><e>"HTMLLIElement"</e></m></meta>
	</class>
	<class path="js.html.LabelElement" params="" file="/usr/lib/haxe/std/js/html/LabelElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<htmlFor public="1"><c path="String"/></htmlFor>
		<control public="1" set="null"><c path="js.html.Element"/></control>
		<meta><m n=":native"><e>"HTMLLabelElement"</e></m></meta>
	</class>
	<class path="js.html.LegendElement" params="" file="/usr/lib/haxe/std/js/html/LegendElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLLegendElement"</e></m></meta>
	</class>
	<class path="js.html.LinkElement" params="" file="/usr/lib/haxe/std/js/html/LinkElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<href public="1"><c path="String"/></href>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<rel public="1"><c path="String"/></rel>
		<relList public="1" set="null"><c path="js.html.DOMTokenList"/></relList>
		<media public="1"><c path="String"/></media>
		<hreflang public="1"><c path="String"/></hreflang>
		<type public="1"><c path="String"/></type>
		<sizes public="1" set="null"><c path="js.html.DOMSettableTokenList"/></sizes>
		<charset public="1"><c path="String"/></charset>
		<rev public="1"><c path="String"/></rev>
		<target public="1"><c path="String"/></target>
		<import_ public="1" set="null">
			<c path="js.html.HTMLDocument"/>
			<meta><m n=":native"><e>"import"</e></m></meta>
		</import_>
		<sheet public="1" set="null"><c path="js.html.StyleSheet"/></sheet>
		<meta><m n=":native"><e>"HTMLLinkElement"</e></m></meta>
	</class>
	<class path="js.html.Location" params="" file="/usr/lib/haxe/std/js/html/Location.hx" extern="1">
		<href public="1"><c path="String"/></href>
		<origin public="1" set="null"><c path="String"/></origin>
		<protocol public="1"><c path="String"/></protocol>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<hostname public="1"><c path="String"/></hostname>
		<port public="1"><c path="String"/></port>
		<pathname public="1"><c path="String"/></pathname>
		<search public="1"><c path="String"/></search>
		<hash public="1"><c path="String"/></hash>
		<assign public="1" set="method">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</assign>
		<replace public="1" set="method">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replace>
		<reload public="1" set="method">
			<f a="?forceget" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{forceget:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</reload>
		<meta><m n=":native"><e>"Location"</e></m></meta>
	</class>
	<class path="js.html.MapElement" params="" file="/usr/lib/haxe/std/js/html/MapElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<areas public="1" set="null"><c path="js.html.HTMLCollection"/></areas>
		<meta><m n=":native"><e>"HTMLMapElement"</e></m></meta>
	</class>
	<class path="js.html.MediaError" params="" file="/usr/lib/haxe/std/js/html/MediaError.hx" extern="1">
		<MEDIA_ERR_ABORTED public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</MEDIA_ERR_ABORTED>
		<MEDIA_ERR_NETWORK public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</MEDIA_ERR_NETWORK>
		<MEDIA_ERR_DECODE public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</MEDIA_ERR_DECODE>
		<MEDIA_ERR_SRC_NOT_SUPPORTED public="1" get="inline" set="null" expr="4" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</MEDIA_ERR_SRC_NOT_SUPPORTED>
		<code public="1" set="null"><x path="Int"/></code>
		<meta><m n=":native"><e>"MediaError"</e></m></meta>
	</class>
	<class path="js.html.MediaKeyError" params="" file="/usr/lib/haxe/std/js/html/MediaKeyError.hx" extern="1">
		<extends path="js.html.Event"/>
		<systemCode public="1" set="null"><x path="Int"/></systemCode>
		<meta><m n=":native"><e>"MediaKeyError"</e></m></meta>
	</class>
	<class path="js.html.MediaKeySession" params="" file="/usr/lib/haxe/std/js/html/MediaKeySession.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<error public="1" set="null"><c path="js.html.MediaKeyError"/></error>
		<keySystem public="1" set="null"><c path="String"/></keySystem>
		<sessionId public="1" set="null"><c path="String"/></sessionId>
		<expiration public="1" set="null"><x path="Float"/></expiration>
		<closed public="1" set="null"><c path="js.Promise"><x path="Void"/></c></closed>
		<generateRequest public="1" set="method"><f a="initDataType:initData">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<c path="js.html.ArrayBuffer"/>
	</x>
	<c path="js.Promise"><x path="Void"/></c>
</f></generateRequest>
		<load public="1" set="method"><f a="sessionId">
	<c path="String"/>
	<c path="js.Promise"><x path="Bool"/></c>
</f></load>
		<update public="1" set="method"><f a="response">
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<c path="js.html.ArrayBuffer"/>
	</x>
	<c path="js.Promise"><x path="Void"/></c>
</f></update>
		<close public="1" set="method"><f a=""><c path="js.Promise"><x path="Void"/></c></f></close>
		<remove public="1" set="method"><f a=""><c path="js.Promise"><x path="Void"/></c></f></remove>
		<getUsableKeyIds public="1" set="method"><f a=""><c path="js.Promise"><c path="Array"><c path="js.html.ArrayBuffer"/></c></c></f></getUsableKeyIds>
		<meta><m n=":native"><e>"MediaKeySession"</e></m></meta>
	</class>
	<class path="js.html.MediaKeySystemAccess" params="" file="/usr/lib/haxe/std/js/html/MediaKeySystemAccess.hx" extern="1">
		<keySystem public="1" set="null"><c path="String"/></keySystem>
		<createMediaKeys public="1" set="method"><f a=""><c path="js.Promise"><c path="js.html.MediaKeys"/></c></f></createMediaKeys>
		<meta><m n=":native"><e>"MediaKeySystemAccess"</e></m></meta>
	</class>
	<typedef path="js.html.MediaKeySystemOptions" params="" file="/usr/lib/haxe/std/js/html/MediaKeySystemOptions.hx"><a>
	<videoType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</videoType>
	<videoCapability>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</videoCapability>
	<uniqueidentifier>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</uniqueidentifier>
	<stateful>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</stateful>
	<initDataType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</initDataType>
	<audioType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</audioType>
	<audioCapability>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</audioCapability>
</a></typedef>
	<class path="js.html.MediaKeys" params="" file="/usr/lib/haxe/std/js/html/MediaKeys.hx" extern="1">
		<keySystem public="1" set="null"><c path="String"/></keySystem>
		<createSession public="1" set="method">
			<f a="?sessionType" v="&quot;temporary&quot;">
				<x path="js.html.SessionType"/>
				<c path="js.html.MediaKeySession"/>
			</f>
			<meta><m n=":value"><e>{sessionType:"temporary"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createSession>
		<setServerCertificate public="1" set="method"><f a="serverCertificate">
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<c path="js.html.ArrayBuffer"/>
	</x>
	<c path="js.Promise"><x path="Void"/></c>
</f></setServerCertificate>
		<meta><m n=":native"><e>"MediaKeys"</e></m></meta>
	</class>
	<class path="js.html.MediaList" params="" file="/usr/lib/haxe/std/js/html/MediaList.hx" extern="1">
		<mediaText public="1"><c path="String"/></mediaText>
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<deleteMedium public="1" set="method">
			<f a="oldMedium">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteMedium>
		<appendMedium public="1" set="method">
			<f a="newMedium">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</appendMedium>
		<meta><m n=":native"><e>"MediaList"</e></m></meta>
	</class>
	<class path="js.html.MediaQueryList" params="" file="/usr/lib/haxe/std/js/html/MediaQueryList.hx" extern="1">
		<media public="1" set="null"><c path="String"/></media>
		<matches public="1" set="null"><x path="Bool"/></matches>
		<addListener public="1" set="method"><f a="listener">
	<f a="">
		<c path="js.html.MediaQueryList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></addListener>
		<removeListener public="1" set="method"><f a="listener">
	<f a="">
		<c path="js.html.MediaQueryList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></removeListener>
		<meta><m n=":native"><e>"MediaQueryList"</e></m></meta>
	</class>
	<class path="js.html.MediaStream" params="" file="/usr/lib/haxe/std/js/html/MediaStream.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<getAudioTracks public="1" set="method"><f a=""><c path="Array"><c path="js.html.AudioStreamTrack"/></c></f></getAudioTracks>
		<getVideoTracks public="1" set="method"><f a=""><c path="Array"><c path="js.html.VideoStreamTrack"/></c></f></getVideoTracks>
		<getTracks public="1" set="method"><f a=""><c path="Array"><c path="js.html.MediaStreamTrack"/></c></f></getTracks>
		<meta><m n=":native"><e>"MediaStream"</e></m></meta>
	</class>
	<abstract path="js.html.MediaWaitingFor" params="" file="/usr/lib/haxe/std/js/html/MediaWaitingFor.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._MediaWaitingFor.MediaWaitingFor_Impl_" params="" file="/usr/lib/haxe/std/js/html/MediaWaitingFor.hx" private="1" module="js.html.MediaWaitingFor"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.MenuElement" params="" file="/usr/lib/haxe/std/js/html/MenuElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<type public="1"><c path="String"/></type>
		<label public="1"><c path="String"/></label>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLMenuElement"</e></m></meta>
	</class>
	<class path="js.html.MetaElement" params="" file="/usr/lib/haxe/std/js/html/MetaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<httpEquiv public="1"><c path="String"/></httpEquiv>
		<content public="1"><c path="String"/></content>
		<scheme public="1"><c path="String"/></scheme>
		<meta><m n=":native"><e>"HTMLMetaElement"</e></m></meta>
	</class>
	<class path="js.html.MeterElement" params="" file="/usr/lib/haxe/std/js/html/MeterElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<value public="1"><x path="Float"/></value>
		<min public="1"><x path="Float"/></min>
		<max public="1"><x path="Float"/></max>
		<low public="1"><x path="Float"/></low>
		<high public="1"><x path="Float"/></high>
		<optimum public="1"><x path="Float"/></optimum>
		<meta><m n=":native"><e>"HTMLMeterElement"</e></m></meta>
	</class>
	<class path="js.html.MimeType" params="" file="/usr/lib/haxe/std/js/html/MimeType.hx" extern="1">
		<description public="1" set="null"><c path="String"/></description>
		<enabledPlugin public="1" set="null"><c path="js.html.Plugin"/></enabledPlugin>
		<suffixes public="1" set="null"><c path="String"/></suffixes>
		<type public="1" set="null"><c path="String"/></type>
		<meta><m n=":native"><e>"MimeType"</e></m></meta>
	</class>
	<class path="js.html.MimeTypeArray" params="" file="/usr/lib/haxe/std/js/html/MimeTypeArray.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.MimeType"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.MimeType"/>
</f></namedItem>
		<meta><m n=":native"><e>"MimeTypeArray"</e></m></meta>
	</class>
	<class path="js.html.ModElement" params="" file="/usr/lib/haxe/std/js/html/ModElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<cite public="1"><c path="String"/></cite>
		<dateTime public="1"><c path="String"/></dateTime>
		<meta><m n=":native"><e>"HTMLModElement"</e></m></meta>
	</class>
	<class path="js.html.MouseEvent" params="" file="/usr/lib/haxe/std/js/html/MouseEvent.hx" extern="1">
		<extends path="js.html.UIEvent"/>
		<screenX public="1" set="null"><x path="Int"/></screenX>
		<screenY public="1" set="null"><x path="Int"/></screenY>
		<clientX public="1" set="null"><x path="Int"/></clientX>
		<clientY public="1" set="null"><x path="Int"/></clientY>
		<ctrlKey public="1" set="null"><x path="Bool"/></ctrlKey>
		<shiftKey public="1" set="null"><x path="Bool"/></shiftKey>
		<altKey public="1" set="null"><x path="Bool"/></altKey>
		<metaKey public="1" set="null"><x path="Bool"/></metaKey>
		<button public="1" set="null"><x path="Int"/></button>
		<buttons public="1" set="null"><x path="Int"/></buttons>
		<relatedTarget public="1" set="null"><c path="js.html.EventTarget"/></relatedTarget>
		<region public="1" set="null"><c path="String"/></region>
		<movementX public="1" set="null"><x path="Int"/></movementX>
		<movementY public="1" set="null"><x path="Int"/></movementY>
		<initMouseEvent public="1" set="method">
			<f a="typeArg:canBubbleArg:cancelableArg:viewArg:detailArg:screenXArg:screenYArg:clientXArg:clientYArg:ctrlKeyArg:altKeyArg:shiftKeyArg:metaKeyArg:buttonArg:relatedTargetArg">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="js.html.Window"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="js.html.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</initMouseEvent>
		<getModifierState public="1" set="method"><f a="keyArg">
	<c path="String"/>
	<x path="Bool"/>
</f></getModifierState>
		<initNSMouseEvent public="1" set="method">
			<f a="typeArg:canBubbleArg:cancelableArg:viewArg:detailArg:screenXArg:screenYArg:clientXArg:clientYArg:ctrlKeyArg:altKeyArg:shiftKeyArg:metaKeyArg:buttonArg:relatedTargetArg:pressure:inputSourceArg">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="js.html.Window"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="js.html.EventTarget"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</initNSMouseEvent>
		<new public="1" set="method">
			<f a="typeArg:?mouseEventInitDict">
				<c path="String"/>
				<t path="js.html.MouseEventInit"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"MouseEvent"</e></m></meta>
	</class>
	<typedef path="js.html.MouseEventInit" params="" file="/usr/lib/haxe/std/js/html/MouseEventInit.hx"><a>
	<view>
		<t path="Null"><c path="js.html.Window"/></t>
		<meta><m n=":optional"/></meta>
	</view>
	<shiftKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</shiftKey>
	<screenY>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</screenY>
	<screenX>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</screenX>
	<relatedTarget>
		<t path="Null"><c path="js.html.EventTarget"/></t>
		<meta><m n=":optional"/></meta>
	</relatedTarget>
	<metaKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</metaKey>
	<detail>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</detail>
	<ctrlKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</ctrlKey>
	<clientY>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</clientY>
	<clientX>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</clientX>
	<cancelable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</cancelable>
	<buttons>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</buttons>
	<button>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</button>
	<bubbles>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</bubbles>
	<altKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</altKey>
</a></typedef>
	<class path="js.html.NamedNodeMap" params="" file="/usr/lib/haxe/std/js/html/NamedNodeMap.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<getNamedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getNamedItem>
		<setNamedItem public="1" set="method">
			<f a="arg">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setNamedItem>
		<removeNamedItem public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeNamedItem>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Attr"/>
</f></item>
		<getNamedItemNS public="1" set="method"><f a="namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getNamedItemNS>
		<setNamedItemNS public="1" set="method">
			<f a="arg">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setNamedItemNS>
		<removeNamedItemNS public="1" set="method">
			<f a="namespaceURI:localName">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeNamedItemNS>
		<meta><m n=":native"><e>"NamedNodeMap"</e></m></meta>
	</class>
	<class path="js.html.Navigator" params="" file="/usr/lib/haxe/std/js/html/Navigator.hx" extern="1">
		<mimeTypes public="1" set="null"><c path="js.html.MimeTypeArray"/></mimeTypes>
		<plugins public="1" set="null"><c path="js.html.PluginArray"/></plugins>
		<doNotTrack public="1" set="null"><c path="String"/></doNotTrack>
		<maxTouchPoints public="1" set="null"><x path="Int"/></maxTouchPoints>
		<oscpu public="1" set="null"><c path="String"/></oscpu>
		<vendor public="1" set="null"><c path="String"/></vendor>
		<vendorSub public="1" set="null"><c path="String"/></vendorSub>
		<productSub public="1" set="null"><c path="String"/></productSub>
		<cookieEnabled public="1" set="null"><x path="Bool"/></cookieEnabled>
		<buildID public="1" set="null"><c path="String"/></buildID>
		<battery public="1" set="null"><c path="js.html.BatteryManager"/></battery>
		<geolocation public="1" set="null"><c path="js.html.Geolocation"/></geolocation>
		<appCodeName public="1" set="null"><c path="String"/></appCodeName>
		<appName public="1" set="null"><c path="String"/></appName>
		<appVersion public="1" set="null"><c path="String"/></appVersion>
		<platform public="1" set="null"><c path="String"/></platform>
		<userAgent public="1" set="null"><c path="String"/></userAgent>
		<product public="1" set="null"><c path="String"/></product>
		<language public="1" set="null"><c path="String"/></language>
		<languages public="1" set="null"><c path="Array"><c path="String"/></c></languages>
		<onLine public="1" set="null"><x path="Bool"/></onLine>
		<vibrate public="1" set="method">
			<f a="pattern">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<overloads><vibrate public="1" set="method"><f a="duration">
	<x path="Int"/>
	<x path="Bool"/>
</f></vibrate></overloads>
		</vibrate>
		<javaEnabled public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</javaEnabled>
		<getGamepads public="1" set="method">
			<f a=""><c path="Array"><c path="js.html.Gamepad"/></c></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getGamepads>
		<sendBeacon public="1" set="method">
			<f a="url:?data">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.ArrayBufferView"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Blob"/>
						<x path="haxe.extern.EitherType">
							<c path="String"/>
							<c path="js.html.FormData"/>
						</x>
					</x>
				</x>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</sendBeacon>
		<requestMediaKeySystemAccess public="1" set="method"><f a="keySystem:?supportedConfigurations">
	<c path="String"/>
	<c path="Array"><t path="js.html.MediaKeySystemOptions"/></c>
	<c path="js.Promise"><c path="js.html.MediaKeySystemAccess"/></c>
</f></requestMediaKeySystemAccess>
		<registerProtocolHandler public="1" set="method">
			<f a="scheme:url:title">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</registerProtocolHandler>
		<registerContentHandler public="1" set="method">
			<f a="mimeType:url:title">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</registerContentHandler>
		<taintEnabled public="1" set="method"><f a=""><x path="Bool"/></f></taintEnabled>
		<meta><m n=":native"><e>"Navigator"</e></m></meta>
	</class>
	<class path="js.html.NodeFilter" params="" file="/usr/lib/haxe/std/js/html/NodeFilter.hx" extern="1">
		<FILTER_ACCEPT public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</FILTER_ACCEPT>
		<FILTER_REJECT public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</FILTER_REJECT>
		<FILTER_SKIP public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</FILTER_SKIP>
		<SHOW_ALL public="1" get="inline" set="null" expr="&apos;???&apos;" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>'???'</e></m></meta>
		</SHOW_ALL>
		<SHOW_ELEMENT public="1" get="inline" set="null" expr="1" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</SHOW_ELEMENT>
		<SHOW_ATTRIBUTE public="1" get="inline" set="null" expr="2" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</SHOW_ATTRIBUTE>
		<SHOW_TEXT public="1" get="inline" set="null" expr="4" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</SHOW_TEXT>
		<SHOW_CDATA_SECTION public="1" get="inline" set="null" expr="8" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</SHOW_CDATA_SECTION>
		<SHOW_ENTITY_REFERENCE public="1" get="inline" set="null" expr="16" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</SHOW_ENTITY_REFERENCE>
		<SHOW_ENTITY public="1" get="inline" set="null" expr="32" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</SHOW_ENTITY>
		<SHOW_PROCESSING_INSTRUCTION public="1" get="inline" set="null" expr="64" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>64</e></m></meta>
		</SHOW_PROCESSING_INSTRUCTION>
		<SHOW_COMMENT public="1" get="inline" set="null" expr="128" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
		</SHOW_COMMENT>
		<SHOW_DOCUMENT public="1" get="inline" set="null" expr="256" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>256</e></m></meta>
		</SHOW_DOCUMENT>
		<SHOW_DOCUMENT_TYPE public="1" get="inline" set="null" expr="512" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>512</e></m></meta>
		</SHOW_DOCUMENT_TYPE>
		<SHOW_DOCUMENT_FRAGMENT public="1" get="inline" set="null" expr="1024" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1024</e></m></meta>
		</SHOW_DOCUMENT_FRAGMENT>
		<SHOW_NOTATION public="1" get="inline" set="null" expr="2048" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2048</e></m></meta>
		</SHOW_NOTATION>
		<acceptNode public="1" set="method"><f a="node">
	<c path="js.html.Node"/>
	<x path="Int"/>
</f></acceptNode>
		<meta><m n=":native"><e>"NodeFilter"</e></m></meta>
	</class>
	<class path="js.html.NodeIterator" params="" file="/usr/lib/haxe/std/js/html/NodeIterator.hx" extern="1">
		<root public="1" set="null"><c path="js.html.Node"/></root>
		<referenceNode public="1" set="null"><c path="js.html.Node"/></referenceNode>
		<pointerBeforeReferenceNode public="1" set="null"><x path="Bool"/></pointerBeforeReferenceNode>
		<whatToShow public="1" set="null"><x path="Int"/></whatToShow>
		<filter public="1" set="null"><c path="js.html.NodeFilter"/></filter>
		<nextNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</nextNode>
		<previousNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</previousNode>
		<detach public="1" set="method"><f a=""><x path="Void"/></f></detach>
		<meta><m n=":native"><e>"NodeIterator"</e></m></meta>
	</class>
	<class path="js.html.NodeList" params="" file="/usr/lib/haxe/std/js/html/NodeList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Node"/>
</f></item>
		<meta><m n=":native"><e>"NodeList"</e></m></meta>
	</class>
	<class path="js.html.OListElement" params="" file="/usr/lib/haxe/std/js/html/OListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<reversed public="1"><x path="Bool"/></reversed>
		<start public="1"><x path="Int"/></start>
		<type public="1"><c path="String"/></type>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLOListElement"</e></m></meta>
	</class>
	<class path="js.html.ObjectElement" params="" file="/usr/lib/haxe/std/js/html/ObjectElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<data public="1"><c path="String"/></data>
		<type public="1"><c path="String"/></type>
		<typeMustMatch public="1"><x path="Bool"/></typeMustMatch>
		<name public="1"><c path="String"/></name>
		<useMap public="1"><c path="String"/></useMap>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<width public="1"><c path="String"/></width>
		<height public="1"><c path="String"/></height>
		<contentDocument public="1" set="null"><c path="js.html.HTMLDocument"/></contentDocument>
		<contentWindow public="1" set="null"><c path="js.html.Window"/></contentWindow>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<align public="1"><c path="String"/></align>
		<archive public="1"><c path="String"/></archive>
		<code public="1"><c path="String"/></code>
		<declare public="1"><x path="Bool"/></declare>
		<hspace public="1"><x path="Int"/></hspace>
		<standby public="1"><c path="String"/></standby>
		<vspace public="1"><x path="Int"/></vspace>
		<codeBase public="1"><c path="String"/></codeBase>
		<codeType public="1"><c path="String"/></codeType>
		<border public="1"><c path="String"/></border>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<getSVGDocument public="1" set="method"><f a=""><c path="js.html.HTMLDocument"/></f></getSVGDocument>
		<meta><m n=":native"><e>"HTMLObjectElement"</e></m></meta>
	</class>
	<class path="js.html.OptGroupElement" params="" file="/usr/lib/haxe/std/js/html/OptGroupElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<label public="1"><c path="String"/></label>
		<meta><m n=":native"><e>"HTMLOptGroupElement"</e></m></meta>
	</class>
	<class path="js.html.OptionElement" params="" file="/usr/lib/haxe/std/js/html/OptionElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<label public="1"><c path="String"/></label>
		<defaultSelected public="1"><x path="Bool"/></defaultSelected>
		<selected public="1"><x path="Bool"/></selected>
		<value public="1"><c path="String"/></value>
		<text public="1"><c path="String"/></text>
		<index public="1" set="null"><x path="Int"/></index>
		<meta><m n=":native"><e>"HTMLOptionElement"</e></m></meta>
	</class>
	<class path="js.html.OutputElement" params="" file="/usr/lib/haxe/std/js/html/OutputElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<htmlFor public="1" set="null"><c path="js.html.DOMSettableTokenList"/></htmlFor>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<name public="1"><c path="String"/></name>
		<type public="1" set="null"><c path="String"/></type>
		<defaultValue public="1"><c path="String"/></defaultValue>
		<value public="1"><c path="String"/></value>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLOutputElement"</e></m></meta>
	</class>
	<class path="js.html.ParagraphElement" params="" file="/usr/lib/haxe/std/js/html/ParagraphElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLParagraphElement"</e></m></meta>
	</class>
	<class path="js.html.ParamElement" params="" file="/usr/lib/haxe/std/js/html/ParamElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<type public="1"><c path="String"/></type>
		<valueType public="1"><c path="String"/></valueType>
		<meta><m n=":native"><e>"HTMLParamElement"</e></m></meta>
	</class>
	<class path="js.html.Path2D" params="" file="/usr/lib/haxe/std/js/html/Path2D.hx" extern="1">
		<addPath public="1" set="method"><f a="path:?transformation">
	<c path="js.html.Path2D"/>
	<c path="js.html.svg.Matrix"/>
	<x path="Void"/>
</f></addPath>
		<closePath public="1" set="method"><f a=""><x path="Void"/></f></closePath>
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<quadraticCurveTo public="1" set="method"><f a="cpx:cpy:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadraticCurveTo>
		<bezierCurveTo public="1" set="method"><f a="cp1x:cp1y:cp2x:cp2y:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bezierCurveTo>
		<arcTo public="1" set="method">
			<f a="x1:y1:x2:y2:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arcTo>
		<rect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rect>
		<arc public="1" set="method">
			<f a="x:y:radius:startAngle:endAngle:?anticlockwise" v=":::::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{anticlockwise:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arc>
		<new public="1" set="method">
			<f a="pathString">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a=""><x path="Void"/></f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="other">
						<c path="js.html.Path2D"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Path2D"</e></m></meta>
	</class>
	<class path="js.html.Performance" params="" file="/usr/lib/haxe/std/js/html/Performance.hx" extern="1">
		<timing public="1" set="null"><c path="js.html.PerformanceTiming"/></timing>
		<navigation public="1" set="null"><c path="js.html.PerformanceNavigation"/></navigation>
		<now public="1" set="method"><f a=""><x path="Float"/></f></now>
		<meta><m n=":native"><e>"Performance"</e></m></meta>
	</class>
	<class path="js.html.PerformanceNavigation" params="" file="/usr/lib/haxe/std/js/html/PerformanceNavigation.hx" extern="1">
		<TYPE_NAVIGATE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</TYPE_NAVIGATE>
		<TYPE_RELOAD public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TYPE_RELOAD>
		<TYPE_BACK_FORWARD public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</TYPE_BACK_FORWARD>
		<TYPE_RESERVED public="1" get="inline" set="null" expr="255" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>255</e></m></meta>
		</TYPE_RESERVED>
		<type public="1" set="null"><x path="Int"/></type>
		<redirectCount public="1" set="null"><x path="Int"/></redirectCount>
		<meta><m n=":native"><e>"PerformanceNavigation"</e></m></meta>
	</class>
	<class path="js.html.PerformanceTiming" params="" file="/usr/lib/haxe/std/js/html/PerformanceTiming.hx" extern="1">
		<navigationStart public="1" set="null"><x path="Int"/></navigationStart>
		<unloadEventStart public="1" set="null"><x path="Int"/></unloadEventStart>
		<unloadEventEnd public="1" set="null"><x path="Int"/></unloadEventEnd>
		<redirectStart public="1" set="null"><x path="Int"/></redirectStart>
		<redirectEnd public="1" set="null"><x path="Int"/></redirectEnd>
		<fetchStart public="1" set="null"><x path="Int"/></fetchStart>
		<domainLookupStart public="1" set="null"><x path="Int"/></domainLookupStart>
		<domainLookupEnd public="1" set="null"><x path="Int"/></domainLookupEnd>
		<connectStart public="1" set="null"><x path="Int"/></connectStart>
		<connectEnd public="1" set="null"><x path="Int"/></connectEnd>
		<requestStart public="1" set="null"><x path="Int"/></requestStart>
		<responseStart public="1" set="null"><x path="Int"/></responseStart>
		<responseEnd public="1" set="null"><x path="Int"/></responseEnd>
		<domLoading public="1" set="null"><x path="Int"/></domLoading>
		<domInteractive public="1" set="null"><x path="Int"/></domInteractive>
		<domContentLoadedEventStart public="1" set="null"><x path="Int"/></domContentLoadedEventStart>
		<domContentLoadedEventEnd public="1" set="null"><x path="Int"/></domContentLoadedEventEnd>
		<domComplete public="1" set="null"><x path="Int"/></domComplete>
		<loadEventStart public="1" set="null"><x path="Int"/></loadEventStart>
		<loadEventEnd public="1" set="null"><x path="Int"/></loadEventEnd>
		<meta><m n=":native"><e>"PerformanceTiming"</e></m></meta>
	</class>
	<class path="js.html.PictureElement" params="" file="/usr/lib/haxe/std/js/html/PictureElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<meta><m n=":native"><e>"HTMLPictureElement"</e></m></meta>
	</class>
	<class path="js.html.Plugin" params="" file="/usr/lib/haxe/std/js/html/Plugin.hx" extern="1">
		<description public="1" set="null"><c path="String"/></description>
		<filename public="1" set="null"><c path="String"/></filename>
		<version public="1" set="null"><c path="String"/></version>
		<name public="1" set="null"><c path="String"/></name>
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.MimeType"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.MimeType"/>
</f></namedItem>
		<meta><m n=":native"><e>"Plugin"</e></m></meta>
	</class>
	<class path="js.html.PluginArray" params="" file="/usr/lib/haxe/std/js/html/PluginArray.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Plugin"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Plugin"/>
</f></namedItem>
		<refresh public="1" set="method">
			<f a="?reloadDocuments" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{reloadDocuments:false}</e></m></meta>
		</refresh>
		<meta><m n=":native"><e>"PluginArray"</e></m></meta>
	</class>
	<class path="js.html.Position" params="" file="/usr/lib/haxe/std/js/html/Position.hx" extern="1">
		<coords public="1" set="null"><c path="js.html.Coordinates"/></coords>
		<timestamp public="1" set="null"><x path="Int"/></timestamp>
		<meta><m n=":native"><e>"Position"</e></m></meta>
	</class>
	<class path="js.html.PositionError" params="" file="/usr/lib/haxe/std/js/html/PositionError.hx" extern="1">
		<PERMISSION_DENIED public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</PERMISSION_DENIED>
		<POSITION_UNAVAILABLE public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</POSITION_UNAVAILABLE>
		<TIMEOUT public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</TIMEOUT>
		<code public="1" set="null"><x path="Int"/></code>
		<message public="1" set="null"><c path="String"/></message>
		<meta><m n=":native"><e>"PositionError"</e></m></meta>
	</class>
	<typedef path="js.html.PositionOptions" params="" file="/usr/lib/haxe/std/js/html/PositionOptions.hx"><a>
	<timeout>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</timeout>
	<maximumAge>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</maximumAge>
	<enableHighAccuracy>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</enableHighAccuracy>
</a></typedef>
	<class path="js.html.PreElement" params="" file="/usr/lib/haxe/std/js/html/PreElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<width public="1"><x path="Int"/></width>
		<meta><m n=":native"><e>"HTMLPreElement"</e></m></meta>
	</class>
	<class path="js.html.ProcessingInstruction" params="" file="/usr/lib/haxe/std/js/html/ProcessingInstruction.hx" extern="1">
		<extends path="js.html.CharacterData"/>
		<target public="1" set="null"><c path="String"/></target>
		<meta><m n=":native"><e>"ProcessingInstruction"</e></m></meta>
	</class>
	<class path="js.html.ProgressElement" params="" file="/usr/lib/haxe/std/js/html/ProgressElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<value public="1"><x path="Float"/></value>
		<max public="1"><x path="Float"/></max>
		<position public="1" set="null"><x path="Float"/></position>
		<meta><m n=":native"><e>"HTMLProgressElement"</e></m></meta>
	</class>
	<class path="js.html.QuoteElement" params="" file="/usr/lib/haxe/std/js/html/QuoteElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<cite public="1"><c path="String"/></cite>
		<meta><m n=":native"><e>"HTMLQuoteElement"</e></m></meta>
	</class>
	<class path="js.html.Range" params="" file="/usr/lib/haxe/std/js/html/Range.hx" extern="1">
		<START_TO_START public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</START_TO_START>
		<START_TO_END public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</START_TO_END>
		<END_TO_END public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</END_TO_END>
		<END_TO_START public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</END_TO_START>
		<startContainer public="1" set="null"><c path="js.html.Node"/></startContainer>
		<startOffset public="1" set="null"><x path="Int"/></startOffset>
		<endContainer public="1" set="null"><c path="js.html.Node"/></endContainer>
		<endOffset public="1" set="null"><x path="Int"/></endOffset>
		<collapsed public="1" set="null"><x path="Bool"/></collapsed>
		<commonAncestorContainer public="1" set="null"><c path="js.html.Node"/></commonAncestorContainer>
		<setStart public="1" set="method">
			<f a="refNode:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setStart>
		<setEnd public="1" set="method">
			<f a="refNode:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setEnd>
		<setStartBefore public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setStartBefore>
		<setStartAfter public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setStartAfter>
		<setEndBefore public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setEndBefore>
		<setEndAfter public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setEndAfter>
		<collapse public="1" set="method">
			<f a="?toStart" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{toStart:false}</e></m></meta>
		</collapse>
		<selectNode public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</selectNode>
		<selectNodeContents public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</selectNodeContents>
		<compareBoundaryPoints public="1" set="method">
			<f a="how:sourceRange">
				<x path="Int"/>
				<c path="js.html.Range"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</compareBoundaryPoints>
		<deleteContents public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteContents>
		<extractContents public="1" set="method">
			<f a=""><c path="js.html.DocumentFragment"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</extractContents>
		<cloneContents public="1" set="method">
			<f a=""><c path="js.html.DocumentFragment"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cloneContents>
		<insertNode public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertNode>
		<surroundContents public="1" set="method">
			<f a="newParent">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</surroundContents>
		<cloneRange public="1" set="method"><f a=""><c path="js.html.Range"/></f></cloneRange>
		<detach public="1" set="method"><f a=""><x path="Void"/></f></detach>
		<isPointInRange public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</isPointInRange>
		<comparePoint public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</comparePoint>
		<intersectsNode public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</intersectsNode>
		<createContextualFragment public="1" set="method">
			<f a="fragment">
				<c path="String"/>
				<c path="js.html.DocumentFragment"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createContextualFragment>
		<getClientRects public="1" set="method"><f a=""><c path="js.html.DOMRectList"/></f></getClientRects>
		<getBoundingClientRect public="1" set="method"><f a=""><c path="js.html.DOMRect"/></f></getBoundingClientRect>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Range"</e></m></meta>
	</class>
	<class path="js.html.Screen" params="" file="/usr/lib/haxe/std/js/html/Screen.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<availWidth public="1" set="null"><x path="Int"/></availWidth>
		<availHeight public="1" set="null"><x path="Int"/></availHeight>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<colorDepth public="1" set="null"><x path="Int"/></colorDepth>
		<pixelDepth public="1" set="null"><x path="Int"/></pixelDepth>
		<top public="1" set="null"><x path="Int"/></top>
		<left public="1" set="null"><x path="Int"/></left>
		<availTop public="1" set="null"><x path="Int"/></availTop>
		<availLeft public="1" set="null"><x path="Int"/></availLeft>
		<meta><m n=":native"><e>"Screen"</e></m></meta>
	</class>
	<class path="js.html.ScriptElement" params="" file="/usr/lib/haxe/std/js/html/ScriptElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<type public="1"><c path="String"/></type>
		<charset public="1"><c path="String"/></charset>
		<async public="1"><x path="Bool"/></async>
		<defer public="1"><x path="Bool"/></defer>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<text public="1"><c path="String"/></text>
		<event public="1"><c path="String"/></event>
		<htmlFor public="1"><c path="String"/></htmlFor>
		<meta><m n=":native"><e>"HTMLScriptElement"</e></m></meta>
	</class>
	<typedef path="js.html.ScrollIntoViewOptions" params="" file="/usr/lib/haxe/std/js/html/ScrollIntoViewOptions.hx"><a>
	<block>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</block>
	<behavior>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</behavior>
</a></typedef>
	<typedef path="js.html.ScrollOptions" params="" file="/usr/lib/haxe/std/js/html/ScrollOptions.hx"><a><behavior>
	<t path="Null"><d/></t>
	<meta><m n=":optional"/></meta>
</behavior></a></typedef>
	<typedef path="js.html.ScrollToOptions" params="" file="/usr/lib/haxe/std/js/html/ScrollToOptions.hx"><a>
	<top>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</top>
	<left>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</left>
	<behavior>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</behavior>
</a></typedef>
	<class path="js.html.SelectElement" params="" file="/usr/lib/haxe/std/js/html/SelectElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<multiple public="1"><x path="Bool"/></multiple>
		<name public="1"><c path="String"/></name>
		<required public="1"><x path="Bool"/></required>
		<size public="1"><x path="Int"/></size>
		<type public="1" set="null"><c path="String"/></type>
		<options public="1" set="null"><c path="js.html.HTMLOptionsCollection"/></options>
		<length public="1"><x path="Int"/></length>
		<selectedOptions public="1" set="null"><c path="js.html.HTMLCollection"/></selectedOptions>
		<selectedIndex public="1"><x path="Int"/></selectedIndex>
		<value public="1"><c path="String"/></value>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Element"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.OptionElement"/>
</f></namedItem>
		<add public="1" set="method">
			<f a="element:?before">
				<x path="haxe.extern.EitherType">
					<c path="js.html.OptionElement"/>
					<c path="js.html.OptGroupElement"/>
				</x>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Element"/>
					<x path="Int"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLSelectElement"</e></m></meta>
	</class>
	<class path="js.html.Selection" params="" file="/usr/lib/haxe/std/js/html/Selection.hx" extern="1">
		<anchorNode public="1" set="null"><c path="js.html.Node"/></anchorNode>
		<anchorOffset public="1" set="null"><x path="Int"/></anchorOffset>
		<focusNode public="1" set="null"><c path="js.html.Node"/></focusNode>
		<focusOffset public="1" set="null"><x path="Int"/></focusOffset>
		<isCollapsed public="1" set="null"><x path="Bool"/></isCollapsed>
		<rangeCount public="1" set="null"><x path="Int"/></rangeCount>
		<collapse public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</collapse>
		<collapseToStart public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</collapseToStart>
		<collapseToEnd public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</collapseToEnd>
		<extend public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</extend>
		<selectAllChildren public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</selectAllChildren>
		<deleteFromDocument public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteFromDocument>
		<getRangeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="js.html.Range"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getRangeAt>
		<addRange public="1" set="method">
			<f a="range">
				<c path="js.html.Range"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</addRange>
		<removeRange public="1" set="method">
			<f a="range">
				<c path="js.html.Range"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeRange>
		<removeAllRanges public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAllRanges>
		<containsNode public="1" set="method">
			<f a="node:allowPartialContainment">
				<c path="js.html.Node"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</containsNode>
		<modify public="1" set="method">
			<f a="alter:direction:granularity">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</modify>
		<meta><m n=":native"><e>"Selection"</e></m></meta>
	</class>
	<abstract path="js.html.SelectionMode" params="" file="/usr/lib/haxe/std/js/html/SelectionMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._SelectionMode.SelectionMode_Impl_" params="" file="/usr/lib/haxe/std/js/html/SelectionMode.hx" private="1" module="js.html.SelectionMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="js.html.SessionType" params="" file="/usr/lib/haxe/std/js/html/SessionType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._SessionType.SessionType_Impl_" params="" file="/usr/lib/haxe/std/js/html/SessionType.hx" private="1" module="js.html.SessionType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.ShadowElement" params="" file="/usr/lib/haxe/std/js/html/ShadowElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<olderShadowRoot public="1" set="null"><c path="js.html.ShadowRoot"/></olderShadowRoot>
		<meta><m n=":native"><e>"HTMLShadowElement"</e></m></meta>
	</class>
	<class path="js.html.ShadowRoot" params="" file="/usr/lib/haxe/std/js/html/ShadowRoot.hx" extern="1">
		<extends path="js.html.DocumentFragment"/>
		<innerHTML public="1"><c path="String"/></innerHTML>
		<host public="1" set="null"><c path="js.html.Element"/></host>
		<olderShadowRoot public="1" set="null"><c path="js.html.ShadowRoot"/></olderShadowRoot>
		<applyAuthorStyles public="1"><x path="Bool"/></applyAuthorStyles>
		<styleSheets public="1" set="null"><c path="js.html.StyleSheetList"/></styleSheets>
		<getElementsByTagName public="1" set="method"><f a="localName">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagName>
		<getElementsByTagNameNS public="1" set="method"><f a="namespace_:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagNameNS>
		<getElementsByClassName public="1" set="method"><f a="classNames">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByClassName>
		<meta><m n=":native"><e>"ShadowRoot"</e></m></meta>
	</class>
	<class path="js.html.SourceElement" params="" file="/usr/lib/haxe/std/js/html/SourceElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<type public="1"><c path="String"/></type>
		<srcset public="1"><c path="String"/></srcset>
		<sizes public="1"><c path="String"/></sizes>
		<media public="1"><c path="String"/></media>
		<meta><m n=":native"><e>"HTMLSourceElement"</e></m></meta>
	</class>
	<class path="js.html.SpanElement" params="" file="/usr/lib/haxe/std/js/html/SpanElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<meta><m n=":native"><e>"HTMLSpanElement"</e></m></meta>
	</class>
	<class path="js.html.SpeechSynthesis" params="" file="/usr/lib/haxe/std/js/html/SpeechSynthesis.hx" extern="1">
		<pending public="1" set="null"><x path="Bool"/></pending>
		<speaking public="1" set="null"><x path="Bool"/></speaking>
		<paused public="1" set="null"><x path="Bool"/></paused>
		<speak public="1" set="method"><f a="utterance">
	<c path="js.html.SpeechSynthesisUtterance"/>
	<x path="Void"/>
</f></speak>
		<cancel public="1" set="method"><f a=""><x path="Void"/></f></cancel>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<getVoices public="1" set="method"><f a=""><c path="Array"><c path="js.html.SpeechSynthesisVoice"/></c></f></getVoices>
		<meta><m n=":native"><e>"SpeechSynthesis"</e></m></meta>
	</class>
	<class path="js.html.SpeechSynthesisUtterance" params="" file="/usr/lib/haxe/std/js/html/SpeechSynthesisUtterance.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<text public="1"><c path="String"/></text>
		<lang public="1"><c path="String"/></lang>
		<voice public="1"><c path="js.html.SpeechSynthesisVoice"/></voice>
		<volume public="1"><x path="Float"/></volume>
		<rate public="1"><x path="Float"/></rate>
		<pitch public="1"><x path="Float"/></pitch>
		<onstart public="1"><x path="haxe.Function"/></onstart>
		<onend public="1"><x path="haxe.Function"/></onend>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onresume public="1"><x path="haxe.Function"/></onresume>
		<onmark public="1"><x path="haxe.Function"/></onmark>
		<onboundary public="1"><x path="haxe.Function"/></onboundary>
		<new public="1" set="method">
			<f a="text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"SpeechSynthesisUtterance"</e></m></meta>
	</class>
	<class path="js.html.SpeechSynthesisVoice" params="" file="/usr/lib/haxe/std/js/html/SpeechSynthesisVoice.hx" extern="1">
		<voiceURI public="1" set="null"><c path="String"/></voiceURI>
		<name public="1" set="null"><c path="String"/></name>
		<lang public="1" set="null"><c path="String"/></lang>
		<localService public="1" set="null"><x path="Bool"/></localService>
		<default_ public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":native"><e>"default"</e></m></meta>
		</default_>
		<meta><m n=":native"><e>"SpeechSynthesisVoice"</e></m></meta>
	</class>
	<class path="js.html.Storage" params="" file="/usr/lib/haxe/std/js/html/Storage.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<key public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</key>
		<getItem public="1" set="method">
			<f a="key">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getItem>
		<setItem public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setItem>
		<removeItem public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeItem>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clear>
		<meta><m n=":native"><e>"Storage"</e></m></meta>
	</class>
	<class path="js.html.StyleElement" params="" file="/usr/lib/haxe/std/js/html/StyleElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<media public="1"><c path="String"/></media>
		<type public="1"><c path="String"/></type>
		<scoped public="1"><x path="Bool"/></scoped>
		<sheet public="1" set="null"><c path="js.html.StyleSheet"/></sheet>
		<meta><m n=":native"><e>"HTMLStyleElement"</e></m></meta>
	</class>
	<class path="js.html.StyleSheetList" params="" file="/usr/lib/haxe/std/js/html/StyleSheetList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.StyleSheet"/>
</f></item>
		<meta><m n=":native"><e>"StyleSheetList"</e></m></meta>
	</class>
	<class path="js.html.TableCaptionElement" params="" file="/usr/lib/haxe/std/js/html/TableCaptionElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLTableCaptionElement"</e></m></meta>
	</class>
	<class path="js.html.TableCellElement" params="" file="/usr/lib/haxe/std/js/html/TableCellElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<colSpan public="1"><x path="Int"/></colSpan>
		<rowSpan public="1"><x path="Int"/></rowSpan>
		<headers public="1"><c path="String"/></headers>
		<cellIndex public="1" set="null"><x path="Int"/></cellIndex>
		<abbr public="1"><c path="String"/></abbr>
		<scope public="1"><c path="String"/></scope>
		<align public="1"><c path="String"/></align>
		<axis public="1"><c path="String"/></axis>
		<height public="1"><c path="String"/></height>
		<width public="1"><c path="String"/></width>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<noWrap public="1"><x path="Bool"/></noWrap>
		<vAlign public="1"><c path="String"/></vAlign>
		<bgColor public="1"><c path="String"/></bgColor>
		<meta><m n=":native"><e>"HTMLTableCellElement"</e></m></meta>
	</class>
	<class path="js.html.TableColElement" params="" file="/usr/lib/haxe/std/js/html/TableColElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<span public="1"><x path="Int"/></span>
		<align public="1"><c path="String"/></align>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<vAlign public="1"><c path="String"/></vAlign>
		<width public="1"><c path="String"/></width>
		<meta><m n=":native"><e>"HTMLTableColElement"</e></m></meta>
	</class>
	<class path="js.html.TableElement" params="" file="/usr/lib/haxe/std/js/html/TableElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<caption public="1"><c path="js.html.TableCaptionElement"/></caption>
		<tHead public="1"><c path="js.html.TableSectionElement"/></tHead>
		<tFoot public="1"><c path="js.html.TableSectionElement"/></tFoot>
		<tBodies public="1" set="null"><c path="js.html.HTMLCollection"/></tBodies>
		<rows public="1" set="null"><c path="js.html.HTMLCollection"/></rows>
		<align public="1"><c path="String"/></align>
		<border public="1"><c path="String"/></border>
		<frame public="1"><c path="String"/></frame>
		<rules public="1"><c path="String"/></rules>
		<summary public="1"><c path="String"/></summary>
		<width public="1"><c path="String"/></width>
		<bgColor public="1"><c path="String"/></bgColor>
		<cellPadding public="1"><c path="String"/></cellPadding>
		<cellSpacing public="1"><c path="String"/></cellSpacing>
		<createCaption public="1" set="method"><f a=""><c path="js.html.Element"/></f></createCaption>
		<deleteCaption public="1" set="method"><f a=""><x path="Void"/></f></deleteCaption>
		<createTHead public="1" set="method"><f a=""><c path="js.html.Element"/></f></createTHead>
		<deleteTHead public="1" set="method"><f a=""><x path="Void"/></f></deleteTHead>
		<createTFoot public="1" set="method"><f a=""><c path="js.html.Element"/></f></createTFoot>
		<deleteTFoot public="1" set="method"><f a=""><x path="Void"/></f></deleteTFoot>
		<createTBody public="1" set="method"><f a=""><c path="js.html.Element"/></f></createTBody>
		<insertRow public="1" set="method">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="js.html.Element"/>
			</f>
			<meta><m n=":value"><e>{index:-1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertRow>
		<deleteRow public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteRow>
		<meta><m n=":native"><e>"HTMLTableElement"</e></m></meta>
	</class>
	<class path="js.html.TableRowElement" params="" file="/usr/lib/haxe/std/js/html/TableRowElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<rowIndex public="1" set="null"><x path="Int"/></rowIndex>
		<sectionRowIndex public="1" set="null"><x path="Int"/></sectionRowIndex>
		<cells public="1" set="null"><c path="js.html.HTMLCollection"/></cells>
		<align public="1"><c path="String"/></align>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<vAlign public="1"><c path="String"/></vAlign>
		<bgColor public="1"><c path="String"/></bgColor>
		<insertCell public="1" set="method">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="js.html.Element"/>
			</f>
			<meta><m n=":value"><e>{index:-1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertCell>
		<deleteCell public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteCell>
		<meta><m n=":native"><e>"HTMLTableRowElement"</e></m></meta>
	</class>
	<class path="js.html.TableSectionElement" params="" file="/usr/lib/haxe/std/js/html/TableSectionElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<rows public="1" set="null"><c path="js.html.HTMLCollection"/></rows>
		<align public="1"><c path="String"/></align>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<vAlign public="1"><c path="String"/></vAlign>
		<insertRow public="1" set="method">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="js.html.Element"/>
			</f>
			<meta><m n=":value"><e>{index:-1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertRow>
		<deleteRow public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteRow>
		<meta><m n=":native"><e>"HTMLTableSectionElement"</e></m></meta>
	</class>
	<class path="js.html.TextAreaElement" params="" file="/usr/lib/haxe/std/js/html/TextAreaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<cols public="1"><x path="Int"/></cols>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<maxLength public="1"><x path="Int"/></maxLength>
		<name public="1"><c path="String"/></name>
		<placeholder public="1"><c path="String"/></placeholder>
		<readOnly public="1"><x path="Bool"/></readOnly>
		<required public="1"><x path="Bool"/></required>
		<rows public="1"><x path="Int"/></rows>
		<wrap public="1"><c path="String"/></wrap>
		<type public="1" set="null"><c path="String"/></type>
		<defaultValue public="1"><c path="String"/></defaultValue>
		<value public="1"><c path="String"/></value>
		<textLength public="1" set="null"><x path="Int"/></textLength>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<selectionStart public="1"><x path="Int"/></selectionStart>
		<selectionEnd public="1"><x path="Int"/></selectionEnd>
		<selectionDirection public="1"><c path="String"/></selectionDirection>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<select public="1" set="method"><f a=""><x path="Void"/></f></select>
		<setRangeText public="1" set="method">
			<f a="replacement:start:end:?selectionMode" v=":::&quot;preserve&quot;">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="js.html.SelectionMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{selectionMode:"preserve"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setRangeText public="1" set="method">
	<f a="replacement">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</setRangeText></overloads>
		</setRangeText>
		<setSelectionRange public="1" set="method">
			<f a="start:end:?direction">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setSelectionRange>
		<meta><m n=":native"><e>"HTMLTextAreaElement"</e></m></meta>
	</class>
	<class path="js.html.TextMetrics" params="" file="/usr/lib/haxe/std/js/html/TextMetrics.hx" extern="1">
		<width public="1" set="null"><x path="Float"/></width>
		<meta><m n=":native"><e>"TextMetrics"</e></m></meta>
	</class>
	<class path="js.html.TextTrack" params="" file="/usr/lib/haxe/std/js/html/TextTrack.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<kind public="1" set="null"><x path="js.html.TextTrackKind"/></kind>
		<label public="1" set="null"><c path="String"/></label>
		<language public="1" set="null"><c path="String"/></language>
		<id public="1" set="null"><c path="String"/></id>
		<inBandMetadataTrackDispatchType public="1" set="null"><c path="String"/></inBandMetadataTrackDispatchType>
		<mode public="1"><x path="js.html.TextTrackMode"/></mode>
		<cues public="1" set="null"><c path="js.html.TextTrackCueList"/></cues>
		<activeCues public="1" set="null"><c path="js.html.TextTrackCueList"/></activeCues>
		<addCue public="1" set="method"><f a="cue">
	<c path="js.html.VTTCue"/>
	<x path="Void"/>
</f></addCue>
		<removeCue public="1" set="method">
			<f a="cue">
				<c path="js.html.VTTCue"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeCue>
		<meta><m n=":native"><e>"TextTrack"</e></m></meta>
	</class>
	<class path="js.html.TextTrackCueList" params="" file="/usr/lib/haxe/std/js/html/TextTrackCueList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<getCueById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.VTTCue"/>
</f></getCueById>
		<meta><m n=":native"><e>"TextTrackCueList"</e></m></meta>
	</class>
	<abstract path="js.html.TextTrackKind" params="" file="/usr/lib/haxe/std/js/html/TextTrackKind.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._TextTrackKind.TextTrackKind_Impl_" params="" file="/usr/lib/haxe/std/js/html/TextTrackKind.hx" private="1" module="js.html.TextTrackKind"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.TextTrackList" params="" file="/usr/lib/haxe/std/js/html/TextTrackList.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<length public="1" set="null"><x path="Int"/></length>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onaddtrack public="1"><x path="haxe.Function"/></onaddtrack>
		<onremovetrack public="1"><x path="haxe.Function"/></onremovetrack>
		<getTrackById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.TextTrack"/>
</f></getTrackById>
		<meta><m n=":native"><e>"TextTrackList"</e></m></meta>
	</class>
	<abstract path="js.html.TextTrackMode" params="" file="/usr/lib/haxe/std/js/html/TextTrackMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._TextTrackMode.TextTrackMode_Impl_" params="" file="/usr/lib/haxe/std/js/html/TextTrackMode.hx" private="1" module="js.html.TextTrackMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.TimeRanges" params="" file="/usr/lib/haxe/std/js/html/TimeRanges.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<start public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</start>
		<end public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</end>
		<meta><m n=":native"><e>"TimeRanges"</e></m></meta>
	</class>
	<class path="js.html.TitleElement" params="" file="/usr/lib/haxe/std/js/html/TitleElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<text public="1"><c path="String"/></text>
		<meta><m n=":native"><e>"HTMLTitleElement"</e></m></meta>
	</class>
	<class path="js.html.Touch" params="" file="/usr/lib/haxe/std/js/html/Touch.hx" extern="1">
		<identifier public="1" set="null"><x path="Int"/></identifier>
		<target public="1" set="null"><c path="js.html.EventTarget"/></target>
		<screenX public="1" set="null"><x path="Int"/></screenX>
		<screenY public="1" set="null"><x path="Int"/></screenY>
		<clientX public="1" set="null"><x path="Int"/></clientX>
		<clientY public="1" set="null"><x path="Int"/></clientY>
		<pageX public="1" set="null"><x path="Int"/></pageX>
		<pageY public="1" set="null"><x path="Int"/></pageY>
		<radiusX public="1" set="null"><x path="Int"/></radiusX>
		<radiusY public="1" set="null"><x path="Int"/></radiusY>
		<rotationAngle public="1" set="null"><x path="Float"/></rotationAngle>
		<force public="1" set="null"><x path="Float"/></force>
		<meta><m n=":native"><e>"Touch"</e></m></meta>
	</class>
	<class path="js.html.TouchList" params="" file="/usr/lib/haxe/std/js/html/TouchList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Touch"/>
</f></item>
		<identifiedTouch public="1" set="method"><f a="identifier">
	<x path="Int"/>
	<c path="js.html.Touch"/>
</f></identifiedTouch>
		<meta><m n=":native"><e>"TouchList"</e></m></meta>
	</class>
	<class path="js.html.TrackElement" params="" file="/usr/lib/haxe/std/js/html/TrackElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<NONE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<LOADING public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</LOADING>
		<LOADED public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</LOADED>
		<ERROR public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</ERROR>
		<kind public="1"><c path="String"/></kind>
		<src public="1"><c path="String"/></src>
		<srclang public="1"><c path="String"/></srclang>
		<label public="1"><c path="String"/></label>
		<default_ public="1">
			<x path="Bool"/>
			<meta><m n=":native"><e>"default"</e></m></meta>
		</default_>
		<readyState public="1" set="null"><x path="Int"/></readyState>
		<track public="1" set="null"><c path="js.html.TextTrack"/></track>
		<meta><m n=":native"><e>"HTMLTrackElement"</e></m></meta>
	</class>
	<class path="js.html.TreeWalker" params="" file="/usr/lib/haxe/std/js/html/TreeWalker.hx" extern="1">
		<root public="1" set="null"><c path="js.html.Node"/></root>
		<whatToShow public="1" set="null"><x path="Int"/></whatToShow>
		<filter public="1" set="null"><c path="js.html.NodeFilter"/></filter>
		<currentNode public="1"><c path="js.html.Node"/></currentNode>
		<parentNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</parentNode>
		<firstChild public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</firstChild>
		<lastChild public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</lastChild>
		<previousSibling public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</previousSibling>
		<nextSibling public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</nextSibling>
		<previousNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</previousNode>
		<nextNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</nextNode>
		<meta><m n=":native"><e>"TreeWalker"</e></m></meta>
	</class>
	<typedef path="js.html.UIEventInit" params="" file="/usr/lib/haxe/std/js/html/UIEventInit.hx"><a>
	<view>
		<t path="Null"><c path="js.html.Window"/></t>
		<meta><m n=":optional"/></meta>
	</view>
	<detail>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</detail>
	<cancelable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</cancelable>
	<bubbles>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</bubbles>
</a></typedef>
	<class path="js.html.UListElement" params="" file="/usr/lib/haxe/std/js/html/UListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<compact public="1"><x path="Bool"/></compact>
		<type public="1"><c path="String"/></type>
		<meta><m n=":native"><e>"HTMLUListElement"</e></m></meta>
	</class>
	<class path="js.html.URLSearchParams" params="" file="/usr/lib/haxe/std/js/html/URLSearchParams.hx" extern="1">
		<append public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></append>
		<delete_ public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
		</delete_>
		<get public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<getAll public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getAll>
		<has public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<set public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></set>
		<new public="1" set="method">
			<f a="init">
				<c path="js.html.URLSearchParams"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?init" v="&quot;&quot;">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{init:""}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"URLSearchParams"</e></m></meta>
	</class>
	<class path="js.html.Uint8Array" params="" file="/usr/lib/haxe/std/js/html/Uint8Array.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
				<set public="1" set="method"><f a="array:?offset">
	<c path="js.html.Uint8Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
			</overloads>
		</set>
		<subarray public="1" set="method"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.Uint8Array"/>
</f></subarray>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="js.html.Uint8Array"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Int"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Uint8Array"</e></m>
		</meta>
	</class>
	<class path="js.html.Uint8ClampedArray" params="" file="/usr/lib/haxe/std/js/html/Uint8ClampedArray.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
				<set public="1" set="method"><f a="array:?offset">
	<c path="js.html.Uint8ClampedArray"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
			</overloads>
		</set>
		<subarray public="1" set="method"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.Uint8ClampedArray"/>
</f></subarray>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="js.html.Uint8ClampedArray"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Int"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Uint8ClampedArray"</e></m></meta>
	</class>
	<class path="js.html.VTTCue" params="" file="/usr/lib/haxe/std/js/html/VTTCue.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<track public="1" set="null"><c path="js.html.TextTrack"/></track>
		<id public="1"><c path="String"/></id>
		<startTime public="1"><x path="Float"/></startTime>
		<endTime public="1"><x path="Float"/></endTime>
		<pauseOnExit public="1"><x path="Bool"/></pauseOnExit>
		<region public="1"><c path="js.html.VTTRegion"/></region>
		<vertical public="1"><x path="js.html.DirectionSetting"/></vertical>
		<snapToLines public="1"><x path="Bool"/></snapToLines>
		<line public="1"><x path="haxe.extern.EitherType">
	<x path="Int"/>
	<d/>
</x></line>
		<lineAlign public="1"><x path="js.html.AlignSetting"/></lineAlign>
		<position public="1"><x path="Int"/></position>
		<positionAlign public="1"><x path="js.html.AlignSetting"/></positionAlign>
		<size public="1"><x path="Int"/></size>
		<align public="1"><x path="js.html.AlignSetting"/></align>
		<text public="1"><c path="String"/></text>
		<onenter public="1"><x path="haxe.Function"/></onenter>
		<onexit public="1"><x path="haxe.Function"/></onexit>
		<getCueAsHTML public="1" set="method"><f a=""><c path="js.html.DocumentFragment"/></f></getCueAsHTML>
		<new public="1" set="method">
			<f a="startTime:endTime:text">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"VTTCue"</e></m></meta>
	</class>
	<class path="js.html.VTTRegion" params="" file="/usr/lib/haxe/std/js/html/VTTRegion.hx" extern="1">
		<width public="1"><x path="Float"/></width>
		<lines public="1"><x path="Int"/></lines>
		<regionAnchorX public="1"><x path="Float"/></regionAnchorX>
		<regionAnchorY public="1"><x path="Float"/></regionAnchorY>
		<viewportAnchorX public="1"><x path="Float"/></viewportAnchorX>
		<viewportAnchorY public="1"><x path="Float"/></viewportAnchorY>
		<scroll public="1"><c path="String"/></scroll>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"VTTRegion"</e></m></meta>
	</class>
	<class path="js.html.ValidityState" params="" file="/usr/lib/haxe/std/js/html/ValidityState.hx" extern="1">
		<valueMissing public="1" set="null"><x path="Bool"/></valueMissing>
		<typeMismatch public="1" set="null"><x path="Bool"/></typeMismatch>
		<patternMismatch public="1" set="null"><x path="Bool"/></patternMismatch>
		<tooLong public="1" set="null"><x path="Bool"/></tooLong>
		<rangeUnderflow public="1" set="null"><x path="Bool"/></rangeUnderflow>
		<rangeOverflow public="1" set="null"><x path="Bool"/></rangeOverflow>
		<stepMismatch public="1" set="null"><x path="Bool"/></stepMismatch>
		<badInput public="1" set="null"><x path="Bool"/></badInput>
		<customError public="1" set="null"><x path="Bool"/></customError>
		<valid public="1" set="null"><x path="Bool"/></valid>
		<meta><m n=":native"><e>"ValidityState"</e></m></meta>
	</class>
	<class path="js.html.VideoElement" params="" file="/usr/lib/haxe/std/js/html/VideoElement.hx" extern="1">
		<extends path="js.html.MediaElement"/>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<poster public="1"><c path="String"/></poster>
		<getVideoPlaybackQuality public="1" set="method"><f a=""><c path="js.html.VideoPlaybackQuality"/></f></getVideoPlaybackQuality>
		<meta><m n=":native"><e>"HTMLVideoElement"</e></m></meta>
	</class>
	<class path="js.html.VideoPlaybackQuality" params="" file="/usr/lib/haxe/std/js/html/VideoPlaybackQuality.hx" extern="1">
		<creationTime public="1" set="null"><x path="Float"/></creationTime>
		<totalVideoFrames public="1" set="null"><x path="Int"/></totalVideoFrames>
		<droppedVideoFrames public="1" set="null"><x path="Int"/></droppedVideoFrames>
		<corruptedVideoFrames public="1" set="null"><x path="Int"/></corruptedVideoFrames>
		<meta><m n=":native"><e>"VideoPlaybackQuality"</e></m></meta>
	</class>
	<class path="js.html.VideoStreamTrack" params="" file="/usr/lib/haxe/std/js/html/VideoStreamTrack.hx" extern="1">
		<extends path="js.html.MediaStreamTrack"/>
		<meta><m n=":native"><e>"VideoStreamTrack"</e></m></meta>
	</class>
	<class path="js.html.VideoTrack" params="" file="/usr/lib/haxe/std/js/html/VideoTrack.hx" extern="1">
		<id public="1" set="null"><c path="String"/></id>
		<kind public="1" set="null"><c path="String"/></kind>
		<label public="1" set="null"><c path="String"/></label>
		<language public="1" set="null"><c path="String"/></language>
		<selected public="1"><x path="Bool"/></selected>
		<meta><m n=":native"><e>"VideoTrack"</e></m></meta>
	</class>
	<class path="js.html.VideoTrackList" params="" file="/usr/lib/haxe/std/js/html/VideoTrackList.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<length public="1" set="null"><x path="Int"/></length>
		<selectedIndex public="1" set="null"><x path="Int"/></selectedIndex>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onaddtrack public="1"><x path="haxe.Function"/></onaddtrack>
		<onremovetrack public="1"><x path="haxe.Function"/></onremovetrack>
		<getTrackById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.VideoTrack"/>
</f></getTrackById>
		<meta><m n=":native"><e>"VideoTrackList"</e></m></meta>
	</class>
	<abstract path="js.html.VisibilityState" params="" file="/usr/lib/haxe/std/js/html/VisibilityState.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._VisibilityState.VisibilityState_Impl_" params="" file="/usr/lib/haxe/std/js/html/VisibilityState.hx" private="1" module="js.html.VisibilityState"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.Window" params="" file="/usr/lib/haxe/std/js/html/Window.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<window public="1" set="null"><c path="js.html.Window"/></window>
		<self public="1" set="null"><c path="js.html.Window"/></self>
		<document public="1" set="null"><c path="js.html.HTMLDocument"/></document>
		<name public="1"><c path="String"/></name>
		<location public="1" set="null"><c path="js.html.Location"/></location>
		<history public="1" set="null"><c path="js.html.History"/></history>
		<locationbar public="1" set="null"><c path="js.html.BarProp"/></locationbar>
		<menubar public="1" set="null"><c path="js.html.BarProp"/></menubar>
		<personalbar public="1" set="null"><c path="js.html.BarProp"/></personalbar>
		<scrollbars public="1" set="null"><c path="js.html.BarProp"/></scrollbars>
		<statusbar public="1" set="null"><c path="js.html.BarProp"/></statusbar>
		<toolbar public="1" set="null"><c path="js.html.BarProp"/></toolbar>
		<status public="1"><c path="String"/></status>
		<closed public="1" set="null"><x path="Bool"/></closed>
		<frames public="1" set="null"><c path="js.html.Window"/></frames>
		<length public="1" set="null"><x path="Int"/></length>
		<top public="1" set="null"><c path="js.html.Window"/></top>
		<opener public="1"><d/></opener>
		<parent public="1" set="null"><c path="js.html.Window"/></parent>
		<frameElement public="1" set="null"><c path="js.html.Element"/></frameElement>
		<navigator public="1" set="null"><c path="js.html.Navigator"/></navigator>
		<applicationCache public="1" set="null"><c path="js.html.ApplicationCache"/></applicationCache>
		<orientation public="1" set="null"><x path="Int"/></orientation>
		<onorientationchange public="1"><x path="haxe.Function"/></onorientationchange>
		<screen public="1" set="null"><c path="js.html.Screen"/></screen>
		<innerWidth public="1"><x path="Int"/></innerWidth>
		<innerHeight public="1"><x path="Int"/></innerHeight>
		<scrollX public="1" set="null"><x path="Int"/></scrollX>
		<pageXOffset public="1" set="null"><x path="Int"/></pageXOffset>
		<scrollY public="1" set="null"><x path="Int"/></scrollY>
		<pageYOffset public="1" set="null"><x path="Int"/></pageYOffset>
		<screenX public="1"><x path="Int"/></screenX>
		<screenY public="1"><x path="Int"/></screenY>
		<outerWidth public="1"><x path="Int"/></outerWidth>
		<outerHeight public="1"><x path="Int"/></outerHeight>
		<performance public="1" set="null"><c path="js.html.Performance"/></performance>
		<crypto public="1" set="null"><d/></crypto>
		<devicePixelRatio public="1" set="null"><x path="Float"/></devicePixelRatio>
		<scrollMaxX public="1" set="null"><x path="Int"/></scrollMaxX>
		<scrollMaxY public="1" set="null"><x path="Int"/></scrollMaxY>
		<fullScreen public="1"><x path="Bool"/></fullScreen>
		<onwheel public="1"><x path="haxe.Function"/></onwheel>
		<ondevicemotion public="1"><x path="haxe.Function"/></ondevicemotion>
		<ondeviceorientation public="1"><x path="haxe.Function"/></ondeviceorientation>
		<ondeviceproximity public="1"><x path="haxe.Function"/></ondeviceproximity>
		<onuserproximity public="1"><x path="haxe.Function"/></onuserproximity>
		<ondevicelight public="1"><x path="haxe.Function"/></ondevicelight>
		<content public="1" set="null"><d/></content>
		<console public="1" set="null"><c path="js.html.Console"/></console>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onblur public="1"><x path="haxe.Function"/></onblur>
		<onfocus public="1"><x path="haxe.Function"/></onfocus>
		<oncanplay public="1"><x path="haxe.Function"/></oncanplay>
		<oncanplaythrough public="1"><x path="haxe.Function"/></oncanplaythrough>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onclick public="1"><x path="haxe.Function"/></onclick>
		<oncontextmenu public="1"><x path="haxe.Function"/></oncontextmenu>
		<ondblclick public="1"><x path="haxe.Function"/></ondblclick>
		<ondrag public="1"><x path="haxe.Function"/></ondrag>
		<ondragend public="1"><x path="haxe.Function"/></ondragend>
		<ondragenter public="1"><x path="haxe.Function"/></ondragenter>
		<ondragleave public="1"><x path="haxe.Function"/></ondragleave>
		<ondragover public="1"><x path="haxe.Function"/></ondragover>
		<ondragstart public="1"><x path="haxe.Function"/></ondragstart>
		<ondrop public="1"><x path="haxe.Function"/></ondrop>
		<ondurationchange public="1"><x path="haxe.Function"/></ondurationchange>
		<onemptied public="1"><x path="haxe.Function"/></onemptied>
		<onended public="1"><x path="haxe.Function"/></onended>
		<oninput public="1"><x path="haxe.Function"/></oninput>
		<oninvalid public="1"><x path="haxe.Function"/></oninvalid>
		<onkeydown public="1"><x path="haxe.Function"/></onkeydown>
		<onkeypress public="1"><x path="haxe.Function"/></onkeypress>
		<onkeyup public="1"><x path="haxe.Function"/></onkeyup>
		<onload public="1"><x path="haxe.Function"/></onload>
		<onloadeddata public="1"><x path="haxe.Function"/></onloadeddata>
		<onloadedmetadata public="1"><x path="haxe.Function"/></onloadedmetadata>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onmousedown public="1"><x path="haxe.Function"/></onmousedown>
		<onmouseenter public="1"><x path="haxe.Function"/></onmouseenter>
		<onmouseleave public="1"><x path="haxe.Function"/></onmouseleave>
		<onmousemove public="1"><x path="haxe.Function"/></onmousemove>
		<onmouseout public="1"><x path="haxe.Function"/></onmouseout>
		<onmouseover public="1"><x path="haxe.Function"/></onmouseover>
		<onmouseup public="1"><x path="haxe.Function"/></onmouseup>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onplay public="1"><x path="haxe.Function"/></onplay>
		<onplaying public="1"><x path="haxe.Function"/></onplaying>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onratechange public="1"><x path="haxe.Function"/></onratechange>
		<onreset public="1"><x path="haxe.Function"/></onreset>
		<onscroll public="1"><x path="haxe.Function"/></onscroll>
		<onseeked public="1"><x path="haxe.Function"/></onseeked>
		<onseeking public="1"><x path="haxe.Function"/></onseeking>
		<onselect public="1"><x path="haxe.Function"/></onselect>
		<onshow public="1"><x path="haxe.Function"/></onshow>
		<onstalled public="1"><x path="haxe.Function"/></onstalled>
		<onsubmit public="1"><x path="haxe.Function"/></onsubmit>
		<onsuspend public="1"><x path="haxe.Function"/></onsuspend>
		<ontimeupdate public="1"><x path="haxe.Function"/></ontimeupdate>
		<onvolumechange public="1"><x path="haxe.Function"/></onvolumechange>
		<onwaiting public="1"><x path="haxe.Function"/></onwaiting>
		<onpointercancel public="1"><x path="haxe.Function"/></onpointercancel>
		<onpointerdown public="1"><x path="haxe.Function"/></onpointerdown>
		<onpointerup public="1"><x path="haxe.Function"/></onpointerup>
		<onpointermove public="1"><x path="haxe.Function"/></onpointermove>
		<onpointerout public="1"><x path="haxe.Function"/></onpointerout>
		<onpointerover public="1"><x path="haxe.Function"/></onpointerover>
		<onpointerenter public="1"><x path="haxe.Function"/></onpointerenter>
		<onpointerleave public="1"><x path="haxe.Function"/></onpointerleave>
		<ongotpointercapture public="1"><x path="haxe.Function"/></ongotpointercapture>
		<onlostpointercapture public="1"><x path="haxe.Function"/></onlostpointercapture>
		<onpointerlockchange public="1"><x path="haxe.Function"/></onpointerlockchange>
		<onpointerlockerror public="1"><x path="haxe.Function"/></onpointerlockerror>
		<indexedDB public="1" set="null"><c path="js.html.idb.Factory"/></indexedDB>
		<onerror public="1"><f a="::::">
	<x path="haxe.extern.EitherType">
		<c path="js.html.Event"/>
		<c path="String"/>
	</x>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<x path="Bool"/>
</f></onerror>
		<speechSynthesis public="1" set="null"><c path="js.html.SpeechSynthesis"/></speechSynthesis>
		<ontouchstart public="1"><x path="haxe.Function"/></ontouchstart>
		<ontouchend public="1"><x path="haxe.Function"/></ontouchend>
		<ontouchmove public="1"><x path="haxe.Function"/></ontouchmove>
		<ontouchcancel public="1"><x path="haxe.Function"/></ontouchcancel>
		<onafterprint public="1"><x path="haxe.Function"/></onafterprint>
		<onbeforeprint public="1"><x path="haxe.Function"/></onbeforeprint>
		<onbeforeunload public="1"><f a="">
	<c path="js.html.Event"/>
	<c path="String"/>
</f></onbeforeunload>
		<onhashchange public="1"><x path="haxe.Function"/></onhashchange>
		<onlanguagechange public="1"><x path="haxe.Function"/></onlanguagechange>
		<onmessage public="1"><x path="haxe.Function"/></onmessage>
		<onoffline public="1"><x path="haxe.Function"/></onoffline>
		<ononline public="1"><x path="haxe.Function"/></ononline>
		<onpagehide public="1"><x path="haxe.Function"/></onpagehide>
		<onpageshow public="1"><x path="haxe.Function"/></onpageshow>
		<onpopstate public="1"><x path="haxe.Function"/></onpopstate>
		<onresize public="1"><x path="haxe.Function"/></onresize>
		<onunload public="1"><x path="haxe.Function"/></onunload>
		<localStorage public="1" set="null"><c path="js.html.Storage"/></localStorage>
		<sessionStorage public="1" set="null"><c path="js.html.Storage"/></sessionStorage>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</close>
		<stop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stop>
		<focus public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</focus>
		<blur public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</blur>
		<open public="1" set="method">
			<f a="?url:?target:?features" v="&quot;&quot;:&quot;&quot;:&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Window"/>
			</f>
			<meta><m n=":value"><e>{features:"",target:"",url:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</open>
		<alert public="1" set="method">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><alert public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</alert></overloads>
		</alert>
		<confirm public="1" set="method">
			<f a="?message" v="&quot;&quot;">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{message:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</confirm>
		<prompt public="1" set="method">
			<f a="?message:?default_" v="&quot;&quot;:&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{default_:"",message:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</prompt>
		<print public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</print>
		<postMessage public="1" set="method">
			<f a="message:targetOrigin:?transfer">
				<d/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</postMessage>
		<captureEvents public="1" set="method"><f a=""><x path="Void"/></f></captureEvents>
		<releaseEvents public="1" set="method"><f a=""><x path="Void"/></f></releaseEvents>
		<getSelection public="1" set="method">
			<f a=""><c path="js.html.Selection"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getSelection>
		<getComputedStyle public="1" set="method">
			<f a="elt:?pseudoElt" v=":&quot;&quot;">
				<c path="js.html.Element"/>
				<c path="String"/>
				<c path="js.html.CSSStyleDeclaration"/>
			</f>
			<meta><m n=":value"><e>{pseudoElt:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getComputedStyle>
		<matchMedia public="1" set="method">
			<f a="query">
				<c path="String"/>
				<c path="js.html.MediaQueryList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</matchMedia>
		<moveTo public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</moveTo>
		<moveBy public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</moveBy>
		<resizeTo public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</resizeTo>
		<resizeBy public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</resizeBy>
		<scroll public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scroll public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scroll></overloads>
		</scroll>
		<scrollTo public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollTo></overloads>
		</scrollTo>
		<scrollBy public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollBy public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollBy></overloads>
		</scrollBy>
		<requestAnimationFrame public="1" set="method">
			<f a="callback">
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</requestAnimationFrame>
		<cancelAnimationFrame public="1" set="method">
			<f a="handle">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cancelAnimationFrame>
		<getDefaultComputedStyle public="1" set="method">
			<f a="elt:?pseudoElt" v=":&quot;&quot;">
				<c path="js.html.Element"/>
				<c path="String"/>
				<c path="js.html.CSSStyleDeclaration"/>
			</f>
			<meta><m n=":value"><e>{pseudoElt:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getDefaultComputedStyle>
		<scrollByLines public="1" set="method"><f a="numLines:?options">
	<x path="Int"/>
	<t path="js.html.ScrollOptions"/>
	<x path="Void"/>
</f></scrollByLines>
		<scrollByPages public="1" set="method"><f a="numPages:?options">
	<x path="Int"/>
	<t path="js.html.ScrollOptions"/>
	<x path="Void"/>
</f></scrollByPages>
		<sizeToContent public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</sizeToContent>
		<updateCommands public="1" set="method">
			<f a="action:?sel:?reason" v="::0">
				<c path="String"/>
				<c path="js.html.Selection"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{reason:0}</e></m></meta>
		</updateCommands>
		<find public="1" set="method">
			<f a="?str:?caseSensitive:?backwards:?wrapAround:?wholeWord:?searchInFrames:?showDialog" v="&quot;&quot;:false:false:false:false:false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{showDialog:false,searchInFrames:false,wholeWord:false,wrapAround:false,backwards:false,caseSensitive:false,str:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</find>
		<dump public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></dump>
		<setResizable public="1" set="method"><f a="resizable">
	<x path="Bool"/>
	<x path="Void"/>
</f></setResizable>
		<btoa public="1" set="method">
			<f a="btoa">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</btoa>
		<atob public="1" set="method">
			<f a="atob">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</atob>
		<setTimeout public="1" set="method">
			<f a="handler:?timeout:unused" v=":0:">
				<c path="String"/>
				<x path="Int"/>
				<x path="haxe.extern.Rest"><d/></x>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{timeout:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setTimeout public="1" set="method">
	<f a="handler:?timeout:arguments" v=":0:">
		<x path="haxe.Function"/>
		<x path="Int"/>
		<x path="haxe.extern.Rest"><d/></x>
		<x path="Int"/>
	</f>
	<meta><m n=":value"><e>{timeout:0}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</setTimeout></overloads>
		</setTimeout>
		<clearTimeout public="1" set="method">
			<f a="?handle" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{handle:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clearTimeout>
		<setInterval public="1" set="method">
			<f a="handler:?timeout:unused">
				<c path="String"/>
				<x path="Int"/>
				<x path="haxe.extern.Rest"><d/></x>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setInterval public="1" set="method">
	<f a="handler:?timeout:arguments">
		<x path="haxe.Function"/>
		<x path="Int"/>
		<x path="haxe.extern.Rest"><d/></x>
		<x path="Int"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</setInterval></overloads>
		</setInterval>
		<clearInterval public="1" set="method">
			<f a="?handle" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{handle:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clearInterval>
		<meta><m n=":native"><e>"Window"</e></m></meta>
	</class>
	<class path="js.html.XMLHttpRequestEventTarget" params="" file="/usr/lib/haxe/std/js/html/XMLHttpRequestEventTarget.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onload public="1"><x path="haxe.Function"/></onload>
		<ontimeout public="1"><x path="haxe.Function"/></ontimeout>
		<onloadend public="1"><x path="haxe.Function"/></onloadend>
		<meta><m n=":native"><e>"XMLHttpRequestEventTarget"</e></m></meta>
	</class>
	<class path="js.html.XMLHttpRequest" params="" file="/usr/lib/haxe/std/js/html/XMLHttpRequest.hx" extern="1">
		<extends path="js.html.XMLHttpRequestEventTarget"/>
		<UNSENT public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UNSENT>
		<OPENED public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</OPENED>
		<HEADERS_RECEIVED public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</HEADERS_RECEIVED>
		<LOADING public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</LOADING>
		<DONE public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</DONE>
		<onreadystatechange public="1"><x path="haxe.Function"/></onreadystatechange>
		<readyState public="1" set="null"><x path="Int"/></readyState>
		<timeout public="1"><x path="Int"/></timeout>
		<withCredentials public="1"><x path="Bool"/></withCredentials>
		<upload public="1" set="null"><c path="js.html.XMLHttpRequestUpload"/></upload>
		<responseURL public="1" set="null"><c path="String"/></responseURL>
		<status public="1" set="null"><x path="Int"/></status>
		<statusText public="1" set="null"><c path="String"/></statusText>
		<responseType public="1"><x path="js.html.XMLHttpRequestResponseType"/></responseType>
		<response public="1" set="null"><d/></response>
		<responseText public="1" set="null"><c path="String"/></responseText>
		<responseXML public="1" set="null"><c path="js.html.HTMLDocument"/></responseXML>
		<open public="1" set="method">
			<f a="method:url:async:?user:?password">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><open public="1" set="method">
	<f a="method:url">
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</open></overloads>
		</open>
		<setRequestHeader public="1" set="method">
			<f a="header:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setRequestHeader>
		<send public="1" set="method">
			<f a="data">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<send public="1" set="method">
					<f a=""><x path="Void"/></f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.ArrayBuffer"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.ArrayBufferView"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.Blob"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.HTMLDocument"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.FormData"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
			</overloads>
		</send>
		<abort public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</abort>
		<getResponseHeader public="1" set="method">
			<f a="header">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getResponseHeader>
		<getAllResponseHeaders public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getAllResponseHeaders>
		<overrideMimeType public="1" set="method">
			<f a="mime">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</overrideMimeType>
		<sendAsBinary public="1" set="method">
			<f a="body">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</sendAsBinary>
		<new public="1" set="method">
			<f a="ignored">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?params">
		<d/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"XMLHttpRequest"</e></m>
		</meta>
	</class>
	<abstract path="js.html.XMLHttpRequestResponseType" params="" file="/usr/lib/haxe/std/js/html/XMLHttpRequestResponseType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._XMLHttpRequestResponseType.XMLHttpRequestResponseType_Impl_" params="" file="/usr/lib/haxe/std/js/html/XMLHttpRequestResponseType.hx" private="1" module="js.html.XMLHttpRequestResponseType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.XMLHttpRequestUpload" params="" file="/usr/lib/haxe/std/js/html/XMLHttpRequestUpload.hx" extern="1">
		<extends path="js.html.XMLHttpRequestEventTarget"/>
		<meta><m n=":native"><e>"XMLHttpRequestUpload"</e></m></meta>
	</class>
	<class path="js.html.XPathExpression" params="" file="/usr/lib/haxe/std/js/html/XPathExpression.hx" extern="1">
		<evaluate public="1" set="method">
			<f a="contextNode:type:result">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<d/>
				<c path="js.html.XPathResult"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</evaluate>
		<meta><m n=":native"><e>"XPathExpression"</e></m></meta>
	</class>
	<class path="js.html.XPathNSResolver" params="" file="/usr/lib/haxe/std/js/html/XPathNSResolver.hx" extern="1">
		<lookupNamespaceURI public="1" set="method"><f a="prefix">
	<c path="String"/>
	<c path="String"/>
</f></lookupNamespaceURI>
		<meta><m n=":native"><e>"XPathNSResolver"</e></m></meta>
	</class>
	<class path="js.html.XPathResult" params="" file="/usr/lib/haxe/std/js/html/XPathResult.hx" extern="1">
		<ANY_TYPE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ANY_TYPE>
		<NUMBER_TYPE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</NUMBER_TYPE>
		<STRING_TYPE public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</STRING_TYPE>
		<BOOLEAN_TYPE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</BOOLEAN_TYPE>
		<UNORDERED_NODE_ITERATOR_TYPE public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</UNORDERED_NODE_ITERATOR_TYPE>
		<ORDERED_NODE_ITERATOR_TYPE public="1" get="inline" set="null" expr="5" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</ORDERED_NODE_ITERATOR_TYPE>
		<UNORDERED_NODE_SNAPSHOT_TYPE public="1" get="inline" set="null" expr="6" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</UNORDERED_NODE_SNAPSHOT_TYPE>
		<ORDERED_NODE_SNAPSHOT_TYPE public="1" get="inline" set="null" expr="7" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</ORDERED_NODE_SNAPSHOT_TYPE>
		<ANY_UNORDERED_NODE_TYPE public="1" get="inline" set="null" expr="8" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</ANY_UNORDERED_NODE_TYPE>
		<FIRST_ORDERED_NODE_TYPE public="1" get="inline" set="null" expr="9" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</FIRST_ORDERED_NODE_TYPE>
		<resultType public="1" set="null"><x path="Int"/></resultType>
		<numberValue public="1" set="null"><x path="Float"/></numberValue>
		<stringValue public="1" set="null"><c path="String"/></stringValue>
		<booleanValue public="1" set="null"><x path="Bool"/></booleanValue>
		<singleNodeValue public="1" set="null"><c path="js.html.Node"/></singleNodeValue>
		<invalidIteratorState public="1" set="null"><x path="Bool"/></invalidIteratorState>
		<snapshotLength public="1" set="null"><x path="Int"/></snapshotLength>
		<iterateNext public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</iterateNext>
		<snapshotItem public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</snapshotItem>
		<meta><m n=":native"><e>"XPathResult"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioNode" params="" file="/usr/lib/haxe/std/js/html/audio/AudioNode.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<context public="1" set="null"><c path="js.html.audio.AudioContext"/></context>
		<numberOfInputs public="1" set="null"><x path="Int"/></numberOfInputs>
		<numberOfOutputs public="1" set="null"><x path="Int"/></numberOfOutputs>
		<channelCount public="1"><x path="Int"/></channelCount>
		<channelCountMode public="1"><x path="js.html.audio.ChannelCountMode"/></channelCountMode>
		<channelInterpretation public="1"><x path="js.html.audio.ChannelInterpretation"/></channelInterpretation>
		<connect public="1" set="method">
			<f a="destination:?output" v=":0">
				<c path="js.html.audio.AudioParam"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{output:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><connect public="1" set="method">
	<f a="destination:?output:?input" v=":0:0">
		<c path="js.html.audio.AudioNode"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{input:0,output:0}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</connect></overloads>
		</connect>
		<disconnect public="1" set="method">
			<f a="?output" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{output:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</disconnect>
		<meta><m n=":native"><e>"AudioNode"</e></m></meta>
	</class>
	<class path="js.html.audio.AnalyserNode" params="" file="/usr/lib/haxe/std/js/html/audio/AnalyserNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<fftSize public="1"><x path="Int"/></fftSize>
		<frequencyBinCount public="1" set="null"><x path="Int"/></frequencyBinCount>
		<minDecibels public="1"><x path="Float"/></minDecibels>
		<maxDecibels public="1"><x path="Float"/></maxDecibels>
		<smoothingTimeConstant public="1"><x path="Float"/></smoothingTimeConstant>
		<getFloatFrequencyData public="1" set="method"><f a="array">
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></getFloatFrequencyData>
		<getByteFrequencyData public="1" set="method"><f a="array">
	<c path="js.html.Uint8Array"/>
	<x path="Void"/>
</f></getByteFrequencyData>
		<getFloatTimeDomainData public="1" set="method"><f a="array">
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></getFloatTimeDomainData>
		<getByteTimeDomainData public="1" set="method"><f a="array">
	<c path="js.html.Uint8Array"/>
	<x path="Void"/>
</f></getByteTimeDomainData>
		<meta><m n=":native"><e>"AnalyserNode"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioBuffer" params="" file="/usr/lib/haxe/std/js/html/audio/AudioBuffer.hx" extern="1">
		<sampleRate public="1" set="null"><x path="Float"/></sampleRate>
		<length public="1" set="null"><x path="Int"/></length>
		<duration public="1" set="null"><x path="Float"/></duration>
		<numberOfChannels public="1" set="null"><x path="Int"/></numberOfChannels>
		<getChannelData public="1" set="method">
			<f a="channel">
				<x path="Int"/>
				<c path="js.html.Float32Array"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getChannelData>
		<copyFromChannel public="1" set="method">
			<f a="destination:channelNumber:?startInChannel" v="::0">
				<c path="js.html.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{startInChannel:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</copyFromChannel>
		<copyToChannel public="1" set="method">
			<f a="source:channelNumber:?startInChannel" v="::0">
				<c path="js.html.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{startInChannel:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</copyToChannel>
		<meta><m n=":native"><e>"AudioBuffer"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioBufferSourceNode" params="" file="/usr/lib/haxe/std/js/html/audio/AudioBufferSourceNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<buffer public="1"><c path="js.html.audio.AudioBuffer"/></buffer>
		<playbackRate public="1" set="null"><c path="js.html.audio.AudioParam"/></playbackRate>
		<loop public="1"><x path="Bool"/></loop>
		<loopStart public="1"><x path="Float"/></loopStart>
		<loopEnd public="1"><x path="Float"/></loopEnd>
		<onended public="1"><x path="haxe.Function"/></onended>
		<start public="1" set="method">
			<f a="?when:?grainOffset:?grainDuration" v="0.0:0.0:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{grainOffset:0.0,when:0.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</start>
		<stop public="1" set="method">
			<f a="?when" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{when:0.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stop>
		<meta><m n=":native"><e>"AudioBufferSourceNode"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioContext" params="" file="/usr/lib/haxe/std/js/html/audio/AudioContext.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<destination public="1" set="null"><c path="js.html.audio.AudioDestinationNode"/></destination>
		<sampleRate public="1" set="null"><x path="Float"/></sampleRate>
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<listener public="1" set="null"><c path="js.html.audio.AudioListener"/></listener>
		<createBuffer public="1" set="method">
			<f a="numberOfChannels:length:sampleRate">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="js.html.audio.AudioBuffer"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createBuffer>
		<decodeAudioData public="1" set="method"><f a="audioData:?successCallback:?errorCallback">
	<c path="js.html.ArrayBuffer"/>
	<f a="">
		<c path="js.html.audio.AudioBuffer"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<c path="js.Promise"><c path="js.html.audio.AudioBuffer"/></c>
</f></decodeAudioData>
		<createBufferSource public="1" set="method"><f a=""><c path="js.html.audio.AudioBufferSourceNode"/></f></createBufferSource>
		<createMediaStreamDestination public="1" set="method">
			<f a=""><c path="js.html.audio.MediaStreamAudioDestinationNode"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createMediaStreamDestination>
		<createScriptProcessor public="1" set="method">
			<f a="?bufferSize:?numberOfInputChannels:?numberOfOutputChannels" v="0:2:2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.audio.ScriptProcessorNode"/>
			</f>
			<meta><m n=":value"><e>{numberOfOutputChannels:2,numberOfInputChannels:2,bufferSize:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createScriptProcessor>
		<createStereoPanner public="1" set="method"><f a=""><c path="js.html.audio.StereoPannerNode"/></f></createStereoPanner>
		<createAnalyser public="1" set="method"><f a=""><c path="js.html.audio.AnalyserNode"/></f></createAnalyser>
		<createMediaElementSource public="1" set="method">
			<f a="mediaElement">
				<c path="js.html.MediaElement"/>
				<c path="js.html.audio.MediaElementAudioSourceNode"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createMediaElementSource>
		<createMediaStreamSource public="1" set="method">
			<f a="mediaStream">
				<c path="js.html.MediaStream"/>
				<c path="js.html.audio.MediaStreamAudioSourceNode"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createMediaStreamSource>
		<createGain public="1" set="method"><f a=""><c path="js.html.audio.GainNode"/></f></createGain>
		<createDelay public="1" set="method">
			<f a="?maxDelayTime" v="1.0">
				<x path="Float"/>
				<c path="js.html.audio.DelayNode"/>
			</f>
			<meta><m n=":value"><e>{maxDelayTime:1.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createDelay>
		<createBiquadFilter public="1" set="method"><f a=""><c path="js.html.audio.BiquadFilterNode"/></f></createBiquadFilter>
		<createWaveShaper public="1" set="method"><f a=""><c path="js.html.audio.WaveShaperNode"/></f></createWaveShaper>
		<createPanner public="1" set="method"><f a=""><c path="js.html.audio.PannerNode"/></f></createPanner>
		<createConvolver public="1" set="method"><f a=""><c path="js.html.audio.ConvolverNode"/></f></createConvolver>
		<createChannelSplitter public="1" set="method">
			<f a="?numberOfOutputs" v="6">
				<x path="Int"/>
				<c path="js.html.audio.ChannelSplitterNode"/>
			</f>
			<meta><m n=":value"><e>{numberOfOutputs:6}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createChannelSplitter>
		<createChannelMerger public="1" set="method">
			<f a="?numberOfInputs" v="6">
				<x path="Int"/>
				<c path="js.html.audio.ChannelMergerNode"/>
			</f>
			<meta><m n=":value"><e>{numberOfInputs:6}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createChannelMerger>
		<createDynamicsCompressor public="1" set="method"><f a=""><c path="js.html.audio.DynamicsCompressorNode"/></f></createDynamicsCompressor>
		<createOscillator public="1" set="method"><f a=""><c path="js.html.audio.OscillatorNode"/></f></createOscillator>
		<createPeriodicWave public="1" set="method">
			<f a="real:imag">
				<c path="js.html.Float32Array"/>
				<c path="js.html.Float32Array"/>
				<c path="js.html.audio.PeriodicWave"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createPeriodicWave>
		<new public="1" set="method">
			<f a="audioChannelType">
				<x path="js.html.AudioChannel"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"AudioContext"</e></m>
		</meta>
	</class>
	<class path="js.html.audio.AudioDestinationNode" params="" file="/usr/lib/haxe/std/js/html/audio/AudioDestinationNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<maxChannelCount public="1" set="null"><x path="Int"/></maxChannelCount>
		<meta><m n=":native"><e>"AudioDestinationNode"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioListener" params="" file="/usr/lib/haxe/std/js/html/audio/AudioListener.hx" extern="1">
		<dopplerFactor public="1"><x path="Float"/></dopplerFactor>
		<speedOfSound public="1"><x path="Float"/></speedOfSound>
		<setPosition public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<setOrientation public="1" set="method"><f a="x:y:z:xUp:yUp:zUp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOrientation>
		<setVelocity public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVelocity>
		<meta><m n=":native"><e>"AudioListener"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioParam" params="" file="/usr/lib/haxe/std/js/html/audio/AudioParam.hx" extern="1">
		<value public="1"><x path="Float"/></value>
		<defaultValue public="1" set="null"><x path="Float"/></defaultValue>
		<setValueAtTime public="1" set="method">
			<f a="value:startTime">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setValueAtTime>
		<linearRampToValueAtTime public="1" set="method">
			<f a="value:endTime">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</linearRampToValueAtTime>
		<exponentialRampToValueAtTime public="1" set="method">
			<f a="value:endTime">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</exponentialRampToValueAtTime>
		<setTargetAtTime public="1" set="method">
			<f a="target:startTime:timeConstant">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setTargetAtTime>
		<setValueCurveAtTime public="1" set="method">
			<f a="values:startTime:duration">
				<c path="js.html.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setValueCurveAtTime>
		<cancelScheduledValues public="1" set="method">
			<f a="startTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cancelScheduledValues>
		<meta><m n=":native"><e>"AudioParam"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioProcessingEvent" params="" file="/usr/lib/haxe/std/js/html/audio/AudioProcessingEvent.hx" extern="1">
		<extends path="js.html.Event"/>
		<playbackTime public="1" set="null"><x path="Float"/></playbackTime>
		<inputBuffer public="1" set="null"><c path="js.html.audio.AudioBuffer"/></inputBuffer>
		<outputBuffer public="1" set="null"><c path="js.html.audio.AudioBuffer"/></outputBuffer>
		<meta><m n=":native"><e>"AudioProcessingEvent"</e></m></meta>
	</class>
	<class path="js.html.audio.BiquadFilterNode" params="" file="/usr/lib/haxe/std/js/html/audio/BiquadFilterNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<type public="1"><x path="js.html.audio.BiquadFilterType"/></type>
		<frequency public="1" set="null"><c path="js.html.audio.AudioParam"/></frequency>
		<detune public="1" set="null"><c path="js.html.audio.AudioParam"/></detune>
		<Q public="1" set="null"><c path="js.html.audio.AudioParam"/></Q>
		<gain public="1" set="null"><c path="js.html.audio.AudioParam"/></gain>
		<getFrequencyResponse public="1" set="method"><f a="frequencyHz:magResponse:phaseResponse">
	<c path="js.html.Float32Array"/>
	<c path="js.html.Float32Array"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></getFrequencyResponse>
		<meta><m n=":native"><e>"BiquadFilterNode"</e></m></meta>
	</class>
	<abstract path="js.html.audio.BiquadFilterType" params="" file="/usr/lib/haxe/std/js/html/audio/BiquadFilterType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._BiquadFilterType.BiquadFilterType_Impl_" params="" file="/usr/lib/haxe/std/js/html/audio/BiquadFilterType.hx" private="1" module="js.html.audio.BiquadFilterType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="js.html.audio.ChannelCountMode" params="" file="/usr/lib/haxe/std/js/html/audio/ChannelCountMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._ChannelCountMode.ChannelCountMode_Impl_" params="" file="/usr/lib/haxe/std/js/html/audio/ChannelCountMode.hx" private="1" module="js.html.audio.ChannelCountMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="js.html.audio.ChannelInterpretation" params="" file="/usr/lib/haxe/std/js/html/audio/ChannelInterpretation.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._ChannelInterpretation.ChannelInterpretation_Impl_" params="" file="/usr/lib/haxe/std/js/html/audio/ChannelInterpretation.hx" private="1" module="js.html.audio.ChannelInterpretation"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.audio.ChannelMergerNode" params="" file="/usr/lib/haxe/std/js/html/audio/ChannelMergerNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<meta><m n=":native"><e>"ChannelMergerNode"</e></m></meta>
	</class>
	<class path="js.html.audio.ChannelSplitterNode" params="" file="/usr/lib/haxe/std/js/html/audio/ChannelSplitterNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<meta><m n=":native"><e>"ChannelSplitterNode"</e></m></meta>
	</class>
	<class path="js.html.audio.ConvolverNode" params="" file="/usr/lib/haxe/std/js/html/audio/ConvolverNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<buffer public="1"><c path="js.html.audio.AudioBuffer"/></buffer>
		<normalize public="1"><x path="Bool"/></normalize>
		<meta><m n=":native"><e>"ConvolverNode"</e></m></meta>
	</class>
	<class path="js.html.audio.DelayNode" params="" file="/usr/lib/haxe/std/js/html/audio/DelayNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<delayTime public="1" set="null"><c path="js.html.audio.AudioParam"/></delayTime>
		<meta><m n=":native"><e>"DelayNode"</e></m></meta>
	</class>
	<abstract path="js.html.audio.DistanceModelType" params="" file="/usr/lib/haxe/std/js/html/audio/DistanceModelType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._DistanceModelType.DistanceModelType_Impl_" params="" file="/usr/lib/haxe/std/js/html/audio/DistanceModelType.hx" private="1" module="js.html.audio.DistanceModelType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.audio.DynamicsCompressorNode" params="" file="/usr/lib/haxe/std/js/html/audio/DynamicsCompressorNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<threshold public="1" set="null"><c path="js.html.audio.AudioParam"/></threshold>
		<knee public="1" set="null"><c path="js.html.audio.AudioParam"/></knee>
		<ratio public="1" set="null"><c path="js.html.audio.AudioParam"/></ratio>
		<reduction public="1" set="null"><c path="js.html.audio.AudioParam"/></reduction>
		<attack public="1" set="null"><c path="js.html.audio.AudioParam"/></attack>
		<release public="1" set="null"><c path="js.html.audio.AudioParam"/></release>
		<meta><m n=":native"><e>"DynamicsCompressorNode"</e></m></meta>
	</class>
	<class path="js.html.audio.GainNode" params="" file="/usr/lib/haxe/std/js/html/audio/GainNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<gain public="1" set="null"><c path="js.html.audio.AudioParam"/></gain>
		<meta><m n=":native"><e>"GainNode"</e></m></meta>
	</class>
	<class path="js.html.audio.MediaElementAudioSourceNode" params="" file="/usr/lib/haxe/std/js/html/audio/MediaElementAudioSourceNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<meta><m n=":native"><e>"MediaElementAudioSourceNode"</e></m></meta>
	</class>
	<class path="js.html.audio.MediaStreamAudioDestinationNode" params="" file="/usr/lib/haxe/std/js/html/audio/MediaStreamAudioDestinationNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<stream public="1" set="null"><c path="js.html.MediaStream"/></stream>
		<meta><m n=":native"><e>"MediaStreamAudioDestinationNode"</e></m></meta>
	</class>
	<class path="js.html.audio.MediaStreamAudioSourceNode" params="" file="/usr/lib/haxe/std/js/html/audio/MediaStreamAudioSourceNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<meta><m n=":native"><e>"MediaStreamAudioSourceNode"</e></m></meta>
	</class>
	<class path="js.html.audio.OscillatorNode" params="" file="/usr/lib/haxe/std/js/html/audio/OscillatorNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<type public="1"><x path="js.html.audio.OscillatorType"/></type>
		<frequency public="1" set="null"><c path="js.html.audio.AudioParam"/></frequency>
		<detune public="1" set="null"><c path="js.html.audio.AudioParam"/></detune>
		<onended public="1"><x path="haxe.Function"/></onended>
		<start public="1" set="method">
			<f a="?when" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{when:0.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</start>
		<stop public="1" set="method">
			<f a="?when" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{when:0.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stop>
		<setPeriodicWave public="1" set="method"><f a="periodicWave">
	<c path="js.html.audio.PeriodicWave"/>
	<x path="Void"/>
</f></setPeriodicWave>
		<meta><m n=":native"><e>"OscillatorNode"</e></m></meta>
	</class>
	<abstract path="js.html.audio.OscillatorType" params="" file="/usr/lib/haxe/std/js/html/audio/OscillatorType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._OscillatorType.OscillatorType_Impl_" params="" file="/usr/lib/haxe/std/js/html/audio/OscillatorType.hx" private="1" module="js.html.audio.OscillatorType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="js.html.audio.OverSampleType" params="" file="/usr/lib/haxe/std/js/html/audio/OverSampleType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._OverSampleType.OverSampleType_Impl_" params="" file="/usr/lib/haxe/std/js/html/audio/OverSampleType.hx" private="1" module="js.html.audio.OverSampleType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.audio.PannerNode" params="" file="/usr/lib/haxe/std/js/html/audio/PannerNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<panningModel public="1"><x path="js.html.audio.PanningModelType"/></panningModel>
		<distanceModel public="1"><x path="js.html.audio.DistanceModelType"/></distanceModel>
		<refDistance public="1"><x path="Float"/></refDistance>
		<maxDistance public="1"><x path="Float"/></maxDistance>
		<rolloffFactor public="1"><x path="Float"/></rolloffFactor>
		<coneInnerAngle public="1"><x path="Float"/></coneInnerAngle>
		<coneOuterAngle public="1"><x path="Float"/></coneOuterAngle>
		<coneOuterGain public="1"><x path="Float"/></coneOuterGain>
		<setPosition public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<setOrientation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOrientation>
		<setVelocity public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVelocity>
		<meta><m n=":native"><e>"PannerNode"</e></m></meta>
	</class>
	<abstract path="js.html.audio.PanningModelType" params="" file="/usr/lib/haxe/std/js/html/audio/PanningModelType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._PanningModelType.PanningModelType_Impl_" params="" file="/usr/lib/haxe/std/js/html/audio/PanningModelType.hx" private="1" module="js.html.audio.PanningModelType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.audio.PeriodicWave" params="" file="/usr/lib/haxe/std/js/html/audio/PeriodicWave.hx" extern="1"><meta><m n=":native"><e>"PeriodicWave"</e></m></meta></class>
	<class path="js.html.audio.ScriptProcessorNode" params="" file="/usr/lib/haxe/std/js/html/audio/ScriptProcessorNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<onaudioprocess public="1"><x path="haxe.Function"/></onaudioprocess>
		<bufferSize public="1" set="null"><x path="Int"/></bufferSize>
		<meta><m n=":native"><e>"ScriptProcessorNode"</e></m></meta>
	</class>
	<class path="js.html.audio.StereoPannerNode" params="" file="/usr/lib/haxe/std/js/html/audio/StereoPannerNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<pan public="1" set="null"><c path="js.html.audio.AudioParam"/></pan>
		<meta><m n=":native"><e>"StereoPannerNode"</e></m></meta>
	</class>
	<class path="js.html.audio.WaveShaperNode" params="" file="/usr/lib/haxe/std/js/html/audio/WaveShaperNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<curve public="1"><c path="js.html.Float32Array"/></curve>
		<oversample public="1"><x path="js.html.audio.OverSampleType"/></oversample>
		<meta><m n=":native"><e>"WaveShaperNode"</e></m></meta>
	</class>
	<class path="js.html.compat.ArrayBuffer" params="" file="/usr/lib/haxe/std/js/html/compat/ArrayBuffer.hx">
		<sliceImpl set="method" line="47" static="1">
			<f a="begin:?end">
				<t path="Null"><x path="Int"/></t>
				<x path="Int"/>
				<c path="js.html.ArrayBuffer"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</sliceImpl>
		<byteLength public="1"><x path="Int"/></byteLength>
		<a><c path="Array"><x path="Int"/></c></a>
		<slice public="1" set="method" line="43"><f a="begin:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.compat.ArrayBuffer"/>
</f></slice>
		<new public="1" set="method" line="30"><f a="?a">
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="js.html.compat.DataView" params="" file="/usr/lib/haxe/std/js/html/compat/DataView.hx">
		<buf><c path="js.html.compat.ArrayBuffer"/></buf>
		<offset><x path="Int"/></offset>
		<length><x path="Int"/></length>
		<getInt8 public="1" set="method" line="41"><f a="byteOffset">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt8>
		<getUint8 public="1" set="method" line="46"><f a="byteOffset">
	<x path="Int"/>
	<x path="Int"/>
</f></getUint8>
		<getInt16 public="1" set="method" line="50"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getInt16>
		<getUint16 public="1" set="method" line="55"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getUint16>
		<getInt32 public="1" set="method" line="59"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getInt32>
		<getUint32 public="1" set="method" line="68"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getUint32>
		<getFloat32 public="1" set="method" line="73"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></getFloat32>
		<getFloat64 public="1" set="method" line="77"><f a="byteOffset:?littleEndian">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></getFloat64>
		<setInt8 public="1" set="method" line="83"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt8>
		<setUint8 public="1" set="method" line="87"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setUint8>
		<setInt16 public="1" set="method" line="91"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setInt16>
		<setUint16 public="1" set="method" line="95"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setUint16>
		<setInt32 public="1" set="method" line="106"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setInt32>
		<setUint32 public="1" set="method" line="110"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setUint32>
		<setFloat32 public="1" set="method" line="125"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setFloat32>
		<setFloat64 public="1" set="method" line="129"><f a="byteOffset:value:?littleEndian">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setFloat64>
		<new public="1" set="method" line="33"><f a="buffer:?byteOffset:?byteLength">
	<c path="js.html.compat.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
			<m n=":access"><e>js.html.compat.ArrayBuffer</e></m>
		</meta>
	</class>
	<class path="js.html.compat.Float32Array" params="" file="/usr/lib/haxe/std/js/html/compat/Float32Array.hx">
		<BYTES_PER_ELEMENT line="27" static="1"><x path="Int"/></BYTES_PER_ELEMENT>
		<_new set="method" line="29" static="1">
			<f a="?arg1:?offset:?length">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_new>
		<_set set="method" line="80" static="1">
			<f a="?arg:?offset">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_set>
		<_subarray set="method" line="98" static="1">
			<f a="start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<a><byteOffset><x path="Int"/></byteOffset></a>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_subarray>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="js.html.compat.Uint8Array" params="" file="/usr/lib/haxe/std/js/html/compat/Uint8Array.hx">
		<BYTES_PER_ELEMENT line="27" static="1"><x path="Int"/></BYTES_PER_ELEMENT>
		<_new set="method" line="29" static="1">
			<f a="?arg1:?offset:?length">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_new>
		<_set set="method" line="71" static="1">
			<f a="?arg:?offset">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_set>
		<_subarray set="method" line="89" static="1">
			<f a="start:?end">
				<x path="Int"/>
				<x path="Int"/>
				<a><byteOffset><x path="Int"/></byteOffset></a>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_subarray>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="js.html.idb.Cursor" params="" file="/usr/lib/haxe/std/js/html/idb/Cursor.hx" extern="1">
		<source public="1" set="null"><x path="haxe.extern.EitherType">
	<c path="js.html.idb.ObjectStore"/>
	<c path="js.html.idb.Index"/>
</x></source>
		<direction public="1" set="null"><x path="js.html.idb.CursorDirection"/></direction>
		<key public="1" set="null"><d/></key>
		<primaryKey public="1" set="null"><d/></primaryKey>
		<update public="1" set="method">
			<f a="value">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</update>
		<advance public="1" set="method">
			<f a="count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</advance>
		<continue_ public="1" set="method">
			<f a="?key">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"continue"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</continue_>
		<delete_ public="1" set="method">
			<f a=""><c path="js.html.idb.Request"/></f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</delete_>
		<meta><m n=":native"><e>"IDBCursor"</e></m></meta>
	</class>
	<abstract path="js.html.idb.CursorDirection" params="" file="/usr/lib/haxe/std/js/html/idb/CursorDirection.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.idb._CursorDirection.CursorDirection_Impl_" params="" file="/usr/lib/haxe/std/js/html/idb/CursorDirection.hx" private="1" module="js.html.idb.CursorDirection"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.idb.Database" params="" file="/usr/lib/haxe/std/js/html/idb/Database.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<name public="1" set="null"><c path="String"/></name>
		<version public="1" set="null"><x path="Int"/></version>
		<objectStoreNames public="1" set="null"><c path="js.html.DOMStringList"/></objectStoreNames>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onversionchange public="1"><x path="haxe.Function"/></onversionchange>
		<createObjectStore public="1" set="method">
			<f a="name:?optionalParameters">
				<c path="String"/>
				<t path="js.html.idb.ObjectStoreParameters"/>
				<c path="js.html.idb.ObjectStore"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createObjectStore>
		<deleteObjectStore public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteObjectStore>
		<transaction public="1" set="method">
			<f a="storeNames:?mode" v=":&quot;readonly&quot;">
				<c path="Array"><c path="String"/></c>
				<x path="js.html.idb.TransactionMode"/>
				<c path="js.html.idb.Transaction"/>
			</f>
			<meta><m n=":value"><e>{mode:"readonly"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><transaction public="1" set="method">
	<f a="storeName:?mode" v=":&quot;readonly&quot;">
		<c path="String"/>
		<x path="js.html.idb.TransactionMode"/>
		<c path="js.html.idb.Transaction"/>
	</f>
	<meta><m n=":value"><e>{mode:"readonly"}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</transaction></overloads>
		</transaction>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<createMutableFile public="1" set="method">
			<f a="name:?type">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createMutableFile>
		<meta><m n=":native"><e>"IDBDatabase"</e></m></meta>
	</class>
	<class path="js.html.idb.Factory" params="" file="/usr/lib/haxe/std/js/html/idb/Factory.hx" extern="1">
		<open public="1" set="method">
			<f a="name:?options">
				<c path="String"/>
				<t path="js.html.idb.OpenDBOptions"/>
				<c path="js.html.idb.OpenDBRequest"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><open public="1" set="method">
	<f a="name:version">
		<c path="String"/>
		<x path="Int"/>
		<c path="js.html.idb.OpenDBRequest"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</open></overloads>
		</open>
		<deleteDatabase public="1" set="method">
			<f a="name:?options">
				<c path="String"/>
				<t path="js.html.idb.OpenDBOptions"/>
				<c path="js.html.idb.OpenDBRequest"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteDatabase>
		<cmp public="1" set="method">
			<f a="first:second">
				<d/>
				<d/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cmp>
		<meta><m n=":native"><e>"IDBFactory"</e></m></meta>
	</class>
	<class path="js.html.idb.Index" params="" file="/usr/lib/haxe/std/js/html/idb/Index.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<objectStore public="1" set="null"><c path="js.html.idb.ObjectStore"/></objectStore>
		<keyPath public="1" set="null"><d/></keyPath>
		<multiEntry public="1" set="null"><x path="Bool"/></multiEntry>
		<unique public="1" set="null"><x path="Bool"/></unique>
		<openCursor public="1" set="method">
			<f a="?range:?direction" v=":&quot;next&quot;">
				<d/>
				<x path="js.html.idb.CursorDirection"/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":value"><e>{direction:"next"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</openCursor>
		<openKeyCursor public="1" set="method">
			<f a="?range:?direction" v=":&quot;next&quot;">
				<d/>
				<x path="js.html.idb.CursorDirection"/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":value"><e>{direction:"next"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</openKeyCursor>
		<get public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</get>
		<getKey public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getKey>
		<count public="1" set="method">
			<f a="?key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</count>
		<meta><m n=":native"><e>"IDBIndex"</e></m></meta>
	</class>
	<typedef path="js.html.idb.IndexParameters" params="" file="/usr/lib/haxe/std/js/html/idb/IndexParameters.hx"><a>
	<unique>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</unique>
	<multiEntry>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</multiEntry>
</a></typedef>
	<class path="js.html.idb.ObjectStore" params="" file="/usr/lib/haxe/std/js/html/idb/ObjectStore.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<keyPath public="1" set="null"><d/></keyPath>
		<indexNames public="1" set="null"><c path="js.html.DOMStringList"/></indexNames>
		<transaction public="1" set="null"><c path="js.html.idb.Transaction"/></transaction>
		<autoIncrement public="1" set="null"><x path="Bool"/></autoIncrement>
		<put public="1" set="method">
			<f a="value:?key">
				<d/>
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</put>
		<add public="1" set="method">
			<f a="value:?key">
				<d/>
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<delete_ public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</delete_>
		<get public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</get>
		<clear public="1" set="method">
			<f a=""><c path="js.html.idb.Request"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clear>
		<openCursor public="1" set="method">
			<f a="?range:?direction" v=":&quot;next&quot;">
				<d/>
				<x path="js.html.idb.CursorDirection"/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":value"><e>{direction:"next"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</openCursor>
		<createIndex public="1" set="method">
			<f a="name:keyPath:?optionalParameters">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<t path="js.html.idb.IndexParameters"/>
				<c path="js.html.idb.Index"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createIndex public="1" set="method">
	<f a="name:keyPath:?optionalParameters">
		<c path="String"/>
		<c path="String"/>
		<t path="js.html.idb.IndexParameters"/>
		<c path="js.html.idb.Index"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createIndex></overloads>
		</createIndex>
		<index public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.idb.Index"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</index>
		<deleteIndex public="1" set="method">
			<f a="indexName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteIndex>
		<count public="1" set="method">
			<f a="?key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</count>
		<meta><m n=":native"><e>"IDBObjectStore"</e></m></meta>
	</class>
	<typedef path="js.html.idb.ObjectStoreParameters" params="" file="/usr/lib/haxe/std/js/html/idb/ObjectStoreParameters.hx"><a>
	<keyPath>
		<t path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</x></t>
		<meta><m n=":optional"/></meta>
	</keyPath>
	<autoIncrement>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</autoIncrement>
</a></typedef>
	<typedef path="js.html.idb.OpenDBOptions" params="" file="/usr/lib/haxe/std/js/html/idb/OpenDBOptions.hx"><a>
	<version>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</version>
	<storage>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</storage>
</a></typedef>
	<class path="js.html.idb.Request" params="" file="/usr/lib/haxe/std/js/html/idb/Request.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<result public="1" set="null"><d/></result>
		<error public="1" set="null"><c path="js.html.DOMError"/></error>
		<source public="1" set="null"><x path="haxe.extern.EitherType">
	<c path="js.html.idb.ObjectStore"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.idb.Index"/>
		<c path="js.html.idb.Cursor"/>
	</x>
</x></source>
		<transaction public="1" set="null"><c path="js.html.idb.Transaction"/></transaction>
		<readyState public="1" set="null"><x path="js.html.idb.RequestReadyState"/></readyState>
		<onsuccess public="1"><x path="haxe.Function"/></onsuccess>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<meta><m n=":native"><e>"IDBRequest"</e></m></meta>
	</class>
	<class path="js.html.idb.OpenDBRequest" params="" file="/usr/lib/haxe/std/js/html/idb/OpenDBRequest.hx" extern="1">
		<extends path="js.html.idb.Request"/>
		<onblocked public="1"><x path="haxe.Function"/></onblocked>
		<onupgradeneeded public="1"><x path="haxe.Function"/></onupgradeneeded>
		<meta><m n=":native"><e>"IDBOpenDBRequest"</e></m></meta>
	</class>
	<abstract path="js.html.idb.RequestReadyState" params="" file="/usr/lib/haxe/std/js/html/idb/RequestReadyState.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.idb._RequestReadyState.RequestReadyState_Impl_" params="" file="/usr/lib/haxe/std/js/html/idb/RequestReadyState.hx" private="1" module="js.html.idb.RequestReadyState"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.idb.Transaction" params="" file="/usr/lib/haxe/std/js/html/idb/Transaction.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<mode public="1" set="null"><x path="js.html.idb.TransactionMode"/></mode>
		<db public="1" set="null"><c path="js.html.idb.Database"/></db>
		<error public="1" set="null"><c path="js.html.DOMError"/></error>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<oncomplete public="1"><x path="haxe.Function"/></oncomplete>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<objectStoreNames public="1" set="null"><c path="js.html.DOMStringList"/></objectStoreNames>
		<objectStore public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.idb.ObjectStore"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</objectStore>
		<abort public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</abort>
		<meta><m n=":native"><e>"IDBTransaction"</e></m></meta>
	</class>
	<abstract path="js.html.idb.TransactionMode" params="" file="/usr/lib/haxe/std/js/html/idb/TransactionMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.idb._TransactionMode.TransactionMode_Impl_" params="" file="/usr/lib/haxe/std/js/html/idb/TransactionMode.hx" private="1" module="js.html.idb.TransactionMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.svg.Matrix" params="" file="/usr/lib/haxe/std/js/html/svg/Matrix.hx" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<e public="1"><x path="Float"/></e>
		<f public="1"><x path="Float"/></f>
		<multiply public="1" set="method"><f a="secondMatrix">
	<c path="js.html.svg.Matrix"/>
	<c path="js.html.svg.Matrix"/>
</f></multiply>
		<inverse public="1" set="method">
			<f a=""><c path="js.html.svg.Matrix"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</inverse>
		<translate public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></translate>
		<scale public="1" set="method"><f a="scaleFactor">
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></scale>
		<scaleNonUniform public="1" set="method"><f a="scaleFactorX:scaleFactorY">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></scaleNonUniform>
		<rotate public="1" set="method"><f a="angle">
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></rotate>
		<rotateFromVector public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.svg.Matrix"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</rotateFromVector>
		<flipX public="1" set="method"><f a=""><c path="js.html.svg.Matrix"/></f></flipX>
		<flipY public="1" set="method"><f a=""><c path="js.html.svg.Matrix"/></f></flipY>
		<skewX public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<c path="js.html.svg.Matrix"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</skewX>
		<skewY public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<c path="js.html.svg.Matrix"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</skewY>
		<meta><m n=":native"><e>"SVGMatrix"</e></m></meta>
	</class>
	<class path="js.html.webgl.ActiveInfo" params="" file="/usr/lib/haxe/std/js/html/webgl/ActiveInfo.hx" extern="1">
		<size public="1" set="null"><x path="Int"/></size>
		<type public="1" set="null"><x path="Int"/></type>
		<name public="1" set="null"><c path="String"/></name>
		<meta><m n=":native"><e>"WebGLActiveInfo"</e></m></meta>
	</class>
	<class path="js.html.webgl.Buffer" params="" file="/usr/lib/haxe/std/js/html/webgl/Buffer.hx" extern="1"><meta><m n=":native"><e>"WebGLBuffer"</e></m></meta></class>
	<typedef path="js.html.webgl.ContextAttributes" params="" file="/usr/lib/haxe/std/js/html/webgl/ContextAttributes.hx"><a>
	<stencil>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</stencil>
	<preserveDrawingBuffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</preserveDrawingBuffer>
	<premultipliedAlpha>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</premultipliedAlpha>
	<depth>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</depth>
	<antialias>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</antialias>
	<alpha>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</alpha>
</a></typedef>
	<class path="js.html.webgl.Framebuffer" params="" file="/usr/lib/haxe/std/js/html/webgl/Framebuffer.hx" extern="1"><meta><m n=":native"><e>"WebGLFramebuffer"</e></m></meta></class>
	<class path="js.html.webgl.Program" params="" file="/usr/lib/haxe/std/js/html/webgl/Program.hx" extern="1"><meta><m n=":native"><e>"WebGLProgram"</e></m></meta></class>
	<class path="js.html.webgl.Renderbuffer" params="" file="/usr/lib/haxe/std/js/html/webgl/Renderbuffer.hx" extern="1"><meta><m n=":native"><e>"WebGLRenderbuffer"</e></m></meta></class>
	<class path="js.html.webgl.RenderingContext" params="" file="/usr/lib/haxe/std/js/html/webgl/RenderingContext.hx" extern="1">
		<DEPTH_BUFFER_BIT public="1" get="inline" set="null" expr="256" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>256</e></m></meta>
		</DEPTH_BUFFER_BIT>
		<STENCIL_BUFFER_BIT public="1" get="inline" set="null" expr="1024" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1024</e></m></meta>
		</STENCIL_BUFFER_BIT>
		<COLOR_BUFFER_BIT public="1" get="inline" set="null" expr="16384" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16384</e></m></meta>
		</COLOR_BUFFER_BIT>
		<POINTS public="1" get="inline" set="null" expr="0" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</POINTS>
		<LINES public="1" get="inline" set="null" expr="1" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</LINES>
		<LINE_LOOP public="1" get="inline" set="null" expr="2" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</LINE_LOOP>
		<LINE_STRIP public="1" get="inline" set="null" expr="3" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</LINE_STRIP>
		<TRIANGLES public="1" get="inline" set="null" expr="4" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</TRIANGLES>
		<TRIANGLE_STRIP public="1" get="inline" set="null" expr="5" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</TRIANGLE_STRIP>
		<TRIANGLE_FAN public="1" get="inline" set="null" expr="6" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</TRIANGLE_FAN>
		<ZERO public="1" get="inline" set="null" expr="0" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ZERO>
		<ONE public="1" get="inline" set="null" expr="1" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ONE>
		<SRC_COLOR public="1" get="inline" set="null" expr="768" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>768</e></m></meta>
		</SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" expr="769" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>769</e></m></meta>
		</ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" get="inline" set="null" expr="770" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>770</e></m></meta>
		</SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" expr="771" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>771</e></m></meta>
		</ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" get="inline" set="null" expr="772" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>772</e></m></meta>
		</DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" expr="773" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>773</e></m></meta>
		</ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" get="inline" set="null" expr="774" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>774</e></m></meta>
		</DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" expr="775" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>775</e></m></meta>
		</ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" get="inline" set="null" expr="776" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>776</e></m></meta>
		</SRC_ALPHA_SATURATE>
		<FUNC_ADD public="1" get="inline" set="null" expr="32774" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32774</e></m></meta>
		</FUNC_ADD>
		<BLEND_EQUATION public="1" get="inline" set="null" expr="32777" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32777</e></m></meta>
		</BLEND_EQUATION>
		<BLEND_EQUATION_RGB public="1" get="inline" set="null" expr="32777" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32777</e></m></meta>
		</BLEND_EQUATION_RGB>
		<BLEND_EQUATION_ALPHA public="1" get="inline" set="null" expr="34877" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34877</e></m></meta>
		</BLEND_EQUATION_ALPHA>
		<FUNC_SUBTRACT public="1" get="inline" set="null" expr="32778" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32778</e></m></meta>
		</FUNC_SUBTRACT>
		<FUNC_REVERSE_SUBTRACT public="1" get="inline" set="null" expr="32779" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32779</e></m></meta>
		</FUNC_REVERSE_SUBTRACT>
		<BLEND_DST_RGB public="1" get="inline" set="null" expr="32968" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32968</e></m></meta>
		</BLEND_DST_RGB>
		<BLEND_SRC_RGB public="1" get="inline" set="null" expr="32969" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32969</e></m></meta>
		</BLEND_SRC_RGB>
		<BLEND_DST_ALPHA public="1" get="inline" set="null" expr="32970" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32970</e></m></meta>
		</BLEND_DST_ALPHA>
		<BLEND_SRC_ALPHA public="1" get="inline" set="null" expr="32971" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32971</e></m></meta>
		</BLEND_SRC_ALPHA>
		<CONSTANT_COLOR public="1" get="inline" set="null" expr="32769" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32769</e></m></meta>
		</CONSTANT_COLOR>
		<ONE_MINUS_CONSTANT_COLOR public="1" get="inline" set="null" expr="32770" line="62" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32770</e></m></meta>
		</ONE_MINUS_CONSTANT_COLOR>
		<CONSTANT_ALPHA public="1" get="inline" set="null" expr="32771" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32771</e></m></meta>
		</CONSTANT_ALPHA>
		<ONE_MINUS_CONSTANT_ALPHA public="1" get="inline" set="null" expr="32772" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32772</e></m></meta>
		</ONE_MINUS_CONSTANT_ALPHA>
		<BLEND_COLOR public="1" get="inline" set="null" expr="32773" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32773</e></m></meta>
		</BLEND_COLOR>
		<ARRAY_BUFFER public="1" get="inline" set="null" expr="34962" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34962</e></m></meta>
		</ARRAY_BUFFER>
		<ELEMENT_ARRAY_BUFFER public="1" get="inline" set="null" expr="34963" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34963</e></m></meta>
		</ELEMENT_ARRAY_BUFFER>
		<ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="34964" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34964</e></m></meta>
		</ARRAY_BUFFER_BINDING>
		<ELEMENT_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="34965" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34965</e></m></meta>
		</ELEMENT_ARRAY_BUFFER_BINDING>
		<STREAM_DRAW public="1" get="inline" set="null" expr="35040" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35040</e></m></meta>
		</STREAM_DRAW>
		<STATIC_DRAW public="1" get="inline" set="null" expr="35044" line="71" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35044</e></m></meta>
		</STATIC_DRAW>
		<DYNAMIC_DRAW public="1" get="inline" set="null" expr="35048" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35048</e></m></meta>
		</DYNAMIC_DRAW>
		<BUFFER_SIZE public="1" get="inline" set="null" expr="34660" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34660</e></m></meta>
		</BUFFER_SIZE>
		<BUFFER_USAGE public="1" get="inline" set="null" expr="34661" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34661</e></m></meta>
		</BUFFER_USAGE>
		<CURRENT_VERTEX_ATTRIB public="1" get="inline" set="null" expr="34342" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34342</e></m></meta>
		</CURRENT_VERTEX_ATTRIB>
		<FRONT public="1" get="inline" set="null" expr="1028" line="76" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1028</e></m></meta>
		</FRONT>
		<BACK public="1" get="inline" set="null" expr="1029" line="77" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1029</e></m></meta>
		</BACK>
		<FRONT_AND_BACK public="1" get="inline" set="null" expr="1032" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1032</e></m></meta>
		</FRONT_AND_BACK>
		<CULL_FACE public="1" get="inline" set="null" expr="2884" line="79" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2884</e></m></meta>
		</CULL_FACE>
		<BLEND public="1" get="inline" set="null" expr="3042" line="80" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3042</e></m></meta>
		</BLEND>
		<DITHER public="1" get="inline" set="null" expr="3024" line="81" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3024</e></m></meta>
		</DITHER>
		<STENCIL_TEST public="1" get="inline" set="null" expr="2960" line="82" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2960</e></m></meta>
		</STENCIL_TEST>
		<DEPTH_TEST public="1" get="inline" set="null" expr="2929" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2929</e></m></meta>
		</DEPTH_TEST>
		<SCISSOR_TEST public="1" get="inline" set="null" expr="3089" line="84" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3089</e></m></meta>
		</SCISSOR_TEST>
		<POLYGON_OFFSET_FILL public="1" get="inline" set="null" expr="32823" line="85" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32823</e></m></meta>
		</POLYGON_OFFSET_FILL>
		<SAMPLE_ALPHA_TO_COVERAGE public="1" get="inline" set="null" expr="32926" line="86" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32926</e></m></meta>
		</SAMPLE_ALPHA_TO_COVERAGE>
		<SAMPLE_COVERAGE public="1" get="inline" set="null" expr="32928" line="87" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32928</e></m></meta>
		</SAMPLE_COVERAGE>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="88" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_ENUM public="1" get="inline" set="null" expr="1280" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1280</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="1281" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1281</e></m></meta>
		</INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" expr="1282" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1282</e></m></meta>
		</INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="1285" line="92" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1285</e></m></meta>
		</OUT_OF_MEMORY>
		<CW public="1" get="inline" set="null" expr="2304" line="93" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2304</e></m></meta>
		</CW>
		<CCW public="1" get="inline" set="null" expr="2305" line="94" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2305</e></m></meta>
		</CCW>
		<LINE_WIDTH public="1" get="inline" set="null" expr="2849" line="95" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2849</e></m></meta>
		</LINE_WIDTH>
		<ALIASED_POINT_SIZE_RANGE public="1" get="inline" set="null" expr="33901" line="96" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33901</e></m></meta>
		</ALIASED_POINT_SIZE_RANGE>
		<ALIASED_LINE_WIDTH_RANGE public="1" get="inline" set="null" expr="33902" line="97" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33902</e></m></meta>
		</ALIASED_LINE_WIDTH_RANGE>
		<CULL_FACE_MODE public="1" get="inline" set="null" expr="2885" line="98" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2885</e></m></meta>
		</CULL_FACE_MODE>
		<FRONT_FACE public="1" get="inline" set="null" expr="2886" line="99" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2886</e></m></meta>
		</FRONT_FACE>
		<DEPTH_RANGE public="1" get="inline" set="null" expr="2928" line="100" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2928</e></m></meta>
		</DEPTH_RANGE>
		<DEPTH_WRITEMASK public="1" get="inline" set="null" expr="2930" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2930</e></m></meta>
		</DEPTH_WRITEMASK>
		<DEPTH_CLEAR_VALUE public="1" get="inline" set="null" expr="2931" line="102" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2931</e></m></meta>
		</DEPTH_CLEAR_VALUE>
		<DEPTH_FUNC public="1" get="inline" set="null" expr="2932" line="103" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2932</e></m></meta>
		</DEPTH_FUNC>
		<STENCIL_CLEAR_VALUE public="1" get="inline" set="null" expr="2961" line="104" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2961</e></m></meta>
		</STENCIL_CLEAR_VALUE>
		<STENCIL_FUNC public="1" get="inline" set="null" expr="2962" line="105" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2962</e></m></meta>
		</STENCIL_FUNC>
		<STENCIL_FAIL public="1" get="inline" set="null" expr="2964" line="106" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2964</e></m></meta>
		</STENCIL_FAIL>
		<STENCIL_PASS_DEPTH_FAIL public="1" get="inline" set="null" expr="2965" line="107" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2965</e></m></meta>
		</STENCIL_PASS_DEPTH_FAIL>
		<STENCIL_PASS_DEPTH_PASS public="1" get="inline" set="null" expr="2966" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2966</e></m></meta>
		</STENCIL_PASS_DEPTH_PASS>
		<STENCIL_REF public="1" get="inline" set="null" expr="2967" line="109" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2967</e></m></meta>
		</STENCIL_REF>
		<STENCIL_VALUE_MASK public="1" get="inline" set="null" expr="2963" line="110" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2963</e></m></meta>
		</STENCIL_VALUE_MASK>
		<STENCIL_WRITEMASK public="1" get="inline" set="null" expr="2968" line="111" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2968</e></m></meta>
		</STENCIL_WRITEMASK>
		<STENCIL_BACK_FUNC public="1" get="inline" set="null" expr="34816" line="112" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34816</e></m></meta>
		</STENCIL_BACK_FUNC>
		<STENCIL_BACK_FAIL public="1" get="inline" set="null" expr="34817" line="113" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34817</e></m></meta>
		</STENCIL_BACK_FAIL>
		<STENCIL_BACK_PASS_DEPTH_FAIL public="1" get="inline" set="null" expr="34818" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34818</e></m></meta>
		</STENCIL_BACK_PASS_DEPTH_FAIL>
		<STENCIL_BACK_PASS_DEPTH_PASS public="1" get="inline" set="null" expr="34819" line="115" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34819</e></m></meta>
		</STENCIL_BACK_PASS_DEPTH_PASS>
		<STENCIL_BACK_REF public="1" get="inline" set="null" expr="36003" line="116" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36003</e></m></meta>
		</STENCIL_BACK_REF>
		<STENCIL_BACK_VALUE_MASK public="1" get="inline" set="null" expr="36004" line="117" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36004</e></m></meta>
		</STENCIL_BACK_VALUE_MASK>
		<STENCIL_BACK_WRITEMASK public="1" get="inline" set="null" expr="36005" line="118" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36005</e></m></meta>
		</STENCIL_BACK_WRITEMASK>
		<VIEWPORT public="1" get="inline" set="null" expr="2978" line="119" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2978</e></m></meta>
		</VIEWPORT>
		<SCISSOR_BOX public="1" get="inline" set="null" expr="3088" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3088</e></m></meta>
		</SCISSOR_BOX>
		<COLOR_CLEAR_VALUE public="1" get="inline" set="null" expr="3106" line="121" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3106</e></m></meta>
		</COLOR_CLEAR_VALUE>
		<COLOR_WRITEMASK public="1" get="inline" set="null" expr="3107" line="122" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3107</e></m></meta>
		</COLOR_WRITEMASK>
		<UNPACK_ALIGNMENT public="1" get="inline" set="null" expr="3317" line="123" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3317</e></m></meta>
		</UNPACK_ALIGNMENT>
		<PACK_ALIGNMENT public="1" get="inline" set="null" expr="3333" line="124" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3333</e></m></meta>
		</PACK_ALIGNMENT>
		<MAX_TEXTURE_SIZE public="1" get="inline" set="null" expr="3379" line="125" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3379</e></m></meta>
		</MAX_TEXTURE_SIZE>
		<MAX_VIEWPORT_DIMS public="1" get="inline" set="null" expr="3386" line="126" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3386</e></m></meta>
		</MAX_VIEWPORT_DIMS>
		<SUBPIXEL_BITS public="1" get="inline" set="null" expr="3408" line="127" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3408</e></m></meta>
		</SUBPIXEL_BITS>
		<RED_BITS public="1" get="inline" set="null" expr="3410" line="128" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3410</e></m></meta>
		</RED_BITS>
		<GREEN_BITS public="1" get="inline" set="null" expr="3411" line="129" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3411</e></m></meta>
		</GREEN_BITS>
		<BLUE_BITS public="1" get="inline" set="null" expr="3412" line="130" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3412</e></m></meta>
		</BLUE_BITS>
		<ALPHA_BITS public="1" get="inline" set="null" expr="3413" line="131" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3413</e></m></meta>
		</ALPHA_BITS>
		<DEPTH_BITS public="1" get="inline" set="null" expr="3414" line="132" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3414</e></m></meta>
		</DEPTH_BITS>
		<STENCIL_BITS public="1" get="inline" set="null" expr="3415" line="133" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3415</e></m></meta>
		</STENCIL_BITS>
		<POLYGON_OFFSET_UNITS public="1" get="inline" set="null" expr="10752" line="134" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10752</e></m></meta>
		</POLYGON_OFFSET_UNITS>
		<POLYGON_OFFSET_FACTOR public="1" get="inline" set="null" expr="32824" line="135" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32824</e></m></meta>
		</POLYGON_OFFSET_FACTOR>
		<TEXTURE_BINDING_2D public="1" get="inline" set="null" expr="32873" line="136" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32873</e></m></meta>
		</TEXTURE_BINDING_2D>
		<SAMPLE_BUFFERS public="1" get="inline" set="null" expr="32936" line="137" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32936</e></m></meta>
		</SAMPLE_BUFFERS>
		<SAMPLES public="1" get="inline" set="null" expr="32937" line="138" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32937</e></m></meta>
		</SAMPLES>
		<SAMPLE_COVERAGE_VALUE public="1" get="inline" set="null" expr="32938" line="139" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32938</e></m></meta>
		</SAMPLE_COVERAGE_VALUE>
		<SAMPLE_COVERAGE_INVERT public="1" get="inline" set="null" expr="32939" line="140" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32939</e></m></meta>
		</SAMPLE_COVERAGE_INVERT>
		<COMPRESSED_TEXTURE_FORMATS public="1" get="inline" set="null" expr="34467" line="141" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34467</e></m></meta>
		</COMPRESSED_TEXTURE_FORMATS>
		<DONT_CARE public="1" get="inline" set="null" expr="4352" line="142" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4352</e></m></meta>
		</DONT_CARE>
		<FASTEST public="1" get="inline" set="null" expr="4353" line="143" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4353</e></m></meta>
		</FASTEST>
		<NICEST public="1" get="inline" set="null" expr="4354" line="144" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4354</e></m></meta>
		</NICEST>
		<GENERATE_MIPMAP_HINT public="1" get="inline" set="null" expr="33170" line="145" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33170</e></m></meta>
		</GENERATE_MIPMAP_HINT>
		<BYTE public="1" get="inline" set="null" expr="5120" line="146" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5120</e></m></meta>
		</BYTE>
		<UNSIGNED_BYTE public="1" get="inline" set="null" expr="5121" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5121</e></m></meta>
		</UNSIGNED_BYTE>
		<SHORT public="1" get="inline" set="null" expr="5122" line="148" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5122</e></m></meta>
		</SHORT>
		<UNSIGNED_SHORT public="1" get="inline" set="null" expr="5123" line="149" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5123</e></m></meta>
		</UNSIGNED_SHORT>
		<INT public="1" get="inline" set="null" expr="5124" line="150" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5124</e></m></meta>
		</INT>
		<UNSIGNED_INT public="1" get="inline" set="null" expr="5125" line="151" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5125</e></m></meta>
		</UNSIGNED_INT>
		<FLOAT public="1" get="inline" set="null" expr="5126" line="152" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5126</e></m></meta>
		</FLOAT>
		<DEPTH_COMPONENT public="1" get="inline" set="null" expr="6402" line="153" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6402</e></m></meta>
		</DEPTH_COMPONENT>
		<ALPHA public="1" get="inline" set="null" expr="6406" line="154" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6406</e></m></meta>
		</ALPHA>
		<RGB public="1" get="inline" set="null" expr="6407" line="155" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6407</e></m></meta>
		</RGB>
		<RGBA public="1" get="inline" set="null" expr="6408" line="156" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6408</e></m></meta>
		</RGBA>
		<LUMINANCE public="1" get="inline" set="null" expr="6409" line="157" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6409</e></m></meta>
		</LUMINANCE>
		<LUMINANCE_ALPHA public="1" get="inline" set="null" expr="6410" line="158" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6410</e></m></meta>
		</LUMINANCE_ALPHA>
		<UNSIGNED_SHORT_4_4_4_4 public="1" get="inline" set="null" expr="32819" line="159" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32819</e></m></meta>
		</UNSIGNED_SHORT_4_4_4_4>
		<UNSIGNED_SHORT_5_5_5_1 public="1" get="inline" set="null" expr="32820" line="160" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32820</e></m></meta>
		</UNSIGNED_SHORT_5_5_5_1>
		<UNSIGNED_SHORT_5_6_5 public="1" get="inline" set="null" expr="33635" line="161" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33635</e></m></meta>
		</UNSIGNED_SHORT_5_6_5>
		<FRAGMENT_SHADER public="1" get="inline" set="null" expr="35632" line="162" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35632</e></m></meta>
		</FRAGMENT_SHADER>
		<VERTEX_SHADER public="1" get="inline" set="null" expr="35633" line="163" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35633</e></m></meta>
		</VERTEX_SHADER>
		<MAX_VERTEX_ATTRIBS public="1" get="inline" set="null" expr="34921" line="164" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34921</e></m></meta>
		</MAX_VERTEX_ATTRIBS>
		<MAX_VERTEX_UNIFORM_VECTORS public="1" get="inline" set="null" expr="36347" line="165" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36347</e></m></meta>
		</MAX_VERTEX_UNIFORM_VECTORS>
		<MAX_VARYING_VECTORS public="1" get="inline" set="null" expr="36348" line="166" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36348</e></m></meta>
		</MAX_VARYING_VECTORS>
		<MAX_COMBINED_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="35661" line="167" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35661</e></m></meta>
		</MAX_COMBINED_TEXTURE_IMAGE_UNITS>
		<MAX_VERTEX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="35660" line="168" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35660</e></m></meta>
		</MAX_VERTEX_TEXTURE_IMAGE_UNITS>
		<MAX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="34930" line="169" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34930</e></m></meta>
		</MAX_TEXTURE_IMAGE_UNITS>
		<MAX_FRAGMENT_UNIFORM_VECTORS public="1" get="inline" set="null" expr="36349" line="170" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36349</e></m></meta>
		</MAX_FRAGMENT_UNIFORM_VECTORS>
		<SHADER_TYPE public="1" get="inline" set="null" expr="35663" line="171" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35663</e></m></meta>
		</SHADER_TYPE>
		<DELETE_STATUS public="1" get="inline" set="null" expr="35712" line="172" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35712</e></m></meta>
		</DELETE_STATUS>
		<LINK_STATUS public="1" get="inline" set="null" expr="35714" line="173" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35714</e></m></meta>
		</LINK_STATUS>
		<VALIDATE_STATUS public="1" get="inline" set="null" expr="35715" line="174" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35715</e></m></meta>
		</VALIDATE_STATUS>
		<ATTACHED_SHADERS public="1" get="inline" set="null" expr="35717" line="175" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35717</e></m></meta>
		</ATTACHED_SHADERS>
		<ACTIVE_UNIFORMS public="1" get="inline" set="null" expr="35718" line="176" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35718</e></m></meta>
		</ACTIVE_UNIFORMS>
		<ACTIVE_ATTRIBUTES public="1" get="inline" set="null" expr="35721" line="177" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35721</e></m></meta>
		</ACTIVE_ATTRIBUTES>
		<SHADING_LANGUAGE_VERSION public="1" get="inline" set="null" expr="35724" line="178" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35724</e></m></meta>
		</SHADING_LANGUAGE_VERSION>
		<CURRENT_PROGRAM public="1" get="inline" set="null" expr="35725" line="179" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35725</e></m></meta>
		</CURRENT_PROGRAM>
		<NEVER public="1" get="inline" set="null" expr="512" line="180" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>512</e></m></meta>
		</NEVER>
		<LESS public="1" get="inline" set="null" expr="513" line="181" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>513</e></m></meta>
		</LESS>
		<EQUAL public="1" get="inline" set="null" expr="514" line="182" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>514</e></m></meta>
		</EQUAL>
		<LEQUAL public="1" get="inline" set="null" expr="515" line="183" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>515</e></m></meta>
		</LEQUAL>
		<GREATER public="1" get="inline" set="null" expr="516" line="184" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>516</e></m></meta>
		</GREATER>
		<NOTEQUAL public="1" get="inline" set="null" expr="517" line="185" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>517</e></m></meta>
		</NOTEQUAL>
		<GEQUAL public="1" get="inline" set="null" expr="518" line="186" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>518</e></m></meta>
		</GEQUAL>
		<ALWAYS public="1" get="inline" set="null" expr="519" line="187" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>519</e></m></meta>
		</ALWAYS>
		<KEEP public="1" get="inline" set="null" expr="7680" line="188" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7680</e></m></meta>
		</KEEP>
		<REPLACE public="1" get="inline" set="null" expr="7681" line="189" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7681</e></m></meta>
		</REPLACE>
		<INCR public="1" get="inline" set="null" expr="7682" line="190" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7682</e></m></meta>
		</INCR>
		<DECR public="1" get="inline" set="null" expr="7683" line="191" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7683</e></m></meta>
		</DECR>
		<INVERT public="1" get="inline" set="null" expr="5386" line="192" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5386</e></m></meta>
		</INVERT>
		<INCR_WRAP public="1" get="inline" set="null" expr="34055" line="193" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34055</e></m></meta>
		</INCR_WRAP>
		<DECR_WRAP public="1" get="inline" set="null" expr="34056" line="194" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34056</e></m></meta>
		</DECR_WRAP>
		<VENDOR public="1" get="inline" set="null" expr="7936" line="195" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7936</e></m></meta>
		</VENDOR>
		<RENDERER public="1" get="inline" set="null" expr="7937" line="196" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7937</e></m></meta>
		</RENDERER>
		<VERSION public="1" get="inline" set="null" expr="7938" line="197" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7938</e></m></meta>
		</VERSION>
		<NEAREST public="1" get="inline" set="null" expr="9728" line="198" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9728</e></m></meta>
		</NEAREST>
		<LINEAR public="1" get="inline" set="null" expr="9729" line="199" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9729</e></m></meta>
		</LINEAR>
		<NEAREST_MIPMAP_NEAREST public="1" get="inline" set="null" expr="9984" line="200" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9984</e></m></meta>
		</NEAREST_MIPMAP_NEAREST>
		<LINEAR_MIPMAP_NEAREST public="1" get="inline" set="null" expr="9985" line="201" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9985</e></m></meta>
		</LINEAR_MIPMAP_NEAREST>
		<NEAREST_MIPMAP_LINEAR public="1" get="inline" set="null" expr="9986" line="202" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9986</e></m></meta>
		</NEAREST_MIPMAP_LINEAR>
		<LINEAR_MIPMAP_LINEAR public="1" get="inline" set="null" expr="9987" line="203" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9987</e></m></meta>
		</LINEAR_MIPMAP_LINEAR>
		<TEXTURE_MAG_FILTER public="1" get="inline" set="null" expr="10240" line="204" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10240</e></m></meta>
		</TEXTURE_MAG_FILTER>
		<TEXTURE_MIN_FILTER public="1" get="inline" set="null" expr="10241" line="205" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10241</e></m></meta>
		</TEXTURE_MIN_FILTER>
		<TEXTURE_WRAP_S public="1" get="inline" set="null" expr="10242" line="206" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10242</e></m></meta>
		</TEXTURE_WRAP_S>
		<TEXTURE_WRAP_T public="1" get="inline" set="null" expr="10243" line="207" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10243</e></m></meta>
		</TEXTURE_WRAP_T>
		<TEXTURE_2D public="1" get="inline" set="null" expr="3553" line="208" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3553</e></m></meta>
		</TEXTURE_2D>
		<TEXTURE public="1" get="inline" set="null" expr="5890" line="209" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5890</e></m></meta>
		</TEXTURE>
		<TEXTURE_CUBE_MAP public="1" get="inline" set="null" expr="34067" line="210" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34067</e></m></meta>
		</TEXTURE_CUBE_MAP>
		<TEXTURE_BINDING_CUBE_MAP public="1" get="inline" set="null" expr="34068" line="211" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34068</e></m></meta>
		</TEXTURE_BINDING_CUBE_MAP>
		<TEXTURE_CUBE_MAP_POSITIVE_X public="1" get="inline" set="null" expr="34069" line="212" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34069</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_X>
		<TEXTURE_CUBE_MAP_NEGATIVE_X public="1" get="inline" set="null" expr="34070" line="213" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34070</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_X>
		<TEXTURE_CUBE_MAP_POSITIVE_Y public="1" get="inline" set="null" expr="34071" line="214" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34071</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_Y>
		<TEXTURE_CUBE_MAP_NEGATIVE_Y public="1" get="inline" set="null" expr="34072" line="215" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34072</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_Y>
		<TEXTURE_CUBE_MAP_POSITIVE_Z public="1" get="inline" set="null" expr="34073" line="216" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34073</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_Z>
		<TEXTURE_CUBE_MAP_NEGATIVE_Z public="1" get="inline" set="null" expr="34074" line="217" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34074</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_Z>
		<MAX_CUBE_MAP_TEXTURE_SIZE public="1" get="inline" set="null" expr="34076" line="218" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34076</e></m></meta>
		</MAX_CUBE_MAP_TEXTURE_SIZE>
		<TEXTURE0 public="1" get="inline" set="null" expr="33984" line="219" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33984</e></m></meta>
		</TEXTURE0>
		<TEXTURE1 public="1" get="inline" set="null" expr="33985" line="220" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33985</e></m></meta>
		</TEXTURE1>
		<TEXTURE2 public="1" get="inline" set="null" expr="33986" line="221" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33986</e></m></meta>
		</TEXTURE2>
		<TEXTURE3 public="1" get="inline" set="null" expr="33987" line="222" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33987</e></m></meta>
		</TEXTURE3>
		<TEXTURE4 public="1" get="inline" set="null" expr="33988" line="223" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33988</e></m></meta>
		</TEXTURE4>
		<TEXTURE5 public="1" get="inline" set="null" expr="33989" line="224" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33989</e></m></meta>
		</TEXTURE5>
		<TEXTURE6 public="1" get="inline" set="null" expr="33990" line="225" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33990</e></m></meta>
		</TEXTURE6>
		<TEXTURE7 public="1" get="inline" set="null" expr="33991" line="226" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33991</e></m></meta>
		</TEXTURE7>
		<TEXTURE8 public="1" get="inline" set="null" expr="33992" line="227" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33992</e></m></meta>
		</TEXTURE8>
		<TEXTURE9 public="1" get="inline" set="null" expr="33993" line="228" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33993</e></m></meta>
		</TEXTURE9>
		<TEXTURE10 public="1" get="inline" set="null" expr="33994" line="229" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33994</e></m></meta>
		</TEXTURE10>
		<TEXTURE11 public="1" get="inline" set="null" expr="33995" line="230" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33995</e></m></meta>
		</TEXTURE11>
		<TEXTURE12 public="1" get="inline" set="null" expr="33996" line="231" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33996</e></m></meta>
		</TEXTURE12>
		<TEXTURE13 public="1" get="inline" set="null" expr="33997" line="232" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33997</e></m></meta>
		</TEXTURE13>
		<TEXTURE14 public="1" get="inline" set="null" expr="33998" line="233" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33998</e></m></meta>
		</TEXTURE14>
		<TEXTURE15 public="1" get="inline" set="null" expr="33999" line="234" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33999</e></m></meta>
		</TEXTURE15>
		<TEXTURE16 public="1" get="inline" set="null" expr="34000" line="235" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34000</e></m></meta>
		</TEXTURE16>
		<TEXTURE17 public="1" get="inline" set="null" expr="34001" line="236" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34001</e></m></meta>
		</TEXTURE17>
		<TEXTURE18 public="1" get="inline" set="null" expr="34002" line="237" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34002</e></m></meta>
		</TEXTURE18>
		<TEXTURE19 public="1" get="inline" set="null" expr="34003" line="238" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34003</e></m></meta>
		</TEXTURE19>
		<TEXTURE20 public="1" get="inline" set="null" expr="34004" line="239" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34004</e></m></meta>
		</TEXTURE20>
		<TEXTURE21 public="1" get="inline" set="null" expr="34005" line="240" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34005</e></m></meta>
		</TEXTURE21>
		<TEXTURE22 public="1" get="inline" set="null" expr="34006" line="241" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34006</e></m></meta>
		</TEXTURE22>
		<TEXTURE23 public="1" get="inline" set="null" expr="34007" line="242" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34007</e></m></meta>
		</TEXTURE23>
		<TEXTURE24 public="1" get="inline" set="null" expr="34008" line="243" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34008</e></m></meta>
		</TEXTURE24>
		<TEXTURE25 public="1" get="inline" set="null" expr="34009" line="244" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34009</e></m></meta>
		</TEXTURE25>
		<TEXTURE26 public="1" get="inline" set="null" expr="34010" line="245" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34010</e></m></meta>
		</TEXTURE26>
		<TEXTURE27 public="1" get="inline" set="null" expr="34011" line="246" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34011</e></m></meta>
		</TEXTURE27>
		<TEXTURE28 public="1" get="inline" set="null" expr="34012" line="247" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34012</e></m></meta>
		</TEXTURE28>
		<TEXTURE29 public="1" get="inline" set="null" expr="34013" line="248" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34013</e></m></meta>
		</TEXTURE29>
		<TEXTURE30 public="1" get="inline" set="null" expr="34014" line="249" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34014</e></m></meta>
		</TEXTURE30>
		<TEXTURE31 public="1" get="inline" set="null" expr="34015" line="250" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34015</e></m></meta>
		</TEXTURE31>
		<ACTIVE_TEXTURE public="1" get="inline" set="null" expr="34016" line="251" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34016</e></m></meta>
		</ACTIVE_TEXTURE>
		<REPEAT public="1" get="inline" set="null" expr="10497" line="252" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10497</e></m></meta>
		</REPEAT>
		<CLAMP_TO_EDGE public="1" get="inline" set="null" expr="33071" line="253" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33071</e></m></meta>
		</CLAMP_TO_EDGE>
		<MIRRORED_REPEAT public="1" get="inline" set="null" expr="33648" line="254" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33648</e></m></meta>
		</MIRRORED_REPEAT>
		<FLOAT_VEC2 public="1" get="inline" set="null" expr="35664" line="255" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35664</e></m></meta>
		</FLOAT_VEC2>
		<FLOAT_VEC3 public="1" get="inline" set="null" expr="35665" line="256" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35665</e></m></meta>
		</FLOAT_VEC3>
		<FLOAT_VEC4 public="1" get="inline" set="null" expr="35666" line="257" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35666</e></m></meta>
		</FLOAT_VEC4>
		<INT_VEC2 public="1" get="inline" set="null" expr="35667" line="258" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35667</e></m></meta>
		</INT_VEC2>
		<INT_VEC3 public="1" get="inline" set="null" expr="35668" line="259" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35668</e></m></meta>
		</INT_VEC3>
		<INT_VEC4 public="1" get="inline" set="null" expr="35669" line="260" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35669</e></m></meta>
		</INT_VEC4>
		<BOOL public="1" get="inline" set="null" expr="35670" line="261" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35670</e></m></meta>
		</BOOL>
		<BOOL_VEC2 public="1" get="inline" set="null" expr="35671" line="262" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35671</e></m></meta>
		</BOOL_VEC2>
		<BOOL_VEC3 public="1" get="inline" set="null" expr="35672" line="263" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35672</e></m></meta>
		</BOOL_VEC3>
		<BOOL_VEC4 public="1" get="inline" set="null" expr="35673" line="264" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35673</e></m></meta>
		</BOOL_VEC4>
		<FLOAT_MAT2 public="1" get="inline" set="null" expr="35674" line="265" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35674</e></m></meta>
		</FLOAT_MAT2>
		<FLOAT_MAT3 public="1" get="inline" set="null" expr="35675" line="266" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35675</e></m></meta>
		</FLOAT_MAT3>
		<FLOAT_MAT4 public="1" get="inline" set="null" expr="35676" line="267" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35676</e></m></meta>
		</FLOAT_MAT4>
		<SAMPLER_2D public="1" get="inline" set="null" expr="35678" line="268" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35678</e></m></meta>
		</SAMPLER_2D>
		<SAMPLER_CUBE public="1" get="inline" set="null" expr="35680" line="269" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35680</e></m></meta>
		</SAMPLER_CUBE>
		<VERTEX_ATTRIB_ARRAY_ENABLED public="1" get="inline" set="null" expr="34338" line="270" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34338</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_ENABLED>
		<VERTEX_ATTRIB_ARRAY_SIZE public="1" get="inline" set="null" expr="34339" line="271" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34339</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_SIZE>
		<VERTEX_ATTRIB_ARRAY_STRIDE public="1" get="inline" set="null" expr="34340" line="272" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34340</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_STRIDE>
		<VERTEX_ATTRIB_ARRAY_TYPE public="1" get="inline" set="null" expr="34341" line="273" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34341</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_TYPE>
		<VERTEX_ATTRIB_ARRAY_NORMALIZED public="1" get="inline" set="null" expr="34922" line="274" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34922</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_NORMALIZED>
		<VERTEX_ATTRIB_ARRAY_POINTER public="1" get="inline" set="null" expr="34373" line="275" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34373</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_POINTER>
		<VERTEX_ATTRIB_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="34975" line="276" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34975</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_BUFFER_BINDING>
		<IMPLEMENTATION_COLOR_READ_TYPE public="1" get="inline" set="null" expr="35738" line="277" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35738</e></m></meta>
		</IMPLEMENTATION_COLOR_READ_TYPE>
		<IMPLEMENTATION_COLOR_READ_FORMAT public="1" get="inline" set="null" expr="35739" line="278" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35739</e></m></meta>
		</IMPLEMENTATION_COLOR_READ_FORMAT>
		<COMPILE_STATUS public="1" get="inline" set="null" expr="35713" line="279" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35713</e></m></meta>
		</COMPILE_STATUS>
		<LOW_FLOAT public="1" get="inline" set="null" expr="36336" line="280" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36336</e></m></meta>
		</LOW_FLOAT>
		<MEDIUM_FLOAT public="1" get="inline" set="null" expr="36337" line="281" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36337</e></m></meta>
		</MEDIUM_FLOAT>
		<HIGH_FLOAT public="1" get="inline" set="null" expr="36338" line="282" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36338</e></m></meta>
		</HIGH_FLOAT>
		<LOW_INT public="1" get="inline" set="null" expr="36339" line="283" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36339</e></m></meta>
		</LOW_INT>
		<MEDIUM_INT public="1" get="inline" set="null" expr="36340" line="284" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36340</e></m></meta>
		</MEDIUM_INT>
		<HIGH_INT public="1" get="inline" set="null" expr="36341" line="285" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36341</e></m></meta>
		</HIGH_INT>
		<FRAMEBUFFER public="1" get="inline" set="null" expr="36160" line="286" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36160</e></m></meta>
		</FRAMEBUFFER>
		<RENDERBUFFER public="1" get="inline" set="null" expr="36161" line="287" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36161</e></m></meta>
		</RENDERBUFFER>
		<RGBA4 public="1" get="inline" set="null" expr="32854" line="288" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32854</e></m></meta>
		</RGBA4>
		<RGB5_A1 public="1" get="inline" set="null" expr="32855" line="289" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32855</e></m></meta>
		</RGB5_A1>
		<RGB565 public="1" get="inline" set="null" expr="36194" line="290" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36194</e></m></meta>
		</RGB565>
		<DEPTH_COMPONENT16 public="1" get="inline" set="null" expr="33189" line="291" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33189</e></m></meta>
		</DEPTH_COMPONENT16>
		<STENCIL_INDEX public="1" get="inline" set="null" expr="6401" line="292" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6401</e></m></meta>
		</STENCIL_INDEX>
		<STENCIL_INDEX8 public="1" get="inline" set="null" expr="36168" line="293" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36168</e></m></meta>
		</STENCIL_INDEX8>
		<DEPTH_STENCIL public="1" get="inline" set="null" expr="34041" line="294" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34041</e></m></meta>
		</DEPTH_STENCIL>
		<RENDERBUFFER_WIDTH public="1" get="inline" set="null" expr="36162" line="295" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36162</e></m></meta>
		</RENDERBUFFER_WIDTH>
		<RENDERBUFFER_HEIGHT public="1" get="inline" set="null" expr="36163" line="296" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36163</e></m></meta>
		</RENDERBUFFER_HEIGHT>
		<RENDERBUFFER_INTERNAL_FORMAT public="1" get="inline" set="null" expr="36164" line="297" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36164</e></m></meta>
		</RENDERBUFFER_INTERNAL_FORMAT>
		<RENDERBUFFER_RED_SIZE public="1" get="inline" set="null" expr="36176" line="298" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36176</e></m></meta>
		</RENDERBUFFER_RED_SIZE>
		<RENDERBUFFER_GREEN_SIZE public="1" get="inline" set="null" expr="36177" line="299" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36177</e></m></meta>
		</RENDERBUFFER_GREEN_SIZE>
		<RENDERBUFFER_BLUE_SIZE public="1" get="inline" set="null" expr="36178" line="300" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36178</e></m></meta>
		</RENDERBUFFER_BLUE_SIZE>
		<RENDERBUFFER_ALPHA_SIZE public="1" get="inline" set="null" expr="36179" line="301" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36179</e></m></meta>
		</RENDERBUFFER_ALPHA_SIZE>
		<RENDERBUFFER_DEPTH_SIZE public="1" get="inline" set="null" expr="36180" line="302" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36180</e></m></meta>
		</RENDERBUFFER_DEPTH_SIZE>
		<RENDERBUFFER_STENCIL_SIZE public="1" get="inline" set="null" expr="36181" line="303" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36181</e></m></meta>
		</RENDERBUFFER_STENCIL_SIZE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE public="1" get="inline" set="null" expr="36048" line="304" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36048</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_NAME public="1" get="inline" set="null" expr="36049" line="305" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36049</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_OBJECT_NAME>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL public="1" get="inline" set="null" expr="36050" line="306" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36050</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE public="1" get="inline" set="null" expr="36051" line="307" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36051</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE>
		<COLOR_ATTACHMENT0 public="1" get="inline" set="null" expr="36064" line="308" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36064</e></m></meta>
		</COLOR_ATTACHMENT0>
		<DEPTH_ATTACHMENT public="1" get="inline" set="null" expr="36096" line="309" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36096</e></m></meta>
		</DEPTH_ATTACHMENT>
		<STENCIL_ATTACHMENT public="1" get="inline" set="null" expr="36128" line="310" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36128</e></m></meta>
		</STENCIL_ATTACHMENT>
		<DEPTH_STENCIL_ATTACHMENT public="1" get="inline" set="null" expr="33306" line="311" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33306</e></m></meta>
		</DEPTH_STENCIL_ATTACHMENT>
		<NONE public="1" get="inline" set="null" expr="0" line="312" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<FRAMEBUFFER_COMPLETE public="1" get="inline" set="null" expr="36053" line="313" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36053</e></m></meta>
		</FRAMEBUFFER_COMPLETE>
		<FRAMEBUFFER_INCOMPLETE_ATTACHMENT public="1" get="inline" set="null" expr="36054" line="314" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36054</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT public="1" get="inline" set="null" expr="36055" line="315" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36055</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_DIMENSIONS public="1" get="inline" set="null" expr="36057" line="316" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36057</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_DIMENSIONS>
		<FRAMEBUFFER_UNSUPPORTED public="1" get="inline" set="null" expr="36061" line="317" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36061</e></m></meta>
		</FRAMEBUFFER_UNSUPPORTED>
		<FRAMEBUFFER_BINDING public="1" get="inline" set="null" expr="36006" line="318" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36006</e></m></meta>
		</FRAMEBUFFER_BINDING>
		<RENDERBUFFER_BINDING public="1" get="inline" set="null" expr="36007" line="319" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36007</e></m></meta>
		</RENDERBUFFER_BINDING>
		<MAX_RENDERBUFFER_SIZE public="1" get="inline" set="null" expr="34024" line="320" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34024</e></m></meta>
		</MAX_RENDERBUFFER_SIZE>
		<INVALID_FRAMEBUFFER_OPERATION public="1" get="inline" set="null" expr="1286" line="321" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1286</e></m></meta>
		</INVALID_FRAMEBUFFER_OPERATION>
		<UNPACK_FLIP_Y_WEBGL public="1" get="inline" set="null" expr="37440" line="322" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37440</e></m></meta>
		</UNPACK_FLIP_Y_WEBGL>
		<UNPACK_PREMULTIPLY_ALPHA_WEBGL public="1" get="inline" set="null" expr="37441" line="323" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37441</e></m></meta>
		</UNPACK_PREMULTIPLY_ALPHA_WEBGL>
		<CONTEXT_LOST_WEBGL public="1" get="inline" set="null" expr="37442" line="324" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37442</e></m></meta>
		</CONTEXT_LOST_WEBGL>
		<UNPACK_COLORSPACE_CONVERSION_WEBGL public="1" get="inline" set="null" expr="37443" line="325" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37443</e></m></meta>
		</UNPACK_COLORSPACE_CONVERSION_WEBGL>
		<BROWSER_DEFAULT_WEBGL public="1" get="inline" set="null" expr="37444" line="326" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37444</e></m></meta>
		</BROWSER_DEFAULT_WEBGL>
		<canvas public="1" set="null"><c path="js.html.CanvasElement"/></canvas>
		<drawingBufferWidth public="1" set="null"><x path="Int"/></drawingBufferWidth>
		<drawingBufferHeight public="1" set="null"><x path="Int"/></drawingBufferHeight>
		<getContextAttributes public="1" set="method"><f a=""><t path="js.html.webgl.ContextAttributes"/></f></getContextAttributes>
		<isContextLost public="1" set="method"><f a=""><x path="Bool"/></f></isContextLost>
		<getSupportedExtensions public="1" set="method"><f a=""><c path="Array"><c path="String"/></c></f></getSupportedExtensions>
		<getExtension public="1" set="method">
			<f a="name">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getExtension>
		<activeTexture public="1" set="method"><f a="texture">
	<x path="Int"/>
	<x path="Void"/>
</f></activeTexture>
		<attachShader public="1" set="method"><f a="program:shader">
	<c path="js.html.webgl.Program"/>
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></attachShader>
		<bindAttribLocation public="1" set="method"><f a="program:index:name">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></bindAttribLocation>
		<bindBuffer public="1" set="method"><f a="target:buffer">
	<x path="Int"/>
	<c path="js.html.webgl.Buffer"/>
	<x path="Void"/>
</f></bindBuffer>
		<bindFramebuffer public="1" set="method"><f a="target:framebuffer">
	<x path="Int"/>
	<c path="js.html.webgl.Framebuffer"/>
	<x path="Void"/>
</f></bindFramebuffer>
		<bindRenderbuffer public="1" set="method"><f a="target:renderbuffer">
	<x path="Int"/>
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Void"/>
</f></bindRenderbuffer>
		<bindTexture public="1" set="method"><f a="target:texture">
	<x path="Int"/>
	<c path="js.html.webgl.Texture"/>
	<x path="Void"/>
</f></bindTexture>
		<blendColor public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></blendColor>
		<blendEquation public="1" set="method"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquation>
		<blendEquationSeparate public="1" set="method"><f a="modeRGB:modeAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquationSeparate>
		<blendFunc public="1" set="method"><f a="sfactor:dfactor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFunc>
		<blendFuncSeparate public="1" set="method"><f a="srcRGB:dstRGB:srcAlpha:dstAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFuncSeparate>
		<bufferData public="1" set="method">
			<f a="target:data:usage">
				<x path="Int"/>
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<bufferData public="1" set="method"><f a="target:size:usage">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
				<bufferData public="1" set="method"><f a="target:data:usage">
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
			</overloads>
		</bufferData>
		<bufferSubData public="1" set="method">
			<f a="target:offset:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.ArrayBuffer"/>
				<x path="Void"/>
			</f>
			<overloads><bufferSubData public="1" set="method"><f a="target:offset:data">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Void"/>
</f></bufferSubData></overloads>
		</bufferSubData>
		<checkFramebufferStatus public="1" set="method"><f a="target">
	<x path="Int"/>
	<x path="Int"/>
</f></checkFramebufferStatus>
		<clear public="1" set="method"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<clearColor public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearColor>
		<clearDepth public="1" set="method"><f a="depth">
	<x path="Float"/>
	<x path="Void"/>
</f></clearDepth>
		<clearStencil public="1" set="method"><f a="s">
	<x path="Int"/>
	<x path="Void"/>
</f></clearStencil>
		<colorMask public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></colorMask>
		<compileShader public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></compileShader>
		<compressedTexImage2D public="1" set="method"><f a="target:level:internalformat:width:height:border:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexImage2D>
		<compressedTexSubImage2D public="1" set="method"><f a="target:level:xoffset:yoffset:width:height:format:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexSubImage2D>
		<copyTexImage2D public="1" set="method"><f a="target:level:internalformat:x:y:width:height:border">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexImage2D>
		<copyTexSubImage2D public="1" set="method"><f a="target:level:xoffset:yoffset:x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexSubImage2D>
		<createBuffer public="1" set="method"><f a=""><c path="js.html.webgl.Buffer"/></f></createBuffer>
		<createFramebuffer public="1" set="method"><f a=""><c path="js.html.webgl.Framebuffer"/></f></createFramebuffer>
		<createProgram public="1" set="method"><f a=""><c path="js.html.webgl.Program"/></f></createProgram>
		<createRenderbuffer public="1" set="method"><f a=""><c path="js.html.webgl.Renderbuffer"/></f></createRenderbuffer>
		<createShader public="1" set="method"><f a="type">
	<x path="Int"/>
	<c path="js.html.webgl.Shader"/>
</f></createShader>
		<createTexture public="1" set="method"><f a=""><c path="js.html.webgl.Texture"/></f></createTexture>
		<cullFace public="1" set="method"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></cullFace>
		<deleteBuffer public="1" set="method"><f a="buffer">
	<c path="js.html.webgl.Buffer"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteFramebuffer public="1" set="method"><f a="framebuffer">
	<c path="js.html.webgl.Framebuffer"/>
	<x path="Void"/>
</f></deleteFramebuffer>
		<deleteProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></deleteProgram>
		<deleteRenderbuffer public="1" set="method"><f a="renderbuffer">
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Void"/>
</f></deleteRenderbuffer>
		<deleteShader public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></deleteShader>
		<deleteTexture public="1" set="method"><f a="texture">
	<c path="js.html.webgl.Texture"/>
	<x path="Void"/>
</f></deleteTexture>
		<depthFunc public="1" set="method"><f a="func">
	<x path="Int"/>
	<x path="Void"/>
</f></depthFunc>
		<depthMask public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></depthMask>
		<depthRange public="1" set="method"><f a="zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></depthRange>
		<detachShader public="1" set="method"><f a="program:shader">
	<c path="js.html.webgl.Program"/>
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></detachShader>
		<disable public="1" set="method"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<disableVertexAttribArray public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></disableVertexAttribArray>
		<drawArrays public="1" set="method"><f a="mode:first:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawArrays>
		<drawElements public="1" set="method"><f a="mode:count:type:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawElements>
		<enable public="1" set="method"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<enableVertexAttribArray public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></enableVertexAttribArray>
		<finish public="1" set="method"><f a=""><x path="Void"/></f></finish>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
		<framebufferRenderbuffer public="1" set="method"><f a="target:attachment:renderbuffertarget:renderbuffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Void"/>
</f></framebufferRenderbuffer>
		<framebufferTexture2D public="1" set="method"><f a="target:attachment:textarget:texture:level">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.webgl.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></framebufferTexture2D>
		<frontFace public="1" set="method"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></frontFace>
		<generateMipmap public="1" set="method"><f a="target">
	<x path="Int"/>
	<x path="Void"/>
</f></generateMipmap>
		<getActiveAttrib public="1" set="method"><f a="program:index">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<c path="js.html.webgl.ActiveInfo"/>
</f></getActiveAttrib>
		<getActiveUniform public="1" set="method"><f a="program:index">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<c path="js.html.webgl.ActiveInfo"/>
</f></getActiveUniform>
		<getAttachedShaders public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<c path="Array"><c path="js.html.webgl.Shader"/></c>
</f></getAttachedShaders>
		<getAttribLocation public="1" set="method"><f a="program:name">
	<c path="js.html.webgl.Program"/>
	<c path="String"/>
	<x path="Int"/>
</f></getAttribLocation>
		<getBufferParameter public="1" set="method"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getBufferParameter>
		<getParameter public="1" set="method">
			<f a="pname">
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getParameter>
		<getError public="1" set="method"><f a=""><x path="Int"/></f></getError>
		<getFramebufferAttachmentParameter public="1" set="method">
			<f a="target:attachment:pname">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getFramebufferAttachmentParameter>
		<getProgramParameter public="1" set="method"><f a="program:pname">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<d/>
</f></getProgramParameter>
		<getProgramInfoLog public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<c path="String"/>
</f></getProgramInfoLog>
		<getRenderbufferParameter public="1" set="method"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getRenderbufferParameter>
		<getShaderParameter public="1" set="method"><f a="shader:pname">
	<c path="js.html.webgl.Shader"/>
	<x path="Int"/>
	<d/>
</f></getShaderParameter>
		<getShaderPrecisionFormat public="1" set="method"><f a="shadertype:precisiontype">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.webgl.ShaderPrecisionFormat"/>
</f></getShaderPrecisionFormat>
		<getShaderInfoLog public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<c path="String"/>
</f></getShaderInfoLog>
		<getShaderSource public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<c path="String"/>
</f></getShaderSource>
		<getTexParameter public="1" set="method"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getTexParameter>
		<getUniform public="1" set="method"><f a="program:location">
	<c path="js.html.webgl.Program"/>
	<c path="js.html.webgl.UniformLocation"/>
	<d/>
</f></getUniform>
		<getUniformLocation public="1" set="method"><f a="program:name">
	<c path="js.html.webgl.Program"/>
	<c path="String"/>
	<c path="js.html.webgl.UniformLocation"/>
</f></getUniformLocation>
		<getVertexAttrib public="1" set="method">
			<f a="index:pname">
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getVertexAttrib>
		<getVertexAttribOffset public="1" set="method"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttribOffset>
		<hint public="1" set="method"><f a="target:mode">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hint>
		<isBuffer public="1" set="method"><f a="buffer">
	<c path="js.html.webgl.Buffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" set="method"><f a="cap">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isFramebuffer public="1" set="method"><f a="framebuffer">
	<c path="js.html.webgl.Framebuffer"/>
	<x path="Bool"/>
</f></isFramebuffer>
		<isProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Bool"/>
</f></isProgram>
		<isRenderbuffer public="1" set="method"><f a="renderbuffer">
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Bool"/>
</f></isRenderbuffer>
		<isShader public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<x path="Bool"/>
</f></isShader>
		<isTexture public="1" set="method"><f a="texture">
	<c path="js.html.webgl.Texture"/>
	<x path="Bool"/>
</f></isTexture>
		<lineWidth public="1" set="method"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></lineWidth>
		<linkProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></linkProgram>
		<pixelStorei public="1" set="method"><f a="pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></pixelStorei>
		<polygonOffset public="1" set="method"><f a="factor:units">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></polygonOffset>
		<readPixels public="1" set="method">
			<f a="x:y:width:height:format:type:pixels">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.ArrayBufferView"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</readPixels>
		<renderbufferStorage public="1" set="method"><f a="target:internalformat:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderbufferStorage>
		<sampleCoverage public="1" set="method"><f a="value:invert">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sampleCoverage>
		<scissor public="1" set="method"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scissor>
		<shaderSource public="1" set="method"><f a="shader:source">
	<c path="js.html.webgl.Shader"/>
	<c path="String"/>
	<x path="Void"/>
</f></shaderSource>
		<stencilFunc public="1" set="method"><f a="func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFunc>
		<stencilFuncSeparate public="1" set="method"><f a="face:func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFuncSeparate>
		<stencilMask public="1" set="method"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMask>
		<stencilMaskSeparate public="1" set="method"><f a="face:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMaskSeparate>
		<stencilOp public="1" set="method"><f a="fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOp>
		<stencilOpSeparate public="1" set="method"><f a="face:fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOpSeparate>
		<texImage2D public="1" set="method">
			<f a="target:level:internalformat:format:type:video">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.VideoElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:width:height:border:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ArrayBufferView"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageData"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:format:type:image">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:format:type:canvas">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.CanvasElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
			</overloads>
		</texImage2D>
		<texParameterf public="1" set="method"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texParameterf>
		<texParameteri public="1" set="method"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></texParameteri>
		<texSubImage2D public="1" set="method">
			<f a="target:level:xoffset:yoffset:format:type:video">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.VideoElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:width:height:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ArrayBufferView"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageData"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:format:type:image">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:format:type:canvas">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.CanvasElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
			</overloads>
		</texSubImage2D>
		<uniform1f public="1" set="method"><f a="location:x">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform1f>
		<uniform1fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform1fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform1fv></overloads>
		</uniform1fv>
		<uniform1i public="1" set="method"><f a="location:x">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform1i>
		<uniform1iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform1iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform1iv></overloads>
		</uniform1iv>
		<uniform2f public="1" set="method"><f a="location:x:y">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform2f>
		<uniform2fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform2fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform2fv></overloads>
		</uniform2fv>
		<uniform2i public="1" set="method"><f a="location:x:y">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform2i>
		<uniform2iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform2iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform2iv></overloads>
		</uniform2iv>
		<uniform3f public="1" set="method"><f a="location:x:y:z">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform3f>
		<uniform3fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform3fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform3fv></overloads>
		</uniform3fv>
		<uniform3i public="1" set="method"><f a="location:x:y:z">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform3i>
		<uniform3iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform3iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform3iv></overloads>
		</uniform3iv>
		<uniform4f public="1" set="method"><f a="location:x:y:z:w">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform4f>
		<uniform4fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform4fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform4fv></overloads>
		</uniform4fv>
		<uniform4i public="1" set="method"><f a="location:x:y:z:w">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform4i>
		<uniform4iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform4iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform4iv></overloads>
		</uniform4iv>
		<uniformMatrix2fv public="1" set="method">
			<f a="location:transpose:value">
				<c path="js.html.webgl.UniformLocation"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniformMatrix2fv public="1" set="method"><f a="location:transpose:value">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Bool"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix2fv></overloads>
		</uniformMatrix2fv>
		<uniformMatrix3fv public="1" set="method">
			<f a="location:transpose:value">
				<c path="js.html.webgl.UniformLocation"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniformMatrix3fv public="1" set="method"><f a="location:transpose:value">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Bool"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix3fv></overloads>
		</uniformMatrix3fv>
		<uniformMatrix4fv public="1" set="method">
			<f a="location:transpose:value">
				<c path="js.html.webgl.UniformLocation"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniformMatrix4fv public="1" set="method"><f a="location:transpose:value">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Bool"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix4fv></overloads>
		</uniformMatrix4fv>
		<useProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></useProgram>
		<validateProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></validateProgram>
		<vertexAttrib1f public="1" set="method"><f a="indx:x">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib1f>
		<vertexAttrib1fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib1fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib1fv></overloads>
		</vertexAttrib1fv>
		<vertexAttrib2f public="1" set="method"><f a="indx:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib2f>
		<vertexAttrib2fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib2fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib2fv></overloads>
		</vertexAttrib2fv>
		<vertexAttrib3f public="1" set="method"><f a="indx:x:y:z">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib3f>
		<vertexAttrib3fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib3fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib3fv></overloads>
		</vertexAttrib3fv>
		<vertexAttrib4f public="1" set="method"><f a="indx:x:y:z:w">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib4f>
		<vertexAttrib4fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib4fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib4fv></overloads>
		</vertexAttrib4fv>
		<vertexAttribPointer public="1" set="method"><f a="indx:size:type:normalized:stride:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vertexAttribPointer>
		<viewport public="1" set="method"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></viewport>
		<meta><m n=":native"><e>"WebGLRenderingContext"</e></m></meta>
	</class>
	<class path="js.html.webgl.Shader" params="" file="/usr/lib/haxe/std/js/html/webgl/Shader.hx" extern="1"><meta><m n=":native"><e>"WebGLShader"</e></m></meta></class>
	<class path="js.html.webgl.ShaderPrecisionFormat" params="" file="/usr/lib/haxe/std/js/html/webgl/ShaderPrecisionFormat.hx" extern="1">
		<rangeMin public="1" set="null"><x path="Int"/></rangeMin>
		<rangeMax public="1" set="null"><x path="Int"/></rangeMax>
		<precision public="1" set="null"><x path="Int"/></precision>
		<meta><m n=":native"><e>"WebGLShaderPrecisionFormat"</e></m></meta>
	</class>
	<class path="js.html.webgl.Texture" params="" file="/usr/lib/haxe/std/js/html/webgl/Texture.hx" extern="1"><meta><m n=":native"><e>"WebGLTexture"</e></m></meta></class>
	<class path="js.html.webgl.UniformLocation" params="" file="/usr/lib/haxe/std/js/html/webgl/UniformLocation.hx" extern="1"><meta><m n=":native"><e>"WebGLUniformLocation"</e></m></meta></class>
	<class path="kha.Resource" params="" file="Kha/Sources/kha/Resource.hx" interface="1">
		<unload public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unload the resource from memory.</haxe_doc>
		</unload>
		<haxe_doc>* Interface representing a generic application resource.
 * It can go from images, to sound or music, videos or blobs.</haxe_doc>
	</class>
	<class path="kha.Blob" params="" file="Kha/Backends/HTML5/kha/Blob.hx">
		<implements path="kha.Resource"/>
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<buffer><c path="Array"><x path="Int"/></c></buffer>
		<myFirstLine><x path="Bool"/></myFirstLine>
		<length public="1" set="method" line="16"><f a=""><x path="Int"/></f></length>
		<reset public="1" set="method" line="20"><f a=""><x path="Void"/></f></reset>
		<seek public="1" set="method" line="24"><f a="pos">
	<x path="Int"/>
	<x path="Void"/>
</f></seek>
		<position public="1" set="null"><x path="Int"/></position>
		<readU8 public="1" set="method" line="30"><f a=""><x path="Int"/></f></readU8>
		<readS8 public="1" set="method" line="36"><f a=""><x path="Int"/></f></readS8>
		<readU16BE public="1" set="method" line="44"><f a=""><x path="Int"/></f></readU16BE>
		<readU16LE public="1" set="method" line="51"><f a=""><x path="Int"/></f></readU16LE>
		<readS16BE public="1" set="method" line="58"><f a=""><x path="Int"/></f></readS16BE>
		<readS16LE public="1" set="method" line="68"><f a=""><x path="Int"/></f></readS16LE>
		<readS32LE public="1" set="method" line="78"><f a=""><x path="Int"/></f></readS32LE>
		<readS32BE public="1" set="method" line="90"><f a=""><x path="Int"/></f></readS32BE>
		<readF32LE public="1" set="method" line="102"><f a=""><x path="Float"/></f></readF32LE>
		<readF32BE public="1" set="method" line="106"><f a=""><x path="Float"/></f></readF32BE>
		<readF32 set="method" line="110"><f a="i">
	<x path="Int"/>
	<x path="Float"/>
</f></readF32>
		<toString public="1" set="method" line="127"><f a=""><c path="String"/></f></toString>
		<bit set="method" line="131"><f a="value:position">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></bit>
		<readUtf8Char set="method" line="145"><f a=""><x path="Int"/></f></readUtf8Char>
		<readUtf8Line set="method" line="169"><f a=""><c path="String"/></f></readUtf8Line>
		<toText set="method" line="196"><f a="chars:length">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<c path="String"/>
</f></toText>
		<readUtf8String public="1" set="method" line="202"><f a=""><c path="String"/></f></readUtf8String>
		<toBytes public="1" set="method" line="208"><f a=""><c path="haxe.io.Bytes"/></f></toBytes>
		<unload public="1" set="method" line="212"><f a=""><x path="Void"/></f></unload>
		<new public="1" set="method" line="10"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.Button" params="" file="Kha/Sources/kha/Button.hx">
		<NONE/>
		<UP/>
		<RIGHT/>
		<DOWN/>
		<LEFT/>
		<BUTTON_1/>
		<BUTTON_2/>
		<haxe_doc>* List of gamepad buttons.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.Canvas" params="" file="Kha/Sources/kha/Canvas.hx" interface="1">
		<get_width public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_width>
		<get_height public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_height>
		<get_g1 public="1" set="method">
			<f a=""><c path="kha.graphics1.Graphics"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_g1>
		<get_g2 public="1" set="method">
			<f a=""><c path="kha.graphics2.Graphics"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_g2>
		<get_g4 public="1" set="method">
			<f a=""><c path="kha.graphics4.Graphics"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_g4>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The width of the canvas in pixels.</haxe_doc>
		</width>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The height of the canvas in pixels.</haxe_doc>
		</height>
		<g1 public="1" get="accessor" set="null">
			<c path="kha.graphics1.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics1 interface object.<br>
	 * Basic setPixel operation.]]></haxe_doc>
		</g1>
		<g2 public="1" get="accessor" set="null">
			<c path="kha.graphics2.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics2 interface object.<br>
	 * Use this for 2D operations.]]></haxe_doc>
		</g2>
		<g4 public="1" get="accessor" set="null">
			<c path="kha.graphics4.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics4 interface object.<br>
	 * Use this for 3D operations.]]></haxe_doc>
		</g4>
		<haxe_doc><![CDATA[* Interface for a generic Canvas with different APIs,<br>
 * that can be used to draw graphics.]]></haxe_doc>
		<meta><m n=":allow"><e>kha.Starter</e></m></meta>
	</class>
	<class path="kha.Image" params="" file="Kha/Backends/HTML5/kha/Image.hx">
		<implements path="kha.Resource"/>
		<implements path="kha.Canvas"/>
		<create public="1" set="method" line="9" static="1"><f a="width:height:?format:?usage:?levels">
	<x path="Int"/>
	<x path="Int"/>
	<e path="kha.graphics4.TextureFormat"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Int"/>
	<c path="kha.Image"/>
</f></create>
		<createRenderTarget public="1" set="method" line="16" static="1"><f a="width:height:?format:?depthStencil:?antiAliasingSamples">
	<x path="Int"/>
	<x path="Int"/>
	<e path="kha.graphics4.TextureFormat"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="kha.Image"/>
</f></createRenderTarget>
		<fromImage public="1" set="method" line="22" static="1"><f a="image:readable">
	<c path="js.html.ImageElement"/>
	<x path="Bool"/>
	<c path="kha.Image"/>
</f></fromImage>
		<fromVideo public="1" set="method" line="37" static="1"><f a="video">
	<c path="kha.js.Video"/>
	<c path="kha.Image"/>
</f></fromVideo>
		<maxSize public="1" get="accessor" set="null" static="1"><x path="Int"/></maxSize>
		<get_maxSize public="1" set="method" line="54" static="1"><f a=""><x path="Int"/></f></get_maxSize>
		<nonPow2Supported public="1" get="accessor" set="null" static="1"><x path="Bool"/></nonPow2Supported>
		<get_nonPow2Supported public="1" set="method" line="60" static="1"><f a=""><x path="Bool"/></f></get_nonPow2Supported>
		<isOpaque public="1" set="method" line="64"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></isOpaque>
		<unload public="1" set="method" line="65"><f a=""><x path="Void"/></f></unload>
		<lock public="1" set="method" line="66"><f a="?level">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></lock>
		<unlock public="1" set="method" line="67"><f a=""><x path="Void"/></f></unlock>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<get_width set="method" line="69"><f a=""><x path="Int"/></f></get_width>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<get_height set="method" line="71"><f a=""><x path="Int"/></f></get_height>
		<realWidth public="1" get="accessor" set="null"><x path="Int"/></realWidth>
		<get_realWidth set="method" line="73"><f a=""><x path="Int"/></f></get_realWidth>
		<realHeight public="1" get="accessor" set="null"><x path="Int"/></realHeight>
		<get_realHeight set="method" line="75"><f a=""><x path="Int"/></f></get_realHeight>
		<g1 public="1" get="accessor" set="null"><c path="kha.graphics1.Graphics"/></g1>
		<get_g1 set="method" line="77"><f a=""><c path="kha.graphics1.Graphics"/></f></get_g1>
		<g2 public="1" get="accessor" set="null"><c path="kha.graphics2.Graphics"/></g2>
		<get_g2 set="method" line="79"><f a=""><c path="kha.graphics2.Graphics"/></f></get_g2>
		<g4 public="1" get="accessor" set="null"><c path="kha.graphics4.Graphics"/></g4>
		<get_g4 set="method" line="81"><f a=""><c path="kha.graphics4.Graphics"/></f></get_g4>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.CanvasImage" params="" file="Kha/Backends/HTML5/kha/CanvasImage.hx">
		<extends path="kha.Image"/>
		<context static="1"><d/></context>
		<init public="1" set="method" line="27" static="1"><f a=""><x path="Void"/></f></init>
		<upperPowerOfTwo set="method" line="104" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></upperPowerOfTwo>
		<image public="1"><d/></image>
		<video public="1"><c path="js.html.VideoElement"/></video>
		<data><d/></data>
		<myWidth><x path="Int"/></myWidth>
		<myHeight><x path="Int"/></myHeight>
		<format><e path="kha.graphics4.TextureFormat"/></format>
		<renderTarget><x path="Bool"/></renderTarget>
		<frameBuffer public="1"><d/></frameBuffer>
		<graphics1><c path="kha.graphics1.Graphics"/></graphics1>
		<g2canvas><c path="kha.js.CanvasGraphics"/></g2canvas>
		<get_g1 set="method" line="47" override="1"><f a=""><c path="kha.graphics1.Graphics"/></f></get_g1>
		<get_g2 set="method" line="54" override="1"><f a=""><c path="kha.graphics2.Graphics"/></f></get_g2>
		<get_g4 set="method" line="66" override="1"><f a=""><c path="kha.graphics4.Graphics"/></f></get_g4>
		<get_width set="method" line="70" override="1"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="74" override="1"><f a=""><x path="Int"/></f></get_height>
		<get_realWidth set="method" line="78" override="1"><f a=""><x path="Int"/></f></get_realWidth>
		<get_realHeight set="method" line="82" override="1"><f a=""><x path="Int"/></f></get_realHeight>
		<isOpaque public="1" set="method" line="86" override="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></isOpaque>
		<createImageData set="method" line="94"><f a=""><x path="Void"/></f></createImageData>
		<texture><d/></texture>
		<createTexture public="1" set="method" line="115"><f a=""><x path="Void"/></f></createTexture>
		<set public="1" set="method" line="139"><f a="stage">
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<lock public="1" set="method" line="147" override="1"><f a="?level">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></lock>
		<unlock public="1" set="method" line="152" override="1"><f a=""><x path="Void"/></f></unlock>
		<unload public="1" set="method" line="183" override="1"><f a=""><x path="Void"/></f></unload>
		<new public="1" set="method" line="37"><f a="width:height:format:renderTarget">
	<x path="Int"/>
	<x path="Int"/>
	<e path="kha.graphics4.TextureFormat"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="kha.Color" params="" file="Kha/Sources/kha/Color.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Class representing a color, based on Int.
 * Provides a variety of methods for creating and converting colors.
 * 
 * Color's can be written as Ints. This means you can pass a hex value such as
 * 0xff123456 to a function expecting a Color, and it will automatically become a Color object.
 * Similarly, Colors may be treated as Ints.</haxe_doc>
		<meta><m n=":expose"/></meta>
		<impl><class path="kha._Color.Color_Impl_" params="" file="Kha/Sources/kha/Color.hx" private="1" module="kha.Color">
	<Black public="1" line="13" static="1"><x path="kha.Color"/></Black>
	<White public="1" line="14" static="1"><x path="kha.Color"/></White>
	<Red public="1" line="15" static="1"><x path="kha.Color"/></Red>
	<Blue public="1" line="16" static="1"><x path="kha.Color"/></Blue>
	<Green public="1" line="17" static="1"><x path="kha.Color"/></Green>
	<Magenta public="1" line="18" static="1"><x path="kha.Color"/></Magenta>
	<Yellow public="1" line="19" static="1"><x path="kha.Color"/></Yellow>
	<Cyan public="1" line="20" static="1"><x path="kha.Color"/></Cyan>
	<Purple public="1" line="21" static="1"><x path="kha.Color"/></Purple>
	<Pink public="1" line="22" static="1"><x path="kha.Color"/></Pink>
	<Orange public="1" line="23" static="1"><x path="kha.Color"/></Orange>
	<fromValue public="1" get="inline" set="null" line="28" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="kha.Color"/>
		</f>
		<haxe_doc>* Creates a new Color object from a packed 32 bit ARGB value.</haxe_doc>
	</fromValue>
	<fromBytes public="1" set="method" line="35" static="1">
		<f a="r:g:b:?a">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="kha.Color"/>
		</f>
		<haxe_doc>* Creates a new Color object from components in the range 0 - 255.</haxe_doc>
	</fromBytes>
	<fromFloats public="1" set="method" line="42" static="1">
		<f a="r:g:b:?a">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="kha.Color"/>
		</f>
		<haxe_doc>* Creates a new Color object from components in the range 0 - 1.</haxe_doc>
	</fromFloats>
	<fromString public="1" set="method" line="49" static="1">
		<f a="value">
			<c path="String"/>
			<x path="kha.Color"/>
		</f>
		<haxe_doc>* Creates a new Color object from #AARRGGBB string.</haxe_doc>
	</fromString>
	<Rb public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a byte representing the red color component.</haxe_doc>
	</Rb>
	<Gb public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a byte representing the green color component.</haxe_doc>
	</Gb>
	<Bb public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a byte representing the blue color component.</haxe_doc>
	</Bb>
	<Ab public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a byte representing the alpha color component (more exactly the opacity component - a value of 0 is fully transparent).</haxe_doc>
	</Ab>
	<R public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a float representing the red color component.</haxe_doc>
	</R>
	<G public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a float representing the green color component.</haxe_doc>
	</G>
	<B public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a float representing the blue color component.</haxe_doc>
	</B>
	<A public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Contains a float representing the alpha color component (more exactly the opacity component - a value of 0 is fully transparent).</haxe_doc>
	</A>
	<_new set="method" line="95" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="kha.Color"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<value public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Return this Color instance as Int.</haxe_doc>
	</value>
	<get_value get="inline" set="null" line="104" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_value>
	<set_value get="inline" set="null" line="108" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_value>
	<get_Rb set="method" line="113" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_Rb>
	<get_Gb set="method" line="117" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_Gb>
	<get_Bb set="method" line="121" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_Bb>
	<get_Ab set="method" line="125" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_Ab>
	<set_Rb get="inline" set="null" line="129" static="1">
		<f a="this:i">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_Rb>
	<set_Gb get="inline" set="null" line="134" static="1">
		<f a="this:i">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_Gb>
	<set_Bb get="inline" set="null" line="139" static="1">
		<f a="this:i">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_Bb>
	<set_Ab get="inline" set="null" line="144" static="1">
		<f a="this:i">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_Ab>
	<get_R get="inline" set="null" line="149" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_R>
	<get_G get="inline" set="null" line="153" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_G>
	<get_B get="inline" set="null" line="157" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_B>
	<get_A get="inline" set="null" line="161" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_A>
	<set_R get="inline" set="null" line="165" static="1">
		<f a="this:f">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_R>
	<set_G get="inline" set="null" line="170" static="1">
		<f a="this:f">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_G>
	<set_B get="inline" set="null" line="175" static="1">
		<f a="this:f">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_B>
	<set_A get="inline" set="null" line="180" static="1">
		<f a="this:f">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_A>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="kha._Color.Color_Impl_" params="" file="Kha/Sources/kha/Color.hx" private="1" module="kha.Color">
		<Black public="1" line="13" static="1"><x path="kha.Color"/></Black>
		<White public="1" line="14" static="1"><x path="kha.Color"/></White>
		<Red public="1" line="15" static="1"><x path="kha.Color"/></Red>
		<Blue public="1" line="16" static="1"><x path="kha.Color"/></Blue>
		<Green public="1" line="17" static="1"><x path="kha.Color"/></Green>
		<Magenta public="1" line="18" static="1"><x path="kha.Color"/></Magenta>
		<Yellow public="1" line="19" static="1"><x path="kha.Color"/></Yellow>
		<Cyan public="1" line="20" static="1"><x path="kha.Color"/></Cyan>
		<Purple public="1" line="21" static="1"><x path="kha.Color"/></Purple>
		<Pink public="1" line="22" static="1"><x path="kha.Color"/></Pink>
		<Orange public="1" line="23" static="1"><x path="kha.Color"/></Orange>
		<fromValue public="1" get="inline" set="null" line="28" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="kha.Color"/>
			</f>
			<haxe_doc>* Creates a new Color object from a packed 32 bit ARGB value.</haxe_doc>
		</fromValue>
		<fromBytes public="1" set="method" line="35" static="1">
			<f a="r:g:b:?a">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="kha.Color"/>
			</f>
			<haxe_doc>* Creates a new Color object from components in the range 0 - 255.</haxe_doc>
		</fromBytes>
		<fromFloats public="1" set="method" line="42" static="1">
			<f a="r:g:b:?a">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="kha.Color"/>
			</f>
			<haxe_doc>* Creates a new Color object from components in the range 0 - 1.</haxe_doc>
		</fromFloats>
		<fromString public="1" set="method" line="49" static="1">
			<f a="value">
				<c path="String"/>
				<x path="kha.Color"/>
			</f>
			<haxe_doc>* Creates a new Color object from #AARRGGBB string.</haxe_doc>
		</fromString>
		<Rb public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a byte representing the red color component.</haxe_doc>
		</Rb>
		<Gb public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a byte representing the green color component.</haxe_doc>
		</Gb>
		<Bb public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a byte representing the blue color component.</haxe_doc>
		</Bb>
		<Ab public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a byte representing the alpha color component (more exactly the opacity component - a value of 0 is fully transparent).</haxe_doc>
		</Ab>
		<R public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a float representing the red color component.</haxe_doc>
		</R>
		<G public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a float representing the green color component.</haxe_doc>
		</G>
		<B public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a float representing the blue color component.</haxe_doc>
		</B>
		<A public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Contains a float representing the alpha color component (more exactly the opacity component - a value of 0 is fully transparent).</haxe_doc>
		</A>
		<_new set="method" line="95" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="kha.Color"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<value public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Return this Color instance as Int.</haxe_doc>
		</value>
		<get_value get="inline" set="null" line="104" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_value>
		<set_value get="inline" set="null" line="108" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_value>
		<get_Rb set="method" line="113" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_Rb>
		<get_Gb set="method" line="117" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_Gb>
		<get_Bb set="method" line="121" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_Bb>
		<get_Ab set="method" line="125" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_Ab>
		<set_Rb get="inline" set="null" line="129" static="1">
			<f a="this:i">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_Rb>
		<set_Gb get="inline" set="null" line="134" static="1">
			<f a="this:i">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_Gb>
		<set_Bb get="inline" set="null" line="139" static="1">
			<f a="this:i">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_Bb>
		<set_Ab get="inline" set="null" line="144" static="1">
			<f a="this:i">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_Ab>
		<get_R get="inline" set="null" line="149" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_R>
		<get_G get="inline" set="null" line="153" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_G>
		<get_B get="inline" set="null" line="157" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_B>
		<get_A get="inline" set="null" line="161" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_A>
		<set_R get="inline" set="null" line="165" static="1">
			<f a="this:f">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_R>
		<set_G get="inline" set="null" line="170" static="1">
			<f a="this:f">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_G>
		<set_B get="inline" set="null" line="175" static="1">
			<f a="this:f">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_B>
		<set_A get="inline" set="null" line="180" static="1">
			<f a="this:f">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_A>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Configuration" params="" file="Kha/Sources/kha/Configuration.hx">
		<theScreen static="1">
			<c path="kha.Game"/>
			<haxe_doc>* The game instance.</haxe_doc>
		</theScreen>
		<id line="14" static="1">
			<x path="Int"/>
			<haxe_doc>* ID of the time task.</haxe_doc>
		</id>
		<screen public="1" get="inline" set="null" line="19" static="1">
			<f a=""><c path="kha.Game"/></f>
			<haxe_doc>* Return the game instance.</haxe_doc>
		</screen>
		<schedulerInitialized set="method" line="27" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>kha.Scheduler</e></m></meta>
			<haxe_doc>* Call this to let the system know the scheduler has been initialized.</haxe_doc>
		</schedulerInitialized>
		<setScreen public="1" set="method" line="34" static="1">
			<f a="screen">
				<c path="kha.Game"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the game instance.</haxe_doc>
		</setScreen>
		<update set="method" line="45" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update the game.</haxe_doc>
		</update>
		<haxe_doc>* This class handles updating the game instance.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Cursor" params="" file="Kha/Sources/kha/Cursor.hx" interface="1">
		<get_clickX public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_clickX>
		<get_clickY public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_clickY>
		<get_width public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_width>
		<get_height public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_height>
		<clickX public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The X position.</haxe_doc>
		</clickX>
		<clickY public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The Y position.</haxe_doc>
		</clickY>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The cursor width.</haxe_doc>
		</width>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The cursor height.</haxe_doc>
		</height>
		<render public="1" set="method">
			<f a="g:x:y">
				<c path="kha.graphics2.Graphics"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Render the cursor on screen.
	 * 
	 * @param g		The graphics2 instance to render.
	 * @param x		The X position of the cursor.
	 * @param y		The Y position of the cursor.</haxe_doc>
		</render>
		<update public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Update the cursor.
	 * 
	 * @param x		The X position of the cursor.
	 * @param y		The Y position of the cursor.</haxe_doc>
		</update>
		<haxe_doc>* A generic interface for a Cursor.</haxe_doc>
	</class>
	<class path="kha.Game" params="" file="Kha/Sources/kha/Game.hx">
		<FPS public="1" line="17" static="1">
			<x path="Int"/>
			<haxe_doc>* The current FPS.</haxe_doc>
		</FPS>
		<the public="1" set="null" static="1">
			<c path="kha.Game"/>
			<haxe_doc>* Static instance.</haxe_doc>
		</the>
		<name>
			<c path="String"/>
			<haxe_doc>* ID name.</haxe_doc>
		</name>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>* Defined width.</haxe_doc>
		</width>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>* Defined height.</haxe_doc>
		</height>
		<highscores public="1" set="null">
			<c path="kha.HighscoreList"/>
			<haxe_doc>* The high scores list.</haxe_doc>
		</highscores>
		<setInstance public="1" set="method" line="52">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Set the static instance.</haxe_doc>
		</setInstance>
		<loadFinished public="1" set="method" line="61">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Callback from when the loaded finished.
	 * This updates the game width and height values 
	 * and also call init().</haxe_doc>
		</loadFinished>
		<init public="1" set="method" line="73">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom init behavior.
	 * Called after the loading process.</haxe_doc>
		</init>
		<update public="1" set="method" line="79">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom update behavior.
	 * Called per frame or various times per frame.</haxe_doc>
		</update>
		<startRender set="method" line="88">
			<f a="frame">
				<c path="kha.Framebuffer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Start render mode for the passed frame.
	 * 
	 * @param frame		The frame buffer we will be rendering on.</haxe_doc>
		</startRender>
		<endRender set="method" line="99">
			<f a="frame">
				<c path="kha.Framebuffer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Finish render mode for the passed frame.
	 * 
	 * @param frame		The frame buffer we will be rendering on.</haxe_doc>
		</endRender>
		<render public="1" set="method" line="110">
			<f a="frame">
				<c path="kha.Framebuffer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this to get your own custom render behavior.
	 * Called per frame.</haxe_doc>
		</render>
		<getHighscores public="1" set="method" line="123">
			<f a=""><c path="kha.HighscoreList"/></f>
			<haxe_doc>* Return the high score list.</haxe_doc>
		</getHighscores>
		<deprecatedImage><c path="kha.Image"/></deprecatedImage>
		<initDeprecatedImage set="method" line="129"><f a=""><x path="Void"/></f></initDeprecatedImage>
		<painterTransformMouseX public="1" set="method" line="135">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":deprecated"><e>"kha.Game.painterTransformMouseX(x, y) is deprecated, use kha.Scaler.transformX instead."</e></m></meta>
		</painterTransformMouseX>
		<painterTransformMouseY public="1" set="method" line="141">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":deprecated"><e>"kha.Game.painterTransformMouseY(x, y) is deprecated, use kha.Scaler.transformY instead."</e></m></meta>
		</painterTransformMouseY>
		<buttonDown public="1" set="method" line="147"><f a="button">
	<e path="kha.Button"/>
	<x path="Void"/>
</f></buttonDown>
		<buttonUp public="1" set="method" line="149"><f a="button">
	<e path="kha.Button"/>
	<x path="Void"/>
</f></buttonUp>
		<keyDown public="1" set="method" line="152"><f a="key:char">
	<e path="kha.Key"/>
	<c path="String"/>
	<x path="Void"/>
</f></keyDown>
		<keyUp public="1" set="method" line="154"><f a="key:char">
	<e path="kha.Key"/>
	<c path="String"/>
	<x path="Void"/>
</f></keyUp>
		<mouseDown public="1" set="method" line="157"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseDown>
		<mouseUp public="1" set="method" line="159"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseUp>
		<rightMouseDown public="1" set="method" line="161"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rightMouseDown>
		<rightMouseUp public="1" set="method" line="163"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rightMouseUp>
		<middleMouseDown public="1" set="method" line="165"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></middleMouseDown>
		<middleMouseUp public="1" set="method" line="167"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></middleMouseUp>
		<mouseMove public="1" set="method" line="169"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></mouseMove>
		<mouseWheel public="1" set="method" line="171"><f a="delta">
	<x path="Int"/>
	<x path="Void"/>
</f></mouseWheel>
		<onForeground public="1" set="method" line="177">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom foreground behavior.
	 * Called when this application frame is moved from background of the screen to the top.</haxe_doc>
		</onForeground>
		<onResume public="1" set="method" line="182">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom resume behavior.
	 * Called when resuming the application from pause.</haxe_doc>
		</onResume>
		<onPause public="1" set="method" line="187">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom shutdown behavior.
	 * Called when pausing the application.</haxe_doc>
		</onPause>
		<onBackground public="1" set="method" line="192">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom background behavior.
	 * Called when this app frame is moved from top of the screen to the background.</haxe_doc>
		</onBackground>
		<onShutdown public="1" set="method" line="197">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom shutdown behavior.
	 * Called when shutting down the system.</haxe_doc>
		</onShutdown>
		<new public="1" set="method" line="41">
			<f a="name:?hasHighscores">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new game object.
	 * 
	 * @param name				The ID name.
	 * @param hasHighscores		If it has high scores or not.</haxe_doc>
		</new>
		<haxe_doc>* Main Kha class.
 * Inherit from this in your game or application.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.EmptyScreen" params="" file="Kha/Sources/kha/EmptyScreen.hx">
		<extends path="kha.Game"/>
		<color>
			<x path="kha.Color"/>
			<haxe_doc>* The color of the screen.</haxe_doc>
		</color>
		<render public="1" set="method" line="24" override="1">
			<f a="frame">
				<c path="kha.Framebuffer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Render the screen.</haxe_doc>
		</render>
		<update public="1" set="method" line="37" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this to get your own custom update behavior.
	 * Called per frame or various times per frame.</haxe_doc>
		</update>
		<new public="1" set="method" line="16">
			<f a="color">
				<x path="kha.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialize a new screen.</haxe_doc>
		</new>
		<haxe_doc>* An empty screen.
 * This will be the default screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.EnvironmentVariables" params="" file="Kha/Sources/kha/EnvironmentVariables.hx">
		<instance public="1" static="1">
			<c path="kha.EnvironmentVariables"/>
			<haxe_doc>* The instance.</haxe_doc>
		</instance>
		<getVariable public="1" set="method" line="25">
			<f a="name">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a variable.
	 *
	 * @param name		The variable name.</haxe_doc>
		</getVariable>
		<new public="1" set="method" line="16">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Get a new instance.</haxe_doc>
		</new>
		<haxe_doc>* Use this class to access environment variables.
 * Mainly for Flash and JS url parameters.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Font" params="" file="Kha/Sources/kha/Font.hx" interface="1">
		<get_name public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_name>
		<get_style public="1" set="method">
			<f a=""><c path="kha.FontStyle"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_style>
		<get_size public="1" set="method">
			<f a=""><x path="Float"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_size>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>* The font name.</haxe_doc>
		</name>
		<style public="1" get="accessor" set="null">
			<c path="kha.FontStyle"/>
			<haxe_doc>* Font style (bold, italic, ect).</haxe_doc>
		</style>
		<size public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Font size</haxe_doc>
		</size>
		<getHeight public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Font height</haxe_doc>
		</getHeight>
		<charWidth public="1" set="method">
			<f a="ch">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* With of a character in this font
	 * 
 	 * @param ch		The character.</haxe_doc>
		</charWidth>
		<charsWidth public="1" set="method">
			<f a="ch:offset:length">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* With of a group character in this font.
	 *
	 * @param ch		The characters.
	 * @param offset	The offset before get the 1st character.
	 * @param length	The length to get.</haxe_doc>
		</charsWidth>
		<stringWidth public="1" set="method">
			<f a="str">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Width of a string with this font.
	 *
	 * @param str		The string to measure.</haxe_doc>
		</stringWidth>
		<getBaselinePosition public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The base line position.</haxe_doc>
		</getBaselinePosition>
		<haxe_doc>* This represents a text font.</haxe_doc>
	</class>
	<class path="kha.FontStyle" params="" file="Kha/Sources/kha/FontStyle.hx">
		<Default public="1" set="null" line="10" static="1">
			<c path="kha.FontStyle"/>
			<haxe_doc>* The default style.</haxe_doc>
		</Default>
		<bold>
			<x path="Bool"/>
			<haxe_doc>* If the font is bold.</haxe_doc>
		</bold>
		<italic>
			<x path="Bool"/>
			<haxe_doc>* If the font is italic.</haxe_doc>
		</italic>
		<underlined>
			<x path="Bool"/>
			<haxe_doc>* If the font is underlined.</haxe_doc>
		</underlined>
		<getBold public="1" set="method" line="40">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns true if the font is bold.</haxe_doc>
		</getBold>
		<getItalic public="1" set="method" line="47">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns true if the font is italic.</haxe_doc>
		</getItalic>
		<getUnderlined public="1" set="method" line="54">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns true if the font is underlined.</haxe_doc>
		</getUnderlined>
		<new public="1" set="method" line="31">
			<f a="bold:italic:underlined">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialize a new font style.
	 * 
	 * @param bold				If the font is bold, default = false.
	 * @param italic			If the font is italic, default = false.
 	 * @param underlined		If the font is underlined, default = false.</haxe_doc>
		</new>
		<haxe_doc>* The font style (bold, italic, ect).</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Framebuffer" params="" file="Kha/Sources/kha/Framebuffer.hx">
		<implements path="kha.Canvas"/>
		<graphics1>
			<c path="kha.graphics1.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics1 interface object.<br>
	 * Basic setPixel operation.]]></haxe_doc>
		</graphics1>
		<graphics2>
			<c path="kha.graphics2.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics2 interface object.<br>
	 * Use this for 2D operations.]]></haxe_doc>
		</graphics2>
		<graphics4>
			<c path="kha.graphics4.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics4 interface object.<br>
	 * Use this for 3D operations.]]></haxe_doc>
		</graphics4>
		<init public="1" set="method" line="46">
			<f a="g1:g2:g4">
				<c path="kha.graphics1.Graphics"/>
				<c path="kha.graphics2.Graphics"/>
				<c path="kha.graphics4.Graphics"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialize a new frame buffer object instance.
	 * 
	 * @param g1		The Graphics1 object.
 	 * @param g2		The Graphics2 object.
	 * @param g4		The Graphics4 object.</haxe_doc>
		</init>
		<g1 public="1" get="accessor" set="null">
			<c path="kha.graphics1.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics1 interface object.<br>
	 * Basic setPixel operation.]]></haxe_doc>
		</g1>
		<get_g1 set="method" line="62">
			<f a=""><c path="kha.graphics1.Graphics"/></f>
			<haxe_doc><![CDATA[* Return the Graphics1 interface object.<br>
	 * Basic setPixel operation.]]></haxe_doc>
		</get_g1>
		<g2 public="1" get="accessor" set="null">
			<c path="kha.graphics2.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics2 interface object.<br>
	 * Use this for 2D operations.]]></haxe_doc>
		</g2>
		<get_g2 set="method" line="76">
			<f a=""><c path="kha.graphics2.Graphics"/></f>
			<haxe_doc><![CDATA[* Return the Graphics2 interface object.<br>
	 * Use this for 2D operations.]]></haxe_doc>
		</get_g2>
		<g4 public="1" get="accessor" set="null">
			<c path="kha.graphics4.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics4 interface object.<br>
	 * Use this for 3D operations.]]></haxe_doc>
		</g4>
		<get_g4 set="method" line="90">
			<f a=""><c path="kha.graphics4.Graphics"/></f>
			<haxe_doc><![CDATA[* Return the Graphics4 interface object.<br>
	 * Use this for 3D operations.]]></haxe_doc>
		</get_g4>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The width of the buffer in pixels.</haxe_doc>
		</width>
		<get_width set="method" line="102">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Return the width of the buffer in pixels.</haxe_doc>
		</get_width>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The height of the buffer in pixels.</haxe_doc>
		</height>
		<get_height set="method" line="114">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Return the height of the buffer in pixels.</haxe_doc>
		</get_height>
		<new public="1" set="method" line="33">
			<f a="g1:g2:g4">
				<c path="kha.graphics1.Graphics"/>
				<c path="kha.graphics2.Graphics"/>
				<c path="kha.graphics4.Graphics"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new frame buffer object instance.
	 * 
	 * @param g1		The Graphics1 object.
 	 * @param g2		The Graphics2 object.
	 * @param g4		The Graphics4 object.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The FrameBuffer represents the current graphical status of the application,<br>
 * you can get references to different graphical APIs,<br>
 * that can be used to draw graphics.]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>kha.Starter</e></m>
		</meta>
	</class>
	<class path="kha.HighscoreList" params="" file="Kha/Sources/kha/HighscoreList.hx">
		<scores><c path="Array"><c path="kha.Score"/></c></scores>
		<getScores public="1" set="method" line="26"><f a=""><c path="Array"><c path="kha.Score"/></c></f></getScores>
		<addScore public="1" set="method" line="30"><f a="name:score">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addScore>
		<load public="1" set="method" line="42"><f a="file">
	<c path="kha.StorageFile"/>
	<x path="Void"/>
</f></load>
		<save public="1" set="method" line="53"><f a="file">
	<c path="kha.StorageFile"/>
	<x path="Void"/>
</f></save>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.Key" params="" file="Kha/Sources/kha/Key.hx">
		<BACKSPACE/>
		<TAB/>
		<ENTER/>
		<SHIFT/>
		<CTRL/>
		<ALT/>
		<CHAR/>
		<ESC/>
		<DEL/>
		<UP/>
		<DOWN/>
		<LEFT/>
		<RIGHT/>
		<haxe_doc>* List of special Keyboard keys.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.BakedChar" params="" file="Kha/Sources/kha/Kravur.hx" module="kha.Kravur">
		<x0 public="1"><x path="Int"/></x0>
		<y0 public="1"><x path="Int"/></y0>
		<x1 public="1"><x path="Int"/></x1>
		<y1 public="1"><x path="Int"/></y1>
		<xoff public="1"><x path="Float"/></xoff>
		<yoff public="1"><x path="Float"/></yoff>
		<xadvance public="1"><x path="Float"/></xadvance>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.AlignedQuad" params="" file="Kha/Sources/kha/Kravur.hx" module="kha.Kravur">
		<x0 public="1"><x path="Float"/></x0>
		<y0 public="1"><x path="Float"/></y0>
		<s0 public="1"><x path="Float"/></s0>
		<t0 public="1"><x path="Float"/></t0>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<s1 public="1"><x path="Float"/></s1>
		<t1 public="1"><x path="Float"/></t1>
		<xadvance public="1"><x path="Float"/></xadvance>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Kravur" params="" file="Kha/Sources/kha/Kravur.hx">
		<implements path="kha.Font"/>
		<fontCache line="49" static="1"><x path="Map">
	<c path="String"/>
	<c path="kha.Kravur"/>
</x></fontCache>
		<get public="1" set="method" line="53" static="1">
			<f a="name:style:size">
				<c path="String"/>
				<c path="kha.FontStyle"/>
				<x path="Float"/>
				<c path="kha.Kravur"/>
			</f>
			<haxe_doc>Returns the cached Kravur for name, style and size or loads it.</haxe_doc>
		</get>
		<myName><c path="String"/></myName>
		<myStyle><c path="kha.FontStyle"/></myStyle>
		<mySize><x path="Float"/></mySize>
		<chars><c path="Array"><c path="kha.BakedChar"/></c></chars>
		<texture><c path="kha.Image"/></texture>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<baseline><x path="Float"/></baseline>
		<getTexture public="1" set="method" line="121"><f a=""><c path="kha.Image"/></f></getTexture>
		<getBakedQuad public="1" set="method" line="125"><f a="char_index:xpos:ypos">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.AlignedQuad"/>
</f></getBakedQuad>
		<getCharWidth set="method" line="150"><f a="charIndex">
	<x path="Int"/>
	<x path="Float"/>
</f></getCharWidth>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<style public="1" get="accessor" set="null"><c path="kha.FontStyle"/></style>
		<size public="1" get="accessor" set="null"><x path="Float"/></size>
		<get_name public="1" set="method" line="160"><f a=""><c path="String"/></f></get_name>
		<get_style public="1" set="method" line="164"><f a=""><c path="kha.FontStyle"/></f></get_style>
		<get_size public="1" set="method" line="168"><f a=""><x path="Float"/></f></get_size>
		<getHeight public="1" set="method" line="172"><f a=""><x path="Float"/></f></getHeight>
		<charWidth public="1" set="method" line="176"><f a="ch">
	<c path="String"/>
	<x path="Float"/>
</f></charWidth>
		<charsWidth public="1" set="method" line="180"><f a="ch:offset:length">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></charsWidth>
		<stringWidth public="1" set="method" line="184"><f a="string">
	<c path="String"/>
	<x path="Float"/>
</f></stringWidth>
		<getBaselinePosition public="1" set="method" line="198"><f a=""><x path="Float"/></f></getBaselinePosition>
		<new set="method" line="78"><f a="blob">
	<c path="kha.Blob"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Loader" params="" file="Kha/Sources/kha/Loader.hx">
		<the public="1" set="null" static="1"><c path="kha.Loader"/></the>
		<init public="1" set="method" line="49" static="1"><f a="loader">
	<c path="kha.Loader"/>
	<x path="Void"/>
</f></init>
		<containsAsset public="1" set="method" line="121" static="1"><f a="assetName:assetType:map">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Bool"/>
</f></containsAsset>
		<blobs><x path="Map">
	<c path="String"/>
	<c path="kha.Blob"/>
</x></blobs>
		<images><x path="Map">
	<c path="String"/>
	<c path="kha.Image"/>
</x></images>
		<sounds><x path="Map">
	<c path="String"/>
	<c path="kha.Sound"/>
</x></sounds>
		<musics><x path="Map">
	<c path="String"/>
	<c path="kha.Music"/>
</x></musics>
		<videos><x path="Map">
	<c path="String"/>
	<c path="kha.Video"/>
</x></videos>
		<shaders><x path="Map">
	<c path="String"/>
	<c path="kha.Blob"/>
</x></shaders>
		<loadcount><x path="Int"/></loadcount>
		<numberOfFiles><x path="Int"/></numberOfFiles>
		<assets><x path="Map">
	<c path="String"/>
	<d/>
</x></assets>
		<rooms><x path="Map">
	<c path="String"/>
	<c path="kha.loader.Room"/>
</x></rooms>
		<isQuitable public="1">
			<x path="Bool"/>
			<haxe_doc>* Some backends dont support quitting, for example if the game is embedded in a web page.</haxe_doc>
		</isQuitable>
		<autoCleanupAssets public="1"><x path="Bool"/></autoCleanupAssets>
		<basePath public="1"><c path="String"/></basePath>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<name public="1" set="null"><c path="String"/></name>
		<antiAliasingSamples public="1" set="null"><x path="Int"/></antiAliasingSamples>
		<getLoadPercentage public="1" set="method" line="53"><f a=""><x path="Int"/></f></getLoadPercentage>
		<getBlob public="1" set="method" line="57"><f a="name">
	<c path="String"/>
	<c path="kha.Blob"/>
</f></getBlob>
		<getImage public="1" set="method" line="61"><f a="name">
	<c path="String"/>
	<c path="kha.Image"/>
</f></getImage>
		<getMusic public="1" set="method" line="68"><f a="name">
	<c path="String"/>
	<c path="kha.Music"/>
</f></getMusic>
		<getSound public="1" set="method" line="72"><f a="name">
	<c path="String"/>
	<c path="kha.Sound"/>
</f></getSound>
		<getVideo public="1" set="method" line="79"><f a="name">
	<c path="String"/>
	<c path="kha.Video"/>
</f></getVideo>
		<getShader public="1" set="method" line="83"><f a="name">
	<c path="String"/>
	<c path="kha.Blob"/>
</f></getShader>
		<getAvailableBlobs public="1" set="method" line="87"><f a=""><t path="Iterator"><c path="String"/></t></f></getAvailableBlobs>
		<isBlobAvailable public="1" get="inline" set="null" line="90"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></isBlobAvailable>
		<getAvailableImages public="1" set="method" line="92"><f a=""><t path="Iterator"><c path="String"/></t></f></getAvailableImages>
		<isImageAvailable public="1" get="inline" set="null" line="95"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></isImageAvailable>
		<getAvailableMusic public="1" set="method" line="97"><f a=""><t path="Iterator"><c path="String"/></t></f></getAvailableMusic>
		<isMusicAvailable public="1" get="inline" set="null" line="100"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></isMusicAvailable>
		<getAvailableSounds public="1" set="method" line="102"><f a=""><t path="Iterator"><c path="String"/></t></f></getAvailableSounds>
		<isSoundAvailable public="1" get="inline" set="null" line="105"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></isSoundAvailable>
		<getAvailableVideos public="1" set="method" line="107"><f a=""><t path="Iterator"><c path="String"/></t></f></getAvailableVideos>
		<isVideoAvailable public="1" get="inline" set="null" line="110"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></isVideoAvailable>
		<enqueued><c path="Array"><d/></c></enqueued>
		<loadFinished public="1"><f a=""><x path="Void"/></f></loadFinished>
		<enqueue public="1" set="method" line="115"><f a="asset">
	<d/>
	<x path="Void"/>
</f></enqueue>
		<removeImage set="method" line="128"><f a="resources:resourceName">
	<x path="Map">
		<c path="String"/>
		<c path="kha.Image"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></removeImage>
		<removeBlob set="method" line="134"><f a="resources:resourceName">
	<x path="Map">
		<c path="String"/>
		<c path="kha.Blob"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></removeBlob>
		<removeMusic set="method" line="140"><f a="resources:resourceName">
	<x path="Map">
		<c path="String"/>
		<c path="kha.Music"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></removeMusic>
		<removeSound set="method" line="146"><f a="resources:resourceName">
	<x path="Map">
		<c path="String"/>
		<c path="kha.Sound"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></removeSound>
		<removeVideo set="method" line="152"><f a="resources:resourceName">
	<x path="Map">
		<c path="String"/>
		<c path="kha.Video"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></removeVideo>
		<cleanup public="1" set="method" line="158"><f a=""><x path="Void"/></f></cleanup>
		<loadFiles public="1" set="method" line="168"><f a="call:autoCleanup">
	<f a=""><x path="Void"/></f>
	<x path="Bool"/>
	<x path="Void"/>
</f></loadFiles>
		<loadProject public="1" set="method" line="275"><f a="call">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></loadProject>
		<loadShaders set="method" line="280"><f a="call">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></loadShaders>
		<loadRoomAssets set="method" line="309"><f a="room">
	<c path="kha.loader.Room"/>
	<x path="Void"/>
</f></loadRoomAssets>
		<loadRoom public="1" set="method" line="316"><f a="name:call">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></loadRoom>
		<unloadedImage public="1" set="method" line="322"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></unloadedImage>
		<initProject public="1" set="method" line="328"><f a=""><x path="Void"/></f></initProject>
		<parseProject set="method" line="365"><f a=""><d/></f></parseProject>
		<checkComplete set="method" line="369"><f a=""><x path="Void"/></f></checkComplete>
		<loadDummyFile set="method" line="384"><f a=""><x path="Void"/></f></loadDummyFile>
		<loadStarted set="method" line="389"><f a="numberOfFiles">
	<x path="Int"/>
	<x path="Void"/>
</f></loadStarted>
		<loadImage public="1" set="method" line="399"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Image"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadImage>
		<loadBlob public="1" set="method" line="400"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Blob"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBlob>
		<loadSound public="1" set="method" line="401"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadSound>
		<loadMusic public="1" set="method" line="402"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Music"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadMusic>
		<loadVideo public="1" set="method" line="403"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Video"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadVideo>
		<loadFont public="1" set="method" line="405"><f a="name:style:size">
	<c path="String"/>
	<c path="kha.FontStyle"/>
	<x path="Float"/>
	<c path="kha.Font"/>
</f></loadFont>
		<loadURL public="1" set="method" line="407"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></loadURL>
		<setNormalCursor public="1" set="method" line="409"><f a=""><x path="Void"/></f></setNormalCursor>
		<setHandCursor public="1" set="method" line="410"><f a=""><x path="Void"/></f></setHandCursor>
		<setCursorBusy public="1" set="method" line="411"><f a="busy">
	<x path="Bool"/>
	<x path="Void"/>
</f></setCursorBusy>
		<showKeyboard public="1" set="method" line="413"><f a=""><x path="Void"/></f></showKeyboard>
		<hideKeyboard public="1" set="method" line="414"><f a=""><x path="Void"/></f></hideKeyboard>
		<quit public="1" set="method" line="416"><f a=""><x path="Void"/></f></quit>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":expose"/>
		</meta>
	</class>
	<class path="kha.Media" params="" file="Kha/Sources/kha/Media.hx">
		<implements path="kha.Resource"/>
		<play public="1" set="method" line="16">
			<f a="?loop">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Play / resume the media element.
	 * 
	 * @param loop		If playing it looped, default = false.</haxe_doc>
		</play>
		<pause public="1" set="method" line="20">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pause the media element.</haxe_doc>
		</pause>
		<stop public="1" set="method" line="24">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pause the stop element.</haxe_doc>
		</stop>
		<getLength public="1" set="method" line="29">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Return the media length, in milliseconds.</haxe_doc>
		</getLength>
		<getCurrentPos public="1" set="method" line="34">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Return the media position, in milliseconds.</haxe_doc>
		</getCurrentPos>
		<getVolume public="1" set="method" line="39">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Return the media volume, between 0 and 1.</haxe_doc>
		</getVolume>
		<setVolume public="1" set="method" line="46">
			<f a="volume">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the media volume, between 0 and 1.
	 *
	 * @param volume	The new volume, between 0 and 1.</haxe_doc>
		</setVolume>
		<isFinished public="1" set="method" line="51">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* If the media has finished or not.</haxe_doc>
		</isFinished>
		<unload public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unload the resource from memory.</haxe_doc>
		</unload>
		<new public="1" set="method" line="10">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Create a new media object instance.</haxe_doc>
		</new>
		<haxe_doc>* This class is used for dynamic media like sounds or videos</haxe_doc>
	</class>
	<class path="kha.Mouse" params="" file="Kha/Sources/kha/Mouse.hx">
		<hidden><x path="Bool"/></hidden>
		<forceSystem><x path="Bool"/></forceSystem>
		<cursors><c path="Array"><c path="kha.Cursor"/></c></cursors>
		<cursorIndex><x path="Int"/></cursorIndex>
		<show public="1" set="method" line="20"><f a=""><x path="Void"/></f></show>
		<hide public="1" set="method" line="25"><f a=""><x path="Void"/></f></hide>
		<hideSystemCursor set="method" line="30"><f a=""><x path="Void"/></f></hideSystemCursor>
		<showSystemCursor set="method" line="34"><f a=""><x path="Void"/></f></showSystemCursor>
		<forceSystemCursor public="1" set="method" line="38"><f a="force">
	<x path="Bool"/>
	<x path="Void"/>
</f></forceSystemCursor>
		<pushCursor public="1" set="method" line="47"><f a="cursorImage">
	<c path="kha.Cursor"/>
	<x path="Void"/>
</f></pushCursor>
		<popCursor public="1" set="method" line="53"><f a=""><x path="Void"/></f></popCursor>
		<render public="1" set="method" line="63"><f a="g">
	<c path="kha.graphics2.Graphics"/>
	<x path="Void"/>
</f></render>
		<update public="1" set="method" line="67"><f a=""><x path="Void"/></f></update>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="kha.Music" params="" file="Kha/Sources/kha/Music.hx">
		<extends path="kha.Media"/>
		<data public="1">
			<c path="haxe.io.Bytes"/>
			<haxe_doc>* The music file in a bytes.</haxe_doc>
		</data>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This represents a Music file.</haxe_doc>
	</class>
	<class path="kha.Rectangle" params="" file="Kha/Sources/kha/Rectangle.hx">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X coordinate of the point.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y coordinate of the point.</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the rectangle.</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the rectangle.</haxe_doc>
		</height>
		<setPos public="1" set="method" line="42">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the rectangle position.</haxe_doc>
		</setPos>
		<moveX public="1" set="method" line="52">
			<f a="xdelta">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move the rectangle in the X axis.
	 *
	 * @param xdelta		The amount to move.</haxe_doc>
		</moveX>
		<moveY public="1" set="method" line="61">
			<f a="ydelta">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move the rectangle in the Y axis.
	 *
	 * @param ydelta		The ammount to move.</haxe_doc>
		</moveY>
		<collision public="1" set="method" line="72">
			<f a="r">
				<c path="kha.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if some Rectangle object overlaps this Rectangle object.
	 * 
	 * @param	r	The rectangle being tested.
	 * 
	 * @return	Whether or not the two rectangles overlap.</haxe_doc>
		</collision>
		<new public="1" set="method" line="32">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new rectangle.
	 * 
	 * @param	x		The X-coordinate of the rectangle in space.
	 * @param	y		The Y-coordinate of the rectangle in space.
	 * @param	width	Desired width of the rectangle.
	 * @param	height	Desired height of the rectangle.</haxe_doc>
		</new>
		<haxe_doc>* Stores a rectangle.</haxe_doc>
	</class>
	<class path="kha.Rotation" params="" file="Kha/Sources/kha/Rotation.hx">
		<center public="1"><c path="kha.math.Vector2"/></center>
		<angle public="1"><x path="Float"/></angle>
		<new public="1" set="method" line="9"><f a="center:angle">
	<c path="kha.math.Vector2"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="kha.TargetRectangle" params="" file="Kha/Sources/kha/Scaler.hx" module="kha.Scaler">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<scaleFactor public="1"><x path="Float"/></scaleFactor>
		<rotation public="1"><e path="kha.ScreenRotation"/></rotation>
		<new public="1" set="method" line="20"><f a="x:y:w:h:s:r">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<e path="kha.ScreenRotation"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Scaler" params="" file="Kha/Sources/kha/Scaler.hx">
		<targetRect public="1" set="method" line="31" static="1"><f a="width:height:destination:rotation">
	<x path="Int"/>
	<x path="Int"/>
	<c path="kha.Canvas"/>
	<e path="kha.ScreenRotation"/>
	<c path="kha.TargetRectangle"/>
</f></targetRect>
		<transformX public="1" set="method" line="102" static="1"><f a="x:y:source:destination:rotation">
	<x path="Int"/>
	<x path="Int"/>
	<c path="kha.Image"/>
	<c path="kha.Canvas"/>
	<e path="kha.ScreenRotation"/>
	<x path="Int"/>
</f></transformX>
		<transformY public="1" set="method" line="116" static="1"><f a="x:y:source:destination:rotation">
	<x path="Int"/>
	<x path="Int"/>
	<c path="kha.Image"/>
	<c path="kha.Canvas"/>
	<e path="kha.ScreenRotation"/>
	<x path="Int"/>
</f></transformY>
		<scale public="1" set="method" line="130" static="1"><f a="source:destination:rotation">
	<c path="kha.Image"/>
	<c path="kha.Canvas"/>
	<e path="kha.ScreenRotation"/>
	<x path="Void"/>
</f></scale>
		<getScaledTransformation public="1" set="method" line="138" static="1"><f a="width:height:destination:rotation">
	<x path="Int"/>
	<x path="Int"/>
	<c path="kha.Canvas"/>
	<e path="kha.ScreenRotation"/>
	<c path="kha.math.Matrix3"/>
</f></getScaledTransformation>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.TimeTask" params="" file="Kha/Sources/kha/Scheduler.hx" module="kha.Scheduler">
		<task public="1"><f a=""><x path="Bool"/></f></task>
		<start public="1"><x path="Float"/></start>
		<period public="1"><x path="Float"/></period>
		<duration public="1"><x path="Float"/></duration>
		<next public="1"><x path="Float"/></next>
		<id public="1"><x path="Int"/></id>
		<groupId public="1"><x path="Int"/></groupId>
		<active public="1"><x path="Bool"/></active>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.FrameTask" params="" file="Kha/Sources/kha/Scheduler.hx" module="kha.Scheduler">
		<task public="1"><f a=""><x path="Bool"/></f></task>
		<priority public="1"><x path="Int"/></priority>
		<id public="1"><x path="Int"/></id>
		<active public="1"><x path="Bool"/></active>
		<new public="1" set="method" line="26"><f a="task:priority:id">
	<f a=""><x path="Bool"/></f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Scheduler" params="" file="Kha/Sources/kha/Scheduler.hx">
		<timeTasks static="1"><c path="Array"><c path="kha.TimeTask"/></c></timeTasks>
		<frameTasks static="1"><c path="Array"><c path="kha.FrameTask"/></c></frameTasks>
		<current static="1"><x path="Float"/></current>
		<lastTime static="1"><x path="Float"/></lastTime>
		<frame_tasks_sorted static="1"><x path="Bool"/></frame_tasks_sorted>
		<stopped static="1"><x path="Bool"/></stopped>
		<vsync static="1"><x path="Bool"/></vsync>
		<onedifhz static="1"><x path="Float"/></onedifhz>
		<currentFrameTaskId static="1"><x path="Int"/></currentFrameTaskId>
		<currentTimeTaskId static="1"><x path="Int"/></currentTimeTaskId>
		<currentGroupId static="1"><x path="Int"/></currentGroupId>
		<halted_count static="1"><x path="Int"/></halted_count>
		<DIF_COUNT line="53" static="1"><x path="Int"/></DIF_COUNT>
		<maxframetime line="54" static="1"><x path="Float"/></maxframetime>
		<deltas static="1"><c path="Array"><x path="Float"/></c></deltas>
		<dScale line="59" static="1"><x path="Float"/></dScale>
		<startTime line="61" static="1"><x path="Float"/></startTime>
		<lastNow line="63" static="1"><x path="Float"/></lastNow>
		<init public="1" set="method" line="65" static="1"><f a=""><x path="Void"/></f></init>
		<start public="1" set="method" line="84" static="1"><f a=""><x path="Void"/></f></start>
		<stop public="1" set="method" line="96" static="1"><f a=""><x path="Void"/></f></stop>
		<isStopped public="1" set="method" line="100" static="1"><f a=""><x path="Bool"/></f></isStopped>
		<back public="1" set="method" line="104" static="1"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></back>
		<executeFrame public="1" set="method" line="119" static="1"><f a=""><x path="Void"/></f></executeFrame>
		<time public="1" set="method" line="243" static="1"><f a=""><x path="Float"/></f></time>
		<realTime public="1" set="method" line="247" static="1"><f a=""><x path="Float"/></f></realTime>
		<resetTime public="1" set="method" line="251" static="1"><f a=""><x path="Void"/></f></resetTime>
		<addBreakableFrameTask public="1" set="method" line="265" static="1"><f a="task:priority">
	<f a=""><x path="Bool"/></f>
	<x path="Int"/>
	<x path="Int"/>
</f></addBreakableFrameTask>
		<addFrameTask public="1" set="method" line="271" static="1"><f a="task:priority">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<x path="Int"/>
</f></addFrameTask>
		<removeFrameTask public="1" set="method" line="275" static="1"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></removeFrameTask>
		<generateGroupId public="1" set="method" line="285" static="1"><f a=""><x path="Int"/></f></generateGroupId>
		<addBreakableTimeTaskToGroup public="1" set="method" line="289" static="1"><f a="groupId:task:start:?period:?duration">
	<x path="Int"/>
	<f a=""><x path="Bool"/></f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></addBreakableTimeTaskToGroup>
		<addTimeTaskToGroup public="1" set="method" line="308" static="1"><f a="groupId:task:start:?period:?duration">
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></addTimeTaskToGroup>
		<addBreakableTimeTask public="1" set="method" line="312" static="1"><f a="task:start:?period:?duration">
	<f a=""><x path="Bool"/></f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></addBreakableTimeTask>
		<addTimeTask public="1" set="method" line="316" static="1"><f a="task:start:?period:?duration">
	<f a=""><x path="Void"/></f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></addTimeTask>
		<getTimeTask set="method" line="320" static="1"><f a="id">
	<x path="Int"/>
	<c path="kha.TimeTask"/>
</f></getTimeTask>
		<removeTimeTask public="1" set="method" line="329" static="1"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></removeTimeTask>
		<removeTimeTasks public="1" set="method" line="337" static="1"><f a="groupId">
	<x path="Int"/>
	<x path="Void"/>
</f></removeTimeTasks>
		<numTasksInSchedule public="1" set="method" line="350" static="1"><f a=""><x path="Int"/></f></numTasksInSchedule>
		<insertSorted set="method" line="354" static="1"><f a="list:task">
	<c path="Array"><c path="kha.TimeTask"/></c>
	<c path="kha.TimeTask"/>
	<x path="Void"/>
</f></insertSorted>
		<sortFrameTasks set="method" line="364" static="1"><f a=""><x path="Void"/></f></sortFrameTasks>
		<get_deltaScale set="method" line="378" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Delta time between frames</haxe_doc>
		</get_deltaScale>
		<set_deltaScale set="method" line="383" static="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_deltaScale>
		<deltaScale public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>Multiplier for delta time</haxe_doc>
		</deltaScale>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Score" params="" file="Kha/Sources/kha/Score.hx">
		<name><c path="String"/></name>
		<score><x path="Int"/></score>
		<getName public="1" set="method" line="12"><f a=""><c path="String"/></f></getName>
		<getScore public="1" set="method" line="16"><f a=""><x path="Int"/></f></getScore>
		<increase public="1" set="method" line="20"><f a="amount">
	<x path="Int"/>
	<x path="Void"/>
</f></increase>
		<new public="1" set="method" line="7"><f a="name:score">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.ScreenCanvas" params="" file="Kha/Sources/kha/ScreenCanvas.hx">
		<implements path="kha.Canvas"/>
		<instance line="8" static="1"><c path="kha.ScreenCanvas"/></instance>
		<the public="1" get="accessor" set="null" static="1">
			<c path="kha.ScreenCanvas"/>
			<haxe_doc>* Static instance of the ScreenCanvas.</haxe_doc>
		</the>
		<get_the set="method" line="19" static="1"><f a=""><c path="kha.ScreenCanvas"/></f></get_the>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The width of the canvas in pixels.</haxe_doc>
		</width>
		<get_width set="method" line="29"><f a=""><x path="Int"/></f></get_width>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The height of the canvas in pixels.</haxe_doc>
		</height>
		<get_height set="method" line="39"><f a=""><x path="Int"/></f></get_height>
		<g1 public="1" get="accessor" set="null">
			<c path="kha.graphics1.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics1 interface object.<br>
	 * Basic setPixel operation.]]></haxe_doc>
		</g1>
		<get_g1 set="method" line="49"><f a=""><c path="kha.graphics1.Graphics"/></f></get_g1>
		<g2 public="1" get="accessor" set="null">
			<c path="kha.graphics2.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics2 interface object.<br>
	 * Use this for 2D operations.]]></haxe_doc>
		</g2>
		<get_g2 set="method" line="59"><f a=""><c path="kha.graphics2.Graphics"/></f></get_g2>
		<g4 public="1" get="accessor" set="null">
			<c path="kha.graphics4.Graphics"/>
			<haxe_doc><![CDATA[* The Graphics4 interface object.<br>
	 * Use this for 3D operations.]]></haxe_doc>
		</g4>
		<get_g4 set="method" line="70"><f a=""><c path="kha.graphics4.Graphics"/></f></get_g4>
		<new set="method" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This represents the screen canvas.
 * This is deprecated.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.ScreenRotation" params="" file="Kha/Sources/kha/ScreenRotation.hx">
		<RotationNone/>
		<Rotation90/>
		<Rotation180/>
		<Rotation270/>
		<haxe_doc>* Enum with all the possible rotations.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.Sound" params="" file="Kha/Sources/kha/Sound.hx">
		<implements path="kha.Resource"/>
		<data public="1">
			<x path="haxe.ds.Vector"><x path="Float"/></x>
			<haxe_doc>* The sound data.</haxe_doc>
		</data>
		<play public="1" set="method" line="24">
			<f a=""><c path="kha.SoundChannel"/></f>
			<haxe_doc>* Play this sound.
	 *
	 * @return		Return a sound channel.</haxe_doc>
		</play>
		<unload public="1" set="method" line="31">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unload this sound resource.</haxe_doc>
		</unload>
		<new public="1" set="method" line="17">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiate a new sound object.</haxe_doc>
		</new>
		<haxe_doc>* This represents a Sound file.</haxe_doc>
	</class>
	<class path="kha.SoundChannel" params="" file="Kha/Sources/kha/SoundChannel.hx">
		<wasStopped><x path="Bool"/></wasStopped>
		<play public="1" set="method" line="8"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method" line="10"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="12"><f a=""><x path="Void"/></f></stop>
		<getLength public="1" set="method" line="14"><f a=""><x path="Int"/></f></getLength>
		<getCurrentPos public="1" set="method" line="16"><f a=""><x path="Int"/></f></getCurrentPos>
		<getVolume public="1" set="method" line="18"><f a=""><x path="Float"/></f></getVolume>
		<setVolume public="1" set="method" line="20"><f a="volume">
	<x path="Float"/>
	<x path="Void"/>
</f></setVolume>
		<setPan public="1" set="method" line="22"><f a="pan">
	<x path="Float"/>
	<x path="Void"/>
</f></setPan>
		<getPan public="1" set="method" line="24"><f a=""><x path="Float"/></f></getPan>
		<isFinished public="1" set="method" line="26"><f a=""><x path="Bool"/></f></isFinished>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="kha.GamepadStates" params="" file="Kha/Backends/HTML5/kha/Starter.hx" module="kha.Starter">
		<axes public="1"><c path="Array"><x path="Float"/></c></axes>
		<buttons public="1"><c path="Array"><x path="Float"/></c></buttons>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Starter" params="" file="Kha/Backends/HTML5/kha/Starter.hx">
		<frame static="1"><c path="kha.Framebuffer"/></frame>
		<pressedKeys static="1"><c path="Array"><x path="Bool"/></c></pressedKeys>
		<lastPressedKey static="1"><x path="Int"/></lastPressedKey>
		<pressedKeyToChar static="1"><c path="Array"><c path="String"/></c></pressedKeyToChar>
		<buttonspressed static="1"><c path="Array"><x path="Bool"/></c></buttonspressed>
		<leftMouseCtrlDown line="40" static="1"><x path="Bool"/></leftMouseCtrlDown>
		<keyboard static="1"><c path="kha.input.Keyboard"/></keyboard>
		<mouse static="1"><c path="kha.input.Mouse"/></mouse>
		<gamepad static="1"><c path="kha.input.Gamepad"/></gamepad>
		<gamepadStates static="1"><c path="Array"><c path="kha.GamepadStates"/></c></gamepadStates>
		<mouseX static="1">
			<x path="Int"/>
			<meta><m n=":allow"><e>kha.Scheduler</e></m></meta>
		</mouseX>
		<mouseY static="1">
			<x path="Int"/>
			<meta><m n=":allow"><e>kha.Scheduler</e></m></meta>
		</mouseY>
		<checkGamepadButton set="method" line="72" static="1"><f a="pad:num:button">
	<d/>
	<x path="Int"/>
	<e path="kha.Button"/>
	<x path="Void"/>
</f></checkGamepadButton>
		<checkGamepad set="method" line="87" static="1"><f a="pad">
	<d/>
	<x path="Void"/>
</f></checkGamepad>
		<unload set="method" line="232" static="1"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></unload>
		<setMouseXY get="inline" set="null" line="238" static="1"><f a="event">
	<c path="js.html.MouseEvent"/>
	<x path="Void"/>
</f></setMouseXY>
		<mouseDown set="method" line="246" static="1"><f a="event">
	<c path="js.html.MouseEvent"/>
	<x path="Void"/>
</f></mouseDown>
		<mouseUp set="method" line="269" static="1"><f a="event">
	<c path="js.html.MouseEvent"/>
	<x path="Void"/>
</f></mouseUp>
		<mouseMove set="method" line="291" static="1"><f a="event">
	<c path="js.html.MouseEvent"/>
	<x path="Void"/>
</f></mouseMove>
		<checkMouseShift set="method" line="298" static="1"><f a="event">
	<c path="js.html.MouseEvent"/>
	<x path="Void"/>
</f></checkMouseShift>
		<checkKeyShift set="method" line="310" static="1"><f a="event">
	<d/>
	<x path="Void"/>
</f></checkKeyShift>
		<keyDown set="method" line="322" static="1"><f a="event">
	<c path="js.html.KeyboardEvent"/>
	<x path="Void"/>
</f></keyDown>
		<keyPress set="method" line="408" static="1"><f a="event">
	<d/>
	<x path="Void"/>
</f></keyPress>
		<keyUp set="method" line="445" static="1"><f a="event">
	<c path="js.html.KeyboardEvent"/>
	<x path="Void"/>
</f></keyUp>
		<gameToStart><c path="kha.Game"/></gameToStart>
		<start public="1" set="method" line="106"><f a="game">
	<c path="kha.Game"/>
	<x path="Void"/>
</f></start>
		<loadFinished public="1" set="method" line="112">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</loadFinished>
		<new public="1" set="method" line="49">
			<f a="?backbufferFormat">
				<e path="kha.graphics4.TextureFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.StorageFile" params="" file="Kha/Sources/kha/StorageFile.hx">
		<read public="1" set="method" line="9"><f a=""><c path="kha.Blob"/></f></read>
		<write public="1" set="method" line="10"><f a="data">
	<c path="kha.Blob"/>
	<x path="Void"/>
</f></write>
		<append public="1" set="method" line="11"><f a="data">
	<c path="kha.Blob"/>
	<x path="Void"/>
</f></append>
		<canAppend public="1" set="method" line="12"><f a=""><x path="Bool"/></f></canAppend>
		<maxSize public="1" set="method" line="13"><f a=""><x path="Int"/></f></maxSize>
		<writeString public="1" set="method" line="15"><f a="data">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<appendString public="1" set="method" line="20"><f a="data">
	<c path="String"/>
	<x path="Void"/>
</f></appendString>
		<readString public="1" set="method" line="25"><f a=""><c path="String"/></f></readString>
		<writeObject public="1" set="method" line="31"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<readObject public="1" set="method" line="35"><f a=""><d/></f></readObject>
	</class>
	<typedef path="kha.SuperString" params="" file="Kha/Sources/kha/SuperString.hx"><c path="String"/></typedef>
	<class path="kha.Sys" params="" file="Kha/Backends/HTML5/kha/Sys.hx">
		<gl public="1" static="1"><d/></gl>
		<_hasWebAudio public="1" static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</_hasWebAudio>
		<screenRotation public="1" line="9" static="1"><e path="kha.ScreenRotation"/></screenRotation>
		<theMouse static="1"><c path="kha.Mouse"/></theMouse>
		<khanvas public="1" static="1"><c path="js.html.CanvasElement"/></khanvas>
		<performance static="1"><d/></performance>
		<initPerformanceTimer public="1" set="method" line="15" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</initPerformanceTimer>
		<init public="1" set="method" line="24" static="1"><f a="canvas">
	<c path="js.html.CanvasElement"/>
	<x path="Void"/>
</f></init>
		<getTime public="1" set="method" line="29" static="1"><f a=""><x path="Float"/></f></getTime>
		<mouse public="1" get="accessor" set="null" static="1"><c path="kha.Mouse"/></mouse>
		<get_mouse public="1" set="method" line="35" static="1"><f a=""><c path="kha.Mouse"/></f></get_mouse>
		<pixelWidth public="1" get="accessor" set="null" static="1"><x path="Int"/></pixelWidth>
		<pixelHeight public="1" get="accessor" set="null" static="1"><x path="Int"/></pixelHeight>
		<get_pixelWidth public="1" set="method" line="42" static="1"><f a=""><x path="Int"/></f></get_pixelWidth>
		<get_pixelHeight public="1" set="method" line="46" static="1"><f a=""><x path="Int"/></f></get_pixelHeight>
		<vsynced public="1" set="method" line="50" static="1"><f a=""><x path="Bool"/></f></vsynced>
		<refreshRate public="1" set="method" line="54" static="1"><f a=""><x path="Int"/></f></refreshRate>
		<systemId public="1" set="method" line="58" static="1"><f a=""><c path="String"/></f></systemId>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.Video" params="" file="Kha/Sources/kha/Video.hx">
		<extends path="kha.Media"/>
		<width public="1" set="method" line="10">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* The width of the video file in pixels.</haxe_doc>
		</width>
		<height public="1" set="method" line="14">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* The height of the video file in pixels.</haxe_doc>
		</height>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This represents a Video file.</haxe_doc>
	</class>
	<class path="kha.WebGLImage" params="" file="Kha/Backends/HTML5/kha/WebGLImage.hx">
		<extends path="kha.Image"/>
		<context static="1"><d/></context>
		<init public="1" set="method" line="29" static="1"><f a=""><x path="Void"/></f></init>
		<upperPowerOfTwo set="method" line="104" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></upperPowerOfTwo>
		<image public="1"><d/></image>
		<video public="1"><c path="js.html.VideoElement"/></video>
		<data><d/></data>
		<myWidth><x path="Int"/></myWidth>
		<myHeight><x path="Int"/></myHeight>
		<format><e path="kha.graphics4.TextureFormat"/></format>
		<renderTarget><x path="Bool"/></renderTarget>
		<frameBuffer public="1"><d/></frameBuffer>
		<graphics1><c path="kha.graphics1.Graphics"/></graphics1>
		<graphics2><c path="kha.graphics2.Graphics"/></graphics2>
		<graphics4><c path="kha.graphics4.Graphics"/></graphics4>
		<get_g1 set="method" line="49" override="1"><f a=""><c path="kha.graphics1.Graphics"/></f></get_g1>
		<get_g2 set="method" line="56" override="1"><f a=""><c path="kha.graphics2.Graphics"/></f></get_g2>
		<get_g4 set="method" line="63" override="1"><f a=""><c path="kha.graphics4.Graphics"/></f></get_g4>
		<get_width set="method" line="70" override="1"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="74" override="1"><f a=""><x path="Int"/></f></get_height>
		<get_realWidth set="method" line="78" override="1"><f a=""><x path="Int"/></f></get_realWidth>
		<get_realHeight set="method" line="82" override="1"><f a=""><x path="Int"/></f></get_realHeight>
		<isOpaque public="1" set="method" line="86" override="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></isOpaque>
		<createImageData set="method" line="94"><f a=""><x path="Void"/></f></createImageData>
		<texture><d/></texture>
		<createTexture public="1" set="method" line="115"><f a=""><x path="Void"/></f></createTexture>
		<set public="1" set="method" line="139"><f a="stage">
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<lock public="1" set="method" line="147" override="1"><f a="?level">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></lock>
		<unlock public="1" set="method" line="152" override="1"><f a=""><x path="Void"/></f></unlock>
		<unload public="1" set="method" line="191" override="1"><f a=""><x path="Void"/></f></unload>
		<new public="1" set="method" line="39"><f a="width:height:format:renderTarget">
	<x path="Int"/>
	<x path="Int"/>
	<e path="kha.graphics4.TextureFormat"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="kha.audio1.MusicChannel" params="" file="Kha/Backends/HTML5/kha/audio1/MusicChannel.hx"><c path="kha.audio2.MusicChannel"/></typedef>
	<typedef path="kha.audio1.SoundChannel" params="" file="Kha/Backends/HTML5/kha/audio1/SoundChannel.hx"><c path="kha.audio2.SoundChannel"/></typedef>
	<class path="kha.audio2.Audio" params="" file="Kha/Backends/HTML5/kha/audio2/Audio.hx">
		<buffer static="1"><c path="kha.audio2.Buffer"/></buffer>
		<_context public="1" static="1">
			<c path="js.html.audio.AudioContext"/>
			<meta><m n=":noCompletion"/></meta>
		</_context>
		<processingNode static="1"><c path="js.html.audio.ScriptProcessorNode"/></processingNode>
		<initContext set="method" line="13" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</initContext>
		<_init public="1" set="method" line="31" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_init>
		<audioCallback public="1" static="1"><f a=":">
	<x path="Int"/>
	<c path="kha.audio2.Buffer"/>
	<x path="Void"/>
</f></audioCallback>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.Audio1" params="" file="Kha/Sources/kha/audio2/Audio1.hx">
		<channelCount get="inline" set="null" line="11" static="1"><x path="Int"/></channelCount>
		<soundChannels static="1"><x path="haxe.ds.Vector"><t path="kha.audio1.SoundChannel"/></x></soundChannels>
		<musicChannels static="1"><x path="haxe.ds.Vector"><t path="kha.audio1.MusicChannel"/></x></musicChannels>
		<_init public="1" set="method" line="19" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_init>
		<_mix set="method" line="28" static="1"><f a="samples:buffer">
	<x path="Int"/>
	<c path="kha.audio2.Buffer"/>
	<x path="Void"/>
</f></_mix>
		<playSound public="1" set="method" line="63" static="1"><f a="sound">
	<c path="kha.Sound"/>
	<t path="kha.audio1.SoundChannel"/>
</f></playSound>
		<playMusic public="1" set="method" line="81" static="1"><f a="music:?loop">
	<c path="kha.Music"/>
	<x path="Bool"/>
	<t path="kha.audio1.MusicChannel"/>
</f></playMusic>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.Buffer" params="" file="Kha/Sources/kha/audio2/Buffer.hx">
		<channels public="1"><x path="Int"/></channels>
		<samplesPerSecond public="1"><x path="Int"/></samplesPerSecond>
		<data public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></data>
		<size public="1"><x path="Int"/></size>
		<readLocation public="1"><x path="Int"/></readLocation>
		<writeLocation public="1"><x path="Int"/></writeLocation>
		<new public="1" set="method" line="14"><f a="size:channels:samplesPerSecond">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.MusicChannel" params="" file="Kha/Sources/kha/audio2/MusicChannel.hx">
		<bufferSize get="inline" set="null" line="10" static="1"><x path="Int"/></bufferSize>
		<volume public="1"><x path="Float"/></volume>
		<buffer><x path="haxe.ds.Vector"><x path="Float"/></x></buffer>
		<reader><c path="kha.audio2.ogg.vorbis.Reader"/></reader>
		<position><x path="Int"/></position>
		<count><x path="Int"/></count>
		<atend><x path="Bool"/></atend>
		<loop><x path="Bool"/></loop>
		<updateBuffer set="method" line="26"><f a=""><x path="Void"/></f></updateBuffer>
		<nextSample public="1" set="method" line="49"><f a=""><x path="Float"/></f></nextSample>
		<ended public="1" set="method" line="58"><f a=""><x path="Bool"/></f></ended>
		<new public="1" set="method" line="18"><f a="data:loop">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.SoundChannel" params="" file="Kha/Sources/kha/audio2/SoundChannel.hx">
		<data public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></data>
		<volume public="1"><x path="Float"/></volume>
		<position><x path="Int"/></position>
		<nextSample public="1" set="method" line="15"><f a=""><x path="Float"/></f></nextSample>
		<ended public="1" set="method" line="21"><f a=""><x path="Bool"/></f></ended>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.tools.Crc32" params="" file="Kha/Sources/kha/audio2/ogg/tools/Crc32.hx">
		<POLY get="inline" set="null" line="10" static="1"><x path="UInt"/></POLY>
		<table static="1"><x path="haxe.ds.Vector"><x path="UInt"/></x></table>
		<init public="1" set="method" line="13" static="1"><f a=""><x path="Void"/></f></init>
		<update public="1" get="inline" set="null" line="28" static="1"><f a="crc:byte">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
</f></update>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.tools.MathTools" params="" file="Kha/Sources/kha/audio2/ogg/tools/MathTools.hx">
		<ilog public="1" get="inline" set="null" line="9" static="1"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></ilog>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.tools.Mdct" params="" file="Kha/Sources/kha/audio2/ogg/tools/Mdct.hx">
		<inverseTransform public="1" get="inline" set="null" line="9" static="1"><f a="buffer:n:a:b:c:bitReverse">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Void"/>
</f></inverseTransform>
		<step3Iter0Loop get="inline" set="null" line="303" static="1"><f a="n:e:i_off:k_off:a">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></step3Iter0Loop>
		<step3InnerRLoop get="inline" set="null" line="349" static="1"><f a="lim:e:d0:k_off:a:k1">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></step3InnerRLoop>
		<step3InnerSLoop get="inline" set="null" line="397" static="1"><f a="n:e:i_off:k_off:a:aOffset0:aOffset1:k0">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></step3InnerSLoop>
		<iter54 get="inline" set="null" line="445" static="1"><f a="e:zOffset">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></iter54>
		<step3InnerSLoopLd654 get="inline" set="null" line="481" static="1"><f a="n:e:i_off:a:baseN">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></step3InnerSLoopLd654>
		<haxe_doc>* modified discrete cosine transform
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.Reader" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/Reader.hx">
		<openFromBytes public="1" set="method" line="85" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="kha.audio2.ogg.vorbis.Reader"/>
</f></openFromBytes>
		<seekBytes set="method" line="90" static="1"><f a="bytes:pos">
	<c path="haxe.io.BytesInput"/>
	<x path="Int"/>
	<x path="Void"/>
</f></seekBytes>
		<readAll public="1" set="method" line="102" static="1"><f a="bytes:output:?useFloat">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Output"/>
	<x path="Bool"/>
	<c path="kha.audio2.ogg.vorbis.data.Header"/>
</f></readAll>
		<decoder public="1" set="null"><c path="kha.audio2.ogg.vorbis.VorbisDecoder"/></decoder>
		<header public="1" get="accessor" set="null"><c path="kha.audio2.ogg.vorbis.data.Header"/></header>
		<get_header set="method" line="33"><f a=""><c path="kha.audio2.ogg.vorbis.data.Header"/></f></get_header>
		<totalSample public="1" get="accessor" set="null"><x path="Int"/></totalSample>
		<get_totalSample set="method" line="38"><f a=""><x path="Int"/></f></get_totalSample>
		<totalMillisecond public="1" get="accessor" set="null"><x path="Float"/></totalMillisecond>
		<get_totalMillisecond set="method" line="44"><f a=""><x path="Float"/></f></get_totalMillisecond>
		<currentSample public="1" get="accessor" set="accessor"><x path="Int"/></currentSample>
		<get_currentSample set="method" line="49"><f a=""><x path="Int"/></f></get_currentSample>
		<set_currentSample set="method" line="53"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_currentSample>
		<currentMillisecond public="1" get="accessor" set="accessor"><x path="Float"/></currentMillisecond>
		<get_currentMillisecond set="method" line="60"><f a=""><x path="Float"/></f></get_currentMillisecond>
		<set_currentMillisecond set="method" line="65"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_currentMillisecond>
		<loopStart public="1"><t path="Null"><x path="Int"/></t></loopStart>
		<loopLength public="1"><t path="Null"><x path="Int"/></t></loopLength>
		<seekFunc><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></seekFunc>
		<inputLength><x path="Int"/></inputLength>
		<read public="1" set="method" line="116"><f a="output:?samples:?channels:?sampleRate:?useFloat">
	<c path="haxe.io.Output"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></read>
		<clone public="1" set="method" line="131"><f a=""><c path="kha.audio2.ogg.vorbis.Reader"/></f></clone>
		<sampleToMillisecond public="1" get="inline" set="null" line="142"><f a="samples">
	<x path="Int"/>
	<x path="Float"/>
</f></sampleToMillisecond>
		<millisecondToSample public="1" get="inline" set="null" line="146"><f a="millseconds">
	<x path="Float"/>
	<x path="Int"/>
</f></millisecondToSample>
		<new set="method" line="76"><f a="input:seekFunc:inputLength">
	<c path="haxe.io.Input"/>
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* public domain ogg reader.
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="kha.audio2.ogg.vorbis._Reader.InitData" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/Reader.hx" private="1" module="kha.audio2.ogg.vorbis.Reader"><a>
	<seekFunc><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></seekFunc>
	<inputLength><x path="Int"/></inputLength>
	<input><c path="haxe.io.Input"/></input>
</a></typedef>
	<class path="kha.audio2.ogg.vorbis.VorbisDecodeState" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecodeState.hx">
		<INVALID_BITS public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></INVALID_BITS>
		<page public="1" set="null"><c path="kha.audio2.ogg.vorbis.data.Page"/></page>
		<eof public="1" set="null"><x path="Bool"/></eof>
		<pFirst public="1" set="null"><c path="kha.audio2.ogg.vorbis.data.ProbedPage"/></pFirst>
		<pLast public="1" set="null"><c path="kha.audio2.ogg.vorbis.data.ProbedPage"/></pLast>
		<validBits public="1" set="null"><x path="Int"/></validBits>
		<inputPosition public="1" set="null"><x path="Int"/></inputPosition>
		<input public="1" set="null"><c path="haxe.io.Input"/></input>
		<discardSamplesDeferred public="1"><x path="Int"/></discardSamplesDeferred>
		<segments public="1" set="null"><x path="haxe.ds.Vector"><x path="Int"/></x></segments>
		<bytesInSeg public="1"><x path="Int"/></bytesInSeg>
		<channelBuffers public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></channelBuffers>
		<channelBufferStart public="1"><x path="Int"/></channelBufferStart>
		<channelBufferEnd public="1"><x path="Int"/></channelBufferEnd>
		<currentSample public="1" set="null"><x path="Int"/></currentSample>
		<previousWindow public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></previousWindow>
		<previousLength public="1"><x path="Int"/></previousLength>
		<finalY public="1"><x path="haxe.ds.Vector"><c path="Array"><x path="Int"/></c></x></finalY>
		<firstDecode><x path="Bool"/></firstDecode>
		<nextSeg><x path="Int"/></nextSeg>
		<acc><x path="UInt"/></acc>
		<lastSeg><x path="Bool"/></lastSeg>
		<lastSegWhich><x path="Int"/></lastSegWhich>
		<endSegWithKnownLoc><x path="Int"/></endSegWithKnownLoc>
		<knownLocForPacket><x path="Int"/></knownLocForPacket>
		<error><c path="kha.audio2.ogg.vorbis.data.ReaderError"/></error>
		<currentLoc><x path="Int"/></currentLoc>
		<currentLocValid><x path="Int"/></currentLocValid>
		<firstAudioPageOffset><x path="UInt"/></firstAudioPageOffset>
		<setup public="1" set="method" line="78"><f a="loc0:loc1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setup>
		<clone public="1" set="method" line="118"><f a="seekFunc">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
</f></clone>
		<next public="1" set="method" line="154"><f a=""><x path="Int"/></f></next>
		<startPacket public="1" set="method" line="189"><f a=""><x path="Void"/></f></startPacket>
		<maybeStartPacket public="1" set="method" line="202"><f a=""><x path="Bool"/></f></maybeStartPacket>
		<readBits public="1" get="inline" set="null" line="230"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></readBits>
		<readPacketRaw get="inline" set="null" line="270"><f a=""><x path="Int"/></f></readPacketRaw>
		<readPacket public="1" get="inline" set="null" line="280"><f a=""><x path="Int"/></f></readPacket>
		<flushPacket public="1" get="inline" set="null" line="287"><f a=""><x path="Void"/></f></flushPacket>
		<vorbisValidate public="1" get="inline" set="null" line="294"><f a=""><x path="Void"/></f></vorbisValidate>
		<firstPageValidate public="1" set="method" line="304"><f a=""><x path="Void"/></f></firstPageValidate>
		<startFirstDecode public="1" set="method" line="314"><f a=""><x path="Void"/></f></startFirstDecode>
		<capturePattern public="1" get="inline" set="null" line="320"><f a=""><x path="Void"/></f></capturePattern>
		<skip get="inline" set="null" line="327"><f a="len">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<prepHuffman set="method" line="332"><f a=""><x path="Void"/></f></prepHuffman>
		<decode public="1" get="inline" set="null" line="350"><f a="c">
	<c path="kha.audio2.ogg.vorbis.data.Codebook"/>
	<x path="Int"/>
</f></decode>
		<decodeRaw public="1" get="inline" set="null" line="358"><f a="c">
	<c path="kha.audio2.ogg.vorbis.data.Codebook"/>
	<x path="Int"/>
</f></decodeRaw>
		<isLastByte public="1" get="inline" set="null" line="382"><f a=""><x path="Bool"/></f></isLastByte>
		<finishDecodePacket public="1" set="method" line="387"><f a="previousLength:n:r">
	<x path="Int"/>
	<x path="Int"/>
	<t path="kha.audio2.ogg.vorbis.DecodeInitialResult"/>
	<a>
		<right><x path="Int"/></right>
		<len><x path="Int"/></len>
		<left><x path="Int"/></left>
	</a>
</f></finishDecodePacket>
		<readInt32 public="1" get="inline" set="null" line="462"><f a=""><x path="Int"/></f></readInt32>
		<readByte public="1" get="inline" set="null" line="468"><f a=""><x path="Int"/></f></readByte>
		<read public="1" get="inline" set="null" line="474"><f a="n">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></read>
		<readBytes public="1" get="inline" set="null" line="483"><f a="n">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readBytes>
		<readString public="1" get="inline" set="null" line="488"><f a="n">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<getSampleNumber public="1" set="method" line="494"><f a="seekFunc:inputLength">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="UInt"/>
	<x path="Int"/>
</f></getSampleNumber>
		<forcePageResync public="1" get="inline" set="null" line="566"><f a=""><x path="Void"/></f></forcePageResync>
		<setInputOffset public="1" get="inline" set="null" line="571"><f a="seekFunc:n">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></setInputOffset>
		<findPage public="1" set="method" line="576"><f a="seekFunc:inputLength">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<e path="kha.audio2.ogg.vorbis._VorbisDecodeState.FindPageResult"/>
</f></findPage>
		<analyzePage public="1" set="method" line="650"><f a="seekFunc:h">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<c path="kha.audio2.ogg.vorbis.data.Header"/>
	<c path="kha.audio2.ogg.vorbis.data.ProbedPage"/>
</f></analyzePage>
		<decodeScalarRaw set="method" line="783"><f a="c">
	<c path="kha.audio2.ogg.vorbis.data.Codebook"/>
	<x path="Int"/>
</f></decodeScalarRaw>
		<new public="1" set="method" line="70"><f a="input">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.audio2.ogg.vorbis._VorbisDecodeState.FindPageResult" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecodeState.hx" private="1" module="kha.audio2.ogg.vorbis.VorbisDecodeState">
		<Found a="end:last">
			<x path="Int"/>
			<x path="Bool"/>
		</Found>
		<NotFound/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="kha.audio2.ogg.vorbis.VorbisDecoder" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecoder.hx">
		<start public="1" set="method" line="72" static="1"><f a="input">
	<c path="haxe.io.Input"/>
	<c path="kha.audio2.ogg.vorbis.VorbisDecoder"/>
</f></start>
		<previousWindow><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></previousWindow>
		<previousLength><x path="Int"/></previousLength>
		<finalY><x path="haxe.ds.Vector"><c path="Array"><x path="Int"/></c></x></finalY>
		<a><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></a>
		<b><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></b>
		<c><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></c>
		<window><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></window>
		<bitReverseData><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></bitReverseData>
		<channelBuffers><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></channelBuffers>
		<channelBufferStart><x path="Int"/></channelBufferStart>
		<channelBufferEnd><x path="Int"/></channelBufferEnd>
		<header public="1" set="null"><c path="kha.audio2.ogg.vorbis.data.Header"/></header>
		<currentSample public="1" set="null"><x path="Int"/></currentSample>
		<totalSample public="1" set="null"><t path="Null"><x path="Int"/></t></totalSample>
		<decodeState><c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/></decodeState>
		<read public="1" set="method" line="82"><f a="output:samples:channels:sampleRate:useFloat">
	<c path="haxe.io.Output"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></read>
		<skipSamples public="1" set="method" line="147"><f a="len">
	<x path="Int"/>
	<x path="Int"/>
</f></skipSamples>
		<setupSampleNumber public="1" set="method" line="166"><f a="seekFunc:inputLength">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></setupSampleNumber>
		<seek public="1" set="method" line="173"><f a="seekFunc:inputLength:sampleNumber">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Void"/>
</f></seek>
		<seekFrameFromPage public="1" set="method" line="275"><f a="seekFunc:pageStart:firstSample:targetSample">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></seekFrameFromPage>
		<clone public="1" set="method" line="338"><f a="seekFunc">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<c path="kha.audio2.ogg.vorbis.VorbisDecoder"/>
</f></clone>
		<ensurePosition public="1" set="method" line="370"><f a="seekFunc">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensurePosition>
		<getFrameFloat set="method" line="374"><f a=""><x path="Int"/></f></getFrameFloat>
		<pumpFirstFrame set="method" line="389"><f a=""><x path="Void"/></f></pumpFirstFrame>
		<finishFrame set="method" line="393"><f a="r">
	<t path="kha.audio2.ogg.vorbis.DecodePacketResult"/>
	<x path="Int"/>
</f></finishFrame>
		<getWindow set="method" line="453"><f a="len">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
</f></getWindow>
		<initBlocksize set="method" line="466"><f a="bs:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></initBlocksize>
		<inverseMdct set="method" line="480"><f a="buffer:n:blocktype">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></inverseMdct>
		<decodePacket set="method" line="485"><f a=""><t path="kha.audio2.ogg.vorbis.DecodePacketResult"/></f></decodePacket>
		<decodeInitial set="method" line="495"><f a=""><t path="kha.audio2.ogg.vorbis.DecodeInitialResult"/></f></decodeInitial>
		<decodePacketRest set="method" line="552"><f a="r">
	<t path="kha.audio2.ogg.vorbis.DecodeInitialResult"/>
	<t path="kha.audio2.ogg.vorbis.DecodePacketResult"/>
</f></decodePacketRest>
		<new set="method" line="44"><f a="header:decodeState">
	<c path="kha.audio2.ogg.vorbis.data.Header"/>
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="kha.audio2.ogg.vorbis.DecodePacketResult" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecoder.hx" module="kha.audio2.ogg.vorbis.VorbisDecoder"><a>
	<right><x path="Int"/></right>
	<len><x path="Int"/></len>
	<left><x path="Int"/></left>
</a></typedef>
	<typedef path="kha.audio2.ogg.vorbis.DecodeInitialResult" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecoder.hx" module="kha.audio2.ogg.vorbis.VorbisDecoder"><a>
	<right><t path="kha.audio2.ogg.vorbis._VorbisDecoder.Range"/></right>
	<mode><x path="Int"/></mode>
	<left><t path="kha.audio2.ogg.vorbis._VorbisDecoder.Range"/></left>
</a></typedef>
	<typedef path="kha.audio2.ogg.vorbis._VorbisDecoder.Range" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisDecoder.hx" private="1" module="kha.audio2.ogg.vorbis.VorbisDecoder"><a>
	<start><x path="Int"/></start>
	<end><x path="Int"/></end>
</a></typedef>
	<class path="kha.audio2.ogg.vorbis.VorbisTools" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/VorbisTools.hx">
		<EOP public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></EOP>
		<integerDivideTable public="1" static="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></integerDivideTable>
		<M__PI get="inline" set="null" line="18" static="1"><x path="Float"/></M__PI>
		<DIVTAB_NUMER get="inline" set="null" line="20" static="1"><x path="Int"/></DIVTAB_NUMER>
		<DIVTAB_DENOM get="inline" set="null" line="21" static="1"><x path="Int"/></DIVTAB_DENOM>
		<INVERSE_DB_TABLE public="1" line="23" static="1"><c path="Array"><x path="Float"/></c></INVERSE_DB_TABLE>
		<assert public="1" get="inline" set="null" line="90" static="1"><f a="b:?p">
	<x path="Bool"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></assert>
		<neighbors public="1" get="inline" set="null" line="98" static="1"><f a="x:n">
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Int"/>
	<a>
		<low><x path="Int"/></low>
		<high><x path="Int"/></high>
	</a>
</f></neighbors>
		<floatUnpack public="1" get="inline" set="null" line="115" static="1"><f a="x">
	<x path="UInt"/>
	<x path="Float"/>
</f></floatUnpack>
		<bitReverse public="1" get="inline" set="null" line="125" static="1"><f a="n">
	<x path="UInt"/>
	<x path="UInt"/>
</f></bitReverse>
		<pointCompare public="1" get="inline" set="null" line="134" static="1"><f a="a:b">
	<c path="kha.audio2.ogg.vorbis.data.IntPoint"/>
	<c path="kha.audio2.ogg.vorbis.data.IntPoint"/>
	<x path="Int"/>
</f></pointCompare>
		<uintAsc public="1" set="method" line="138" static="1"><f a="a:b">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Int"/>
</f></uintAsc>
		<lookup1Values public="1" set="method" line="148" static="1"><f a="entries:dim">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lookup1Values>
		<computeWindow public="1" set="method" line="160" static="1"><f a="n:window">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></computeWindow>
		<square public="1" set="method" line="168" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></square>
		<computeBitReverse public="1" set="method" line="172" static="1"><f a="n:rev">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Void"/>
</f></computeBitReverse>
		<computeTwiddleFactors public="1" set="method" line="182" static="1"><f a="n:af:bf:cf">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></computeTwiddleFactors>
		<drawLine public="1" set="method" line="205" static="1"><f a="output:x0:y0:x1:y1:n">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawLine>
		<predictPoint public="1" get="inline" set="null" line="264" static="1"><f a="x:x0:x1:y0:y1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></predictPoint>
		<emptyFloatVector public="1" get="inline" set="null" line="274" static="1"><f a="len">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
</f></emptyFloatVector>
		<copyVector public="1" set="method" line="284" static="1"><f a="source">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
</f></copyVector>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Codebook" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Codebook.hx">
		<NO_CODE public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></NO_CODE>
		<read public="1" set="method" line="37" static="1"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<c path="kha.audio2.ogg.vorbis.data.Codebook"/>
</f></read>
		<delay line="480" static="1"><x path="Int"/></delay>
		<dimensions public="1"><x path="Int"/></dimensions>
		<entries public="1"><x path="Int"/></entries>
		<codewordLengths public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></codewordLengths>
		<minimumValue public="1"><x path="Float"/></minimumValue>
		<deltaValue public="1"><x path="Float"/></deltaValue>
		<valueBits public="1"><x path="Int"/></valueBits>
		<lookupType public="1"><x path="Int"/></lookupType>
		<sequenceP public="1"><x path="Bool"/></sequenceP>
		<sparse public="1"><x path="Bool"/></sparse>
		<lookupValues public="1"><x path="UInt"/></lookupValues>
		<multiplicands public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></multiplicands>
		<codewords public="1"><x path="haxe.ds.Vector"><x path="UInt"/></x></codewords>
		<fastHuffman public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></fastHuffman>
		<sortedCodewords public="1"><c path="Array"><x path="UInt"/></c></sortedCodewords>
		<sortedValues public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></sortedValues>
		<sortedEntries public="1"><x path="Int"/></sortedEntries>
		<addEntry get="inline" set="null" line="187"><f a="huffCode:symbol:count:len:values">
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="UInt"/></x>
	<x path="Void"/>
</f></addEntry>
		<includeInSort get="inline" set="null" line="198"><f a="len">
	<x path="Int"/>
	<x path="Bool"/>
</f></includeInSort>
		<computeCodewords set="method" line="213"><f a="len:n:values">
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="UInt"/></x>
	<x path="Bool"/>
</f></computeCodewords>
		<computeSortedHuffman set="method" line="283"><f a="lengths:values">
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="haxe.ds.Vector"><x path="UInt"/></x>
	<x path="Void"/>
</f></computeSortedHuffman>
		<computeAcceleratedHuffman set="method" line="340"><f a=""><x path="Void"/></f></computeAcceleratedHuffman>
		<codebookDecode set="method" line="366"><f a="decodeState:output:offset:len">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></codebookDecode>
		<codebookDecodeStep set="method" line="414"><f a="decodeState:output:offset:len:step">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></codebookDecodeStep>
		<decodeStart get="inline" set="null" line="457"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="Int"/>
</f></decodeStart>
		<decodeDeinterleaveRepeat public="1" set="method" line="482"><f a="decodeState:residueBuffers:ch:cInter:pInter:len:totalDecode">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<a>
		<pInter><x path="Int"/></pInter>
		<cInter><x path="Int"/></cInter>
	</a>
</f></decodeDeinterleaveRepeat>
		<residueDecode public="1" set="method" line="573"><f a="decodeState:target:offset:n:rtype">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></residueDecode>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Comment" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Comment.hx">
		<data public="1" set="null"><x path="Map">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</x></data>
		<title public="1" get="accessor" set="null"><c path="String"/></title>
		<get_title set="method" line="11"><f a=""><t path="Null"><c path="String"/></t></f></get_title>
		<loopStart public="1" get="accessor" set="null"><t path="Null"><x path="Int"/></t></loopStart>
		<get_loopStart set="method" line="16"><f a=""><t path="Null"><x path="Int"/></t></f></get_loopStart>
		<loopLength public="1" get="accessor" set="null"><t path="Null"><x path="Int"/></t></loopLength>
		<get_loopLength set="method" line="21"><f a=""><t path="Null"><x path="Int"/></t></f></get_loopLength>
		<version public="1" get="accessor" set="null"><c path="String"/></version>
		<get_version set="method" line="26"><f a=""><t path="Null"><c path="String"/></t></f></get_version>
		<album public="1" get="accessor" set="null"><c path="String"/></album>
		<get_album set="method" line="31"><f a=""><t path="Null"><c path="String"/></t></f></get_album>
		<organization public="1" get="accessor" set="null"><c path="String"/></organization>
		<get_organization set="method" line="36"><f a=""><t path="Null"><c path="String"/></t></f></get_organization>
		<tracknumber public="1" get="accessor" set="null"><c path="String"/></tracknumber>
		<get_tracknumber set="method" line="41"><f a=""><t path="Null"><c path="String"/></t></f></get_tracknumber>
		<performer public="1" get="accessor" set="null"><c path="String"/></performer>
		<get_performer set="method" line="46"><f a=""><t path="Null"><c path="String"/></t></f></get_performer>
		<copyright public="1" get="accessor" set="null"><c path="String"/></copyright>
		<get_copyright set="method" line="51"><f a=""><t path="Null"><c path="String"/></t></f></get_copyright>
		<license public="1" get="accessor" set="null"><c path="String"/></license>
		<get_license set="method" line="56"><f a=""><t path="Null"><c path="String"/></t></f></get_license>
		<artist public="1" get="accessor" set="null"><c path="String"/></artist>
		<get_artist set="method" line="61"><f a=""><t path="Null"><c path="String"/></t></f></get_artist>
		<description public="1" get="accessor" set="null"><c path="String"/></description>
		<get_description set="method" line="66"><f a=""><t path="Null"><c path="String"/></t></f></get_description>
		<genre public="1" get="accessor" set="null"><c path="String"/></genre>
		<get_genre set="method" line="71"><f a=""><t path="Null"><c path="String"/></t></f></get_genre>
		<date public="1" get="accessor" set="null"><c path="String"/></date>
		<get_date set="method" line="76"><f a=""><t path="Null"><c path="String"/></t></f></get_date>
		<location public="1" get="accessor" set="null"><c path="String"/></location>
		<get_location set="method" line="81"><f a=""><t path="Null"><c path="String"/></t></f></get_location>
		<contact public="1" get="accessor" set="null"><c path="String"/></contact>
		<get_contact set="method" line="86"><f a=""><t path="Null"><c path="String"/></t></f></get_contact>
		<isrc public="1" get="accessor" set="null"><c path="String"/></isrc>
		<get_isrc set="method" line="91"><f a=""><t path="Null"><c path="String"/></t></f></get_isrc>
		<artists public="1" get="accessor" set="null"><c path="Array"><c path="String"/></c></artists>
		<get_artists set="method" line="96"><f a=""><t path="Null"><t path="Null"><c path="Array"><c path="String"/></c></t></t></f></get_artists>
		<add public="1" set="method" line="104"><f a="key:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></add>
		<getString public="1" set="method" line="113"><f a="key">
	<c path="String"/>
	<t path="Null"><c path="String"/></t>
</f></getString>
		<getArray public="1" set="method" line="122"><f a="key">
	<c path="String"/>
	<t path="Null"><t path="Null"><c path="Array"><c path="String"/></c></t></t>
</f></getArray>
		<new public="1" set="method" line="100"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Floor" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Floor.hx">
		<read public="1" set="method" line="22" static="1"><f a="decodeState:codebooks">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Codebook"/></x>
	<c path="kha.audio2.ogg.vorbis.data.Floor"/>
</f></read>
		<floor0 public="1"><c path="kha.audio2.ogg.vorbis.data.Floor0"/></floor0>
		<floor1 public="1"><c path="kha.audio2.ogg.vorbis.data.Floor1"/></floor1>
		<type public="1"><x path="Int"/></type>
		<new set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Floor0" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Floor.hx" module="kha.audio2.ogg.vorbis.data.Floor">
		<order public="1"><x path="Int"/></order>
		<rate public="1"><x path="Int"/></rate>
		<barkMapSize public="1"><x path="Int"/></barkMapSize>
		<amplitudeBits public="1"><x path="Int"/></amplitudeBits>
		<amplitudeOffset public="1"><x path="Int"/></amplitudeOffset>
		<numberOfBooks public="1"><x path="Int"/></numberOfBooks>
		<bookList public="1"><x path="haxe.ds.Vector"><x path="UInt"/></x></bookList>
		<new public="1" set="method" line="130"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Floor1" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Floor.hx" module="kha.audio2.ogg.vorbis.data.Floor">
		<partitions public="1"><x path="Int"/></partitions>
		<partitionClassList public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></partitionClassList>
		<classDimensions public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></classDimensions>
		<classSubclasses public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></classSubclasses>
		<classMasterbooks public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></classMasterbooks>
		<subclassBooks public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></subclassBooks>
		<xlist public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></xlist>
		<sortedOrder public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></sortedOrder>
		<neighbors public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></neighbors>
		<floor1Multiplier public="1"><x path="Int"/></floor1Multiplier>
		<rangebits public="1"><x path="Int"/></rangebits>
		<values public="1"><x path="Int"/></values>
		<new public="1" set="method" line="149"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Header" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Header.hx">
		<PACKET_ID public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></PACKET_ID>
		<PACKET_COMMENT public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></PACKET_COMMENT>
		<PACKET_SETUP public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></PACKET_SETUP>
		<read public="1" set="method" line="41" static="1"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<c path="kha.audio2.ogg.vorbis.data.Header"/>
</f></read>
		<maximumBitRate public="1" set="null"><x path="UInt"/></maximumBitRate>
		<nominalBitRate public="1" set="null"><x path="UInt"/></nominalBitRate>
		<minimumBitRate public="1" set="null"><x path="UInt"/></minimumBitRate>
		<sampleRate public="1" set="null"><x path="UInt"/></sampleRate>
		<channel public="1" set="null"><x path="Int"/></channel>
		<blocksize0 public="1" set="null"><x path="Int"/></blocksize0>
		<blocksize1 public="1" set="null"><x path="Int"/></blocksize1>
		<codebooks public="1" set="null"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Codebook"/></x></codebooks>
		<floorConfig public="1" set="null"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Floor"/></x></floorConfig>
		<residueConfig public="1" set="null"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Residue"/></x></residueConfig>
		<mapping public="1" set="null"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Mapping"/></x></mapping>
		<modes public="1" set="null"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Mode"/></x></modes>
		<comment public="1" set="null"><c path="kha.audio2.ogg.vorbis.data.Comment"/></comment>
		<vendor public="1" set="null"><c path="String"/></vendor>
		<new set="method" line="37"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.IntPoint" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/IntPoint.hx">
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Mapping" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Mapping.hx">
		<read public="1" set="method" line="17" static="1"><f a="decodeState:channels">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="Int"/>
	<c path="kha.audio2.ogg.vorbis.data.Mapping"/>
</f></read>
		<couplingSteps public="1"><x path="Int"/></couplingSteps>
		<chan public="1"><x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.MappingChannel"/></x></chan>
		<submaps public="1"><x path="Int"/></submaps>
		<submapFloor public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></submapFloor>
		<submapResidue public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></submapResidue>
		<doFloor public="1" set="method" line="88"><f a="floors:i:n:target:finalY:step2Flag">
	<x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Floor"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<c path="Array"><x path="Int"/></c>
	<x path="haxe.ds.Vector"><x path="Bool"/></x>
	<x path="Void"/>
</f></doFloor>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.MappingChannel" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Mapping.hx" module="kha.audio2.ogg.vorbis.data.Mapping">
		<magnitude public="1"><x path="Int"/></magnitude>
		<angle public="1"><x path="Int"/></angle>
		<mux public="1"><x path="Int"/></mux>
		<new public="1" set="method" line="125"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Mode" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Mode.hx">
		<read public="1" set="method" line="15" static="1"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<c path="kha.audio2.ogg.vorbis.data.Mode"/>
</f></read>
		<blockflag public="1"><x path="Bool"/></blockflag>
		<mapping public="1"><x path="Int"/></mapping>
		<windowtype public="1"><x path="Int"/></windowtype>
		<transformtype public="1"><x path="Int"/></transformtype>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Page" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Page.hx">
		<flag public="1" set="null"><x path="Int"/></flag>
		<clone public="1" set="method" line="18"><f a=""><c path="kha.audio2.ogg.vorbis.data.Page"/></f></clone>
		<start public="1" set="method" line="25"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="Void"/>
</f></start>
		<startWithoutCapturePattern public="1" set="method" line="31"><f a="decodeState">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="Void"/>
</f></startWithoutCapturePattern>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.PageFlag" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Page.hx" module="kha.audio2.ogg.vorbis.data.Page">
		<CONTINUED_PACKET public="1" get="inline" set="null" line="57" static="1"><x path="Int"/></CONTINUED_PACKET>
		<FIRST_PAGE public="1" get="inline" set="null" line="58" static="1"><x path="Int"/></FIRST_PAGE>
		<LAST_PAGE public="1" get="inline" set="null" line="59" static="1"><x path="Int"/></LAST_PAGE>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.ProbedPage" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/ProbedPage.hx">
		<pageStart public="1"><x path="Int"/></pageStart>
		<pageEnd public="1"><x path="Int"/></pageEnd>
		<afterPreviousPageStart public="1"><x path="Int"/></afterPreviousPageStart>
		<firstDecodedSample public="1"><t path="Null"><x path="Int"/></t></firstDecodedSample>
		<lastDecodedSample public="1"><t path="Null"><x path="Int"/></t></lastDecodedSample>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.ReaderError" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/ReaderError.hx">
		<type public="1" set="null"><e path="kha.audio2.ogg.vorbis.data.ReaderErrorType"/></type>
		<message public="1" set="null"><c path="String"/></message>
		<posInfos public="1" set="null"><t path="haxe.PosInfos"/></posInfos>
		<new public="1" set="method" line="14"><f a="type:?message:?posInfos">
	<e path="kha.audio2.ogg.vorbis.data.ReaderErrorType"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.audio2.ogg.vorbis.data.ReaderErrorType" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/ReaderError.hx" module="kha.audio2.ogg.vorbis.data.ReaderError">
		<NEED_MORE_DATA/>
		<INVALID_API_MIXING/>
		<OUTOFMEM/>
		<FEATURE_NOT_SUPPORTED/>
		<TOO_MANY_CHANNELS/>
		<FILE_OPEN_FAILURE/>
		<SEEK_WITHOUT_LENGTH/>
		<UNEXPECTED_EOF/>
		<SEEK_INVALID/>
		<INVALID_SETUP/>
		<INVALID_STREAM/>
		<MISSING_CAPTURE_PATTERN/>
		<INVALID_STREAM_STRUCTURE_VERSION/>
		<CONTINUED_PACKET_FLAG_INVALID/>
		<INCORRECT_STREAM_SERIAL_NUMBER/>
		<INVALID_FIRST_PAGE/>
		<BAD_PACKET_TYPE/>
		<CANT_FIND_LAST_PAGE/>
		<SEEK_FAILED/>
		<OTHER/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.audio2.ogg.vorbis.data.Residue" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Residue.hx">
		<read public="1" set="method" line="24" static="1"><f a="decodeState:codebooks">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><c path="kha.audio2.ogg.vorbis.data.Codebook"/></x>
	<c path="kha.audio2.ogg.vorbis.data.Residue"/>
</f></read>
		<begin public="1" set="null"><x path="UInt"/></begin>
		<end public="1" set="null"><x path="UInt"/></end>
		<partSize public="1" set="null"><x path="UInt"/></partSize>
		<classifications public="1" set="null"><x path="Int"/></classifications>
		<classbook public="1" set="null"><x path="Int"/></classbook>
		<classdata public="1" set="null"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></classdata>
		<residueBooks public="1" set="null"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></residueBooks>
		<type public="1" set="null"><x path="Int"/></type>
		<decode public="1" set="method" line="83"><f a="decodeState:header:residueBuffers:ch:n:doNotDecode:channelBuffers">
	<c path="kha.audio2.ogg.vorbis.VorbisDecodeState"/>
	<c path="kha.audio2.ogg.vorbis.data.Header"/>
	<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Bool"/></x>
	<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x>
	<x path="Void"/>
</f></decode>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.audio2.ogg.vorbis.data.Setting" params="" file="Kha/Sources/kha/audio2/ogg/vorbis/data/Setting.hx">
		<MAX_CHANNELS public="1" get="inline" set="null" line="9" static="1"><x path="Int"/></MAX_CHANNELS>
		<PUSHDATA_CRC_COUNT public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></PUSHDATA_CRC_COUNT>
		<FAST_HUFFMAN_LENGTH public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></FAST_HUFFMAN_LENGTH>
		<FAST_HUFFMAN_TABLE_SIZE public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></FAST_HUFFMAN_TABLE_SIZE>
		<FAST_HUFFMAN_TABLE_MASK public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></FAST_HUFFMAN_TABLE_MASK>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
	</class>
	<class path="kha.graphics1.Graphics" params="" file="Kha/Sources/kha/graphics1/Graphics.hx" interface="1">
		<begin public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Begin the graphic operations.
	 * You MUST call this.</haxe_doc>
		</begin>
		<end public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Terminate all graphical operations and apply them.
	 * You MUST call this at the end.</haxe_doc>
		</end>
		<setPixel public="1" set="method">
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="kha.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the pixel color in a specific position.</haxe_doc>
		</setPixel>
		<haxe_doc><![CDATA[* Basic graphical interface.<br>
 * Represent old devices with only pixel pushing operations.]]></haxe_doc>
	</class>
	<class path="kha.graphics2.Graphics" params="" file="Kha/Sources/kha/graphics2/Graphics.hx">
		<begin public="1" set="method" line="10"><f a="?clear:?clearColor">
	<x path="Bool"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></begin>
		<end public="1" set="method" line="11"><f a=""><x path="Void"/></f></end>
		<clear public="1" set="method" line="16"><f a="?color">
	<x path="kha.Color"/>
	<x path="Void"/>
</f></clear>
		<drawImage public="1" set="method" line="17"><f a="img:x:y">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawImage>
		<drawSubImage public="1" set="method" line="20"><f a="img:x:y:sx:sy:sw:sh">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawSubImage>
		<drawScaledImage public="1" set="method" line="23"><f a="img:dx:dy:dw:dh">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawScaledImage>
		<drawScaledSubImage public="1" set="method" line="26"><f a="image:sx:sy:sw:sh:dx:dy:dw:dh">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawScaledSubImage>
		<drawRect public="1" set="method" line="27"><f a="x:y:width:height:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<fillRect public="1" set="method" line="28"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<drawString public="1" set="method" line="29"><f a="text:x:y">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawString>
		<drawLine public="1" set="method" line="30"><f a="x1:y1:x2:y2:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawLine>
		<drawVideo public="1" set="method" line="31"><f a="video:x:y:width:height">
	<c path="kha.Video"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawVideo>
		<fillTriangle public="1" set="method" line="32"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillTriangle>
		<color public="1" get="accessor" set="accessor"><x path="kha.Color"/></color>
		<font public="1" get="accessor" set="accessor"><c path="kha.Font"/></font>
		<get_color public="1" set="method" line="37"><f a=""><x path="kha.Color"/></f></get_color>
		<set_color public="1" set="method" line="41"><f a="color">
	<x path="kha.Color"/>
	<x path="kha.Color"/>
</f></set_color>
		<get_font public="1" set="method" line="45"><f a=""><c path="kha.Font"/></f></get_font>
		<set_font public="1" set="method" line="49"><f a="font">
	<c path="kha.Font"/>
	<c path="kha.Font"/>
</f></set_font>
		<transformation public="1" get="accessor" set="accessor"><c path="kha.math.Matrix3"/></transformation>
		<pushTransformation public="1" set="method" line="55"><f a="transformation">
	<c path="kha.math.Matrix3"/>
	<x path="Void"/>
</f></pushTransformation>
		<popTransformation public="1" set="method" line="60"><f a=""><c path="kha.math.Matrix3"/></f></popTransformation>
		<get_transformation public="1" set="method" line="66"><f a=""><c path="kha.math.Matrix3"/></f></get_transformation>
		<set_transformation public="1" set="method" line="70"><f a="transformation">
	<c path="kha.math.Matrix3"/>
	<c path="kha.math.Matrix3"/>
</f></set_transformation>
		<translation get="inline" set="null" line="75"><f a="tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></translation>
		<translate public="1" set="method" line="79"><f a="tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<pushTranslation public="1" set="method" line="83"><f a="tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pushTranslation>
		<rotation get="inline" set="null" line="87"><f a="angle:centerx:centery">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></rotation>
		<rotate public="1" set="method" line="91"><f a="angle:centerx:centery">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<pushRotation public="1" set="method" line="95"><f a="angle:centerx:centery">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pushRotation>
		<opacity public="1" get="accessor" set="accessor"><x path="Float"/></opacity>
		<pushOpacity public="1" set="method" line="101"><f a="opacity">
	<x path="Float"/>
	<x path="Void"/>
</f></pushOpacity>
		<popOpacity public="1" set="method" line="106"><f a=""><x path="Float"/></f></popOpacity>
		<get_opacity public="1" set="method" line="112"><f a=""><x path="Float"/></f></get_opacity>
		<set_opacity public="1" set="method" line="116"><f a="opacity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_opacity>
		<prog><c path="kha.graphics4.Program"/></prog>
		<program public="1" get="accessor" set="accessor"><c path="kha.graphics4.Program"/></program>
		<get_program set="method" line="128"><f a=""><c path="kha.graphics4.Program"/></f></get_program>
		<set_program set="method" line="132"><f a="program">
	<c path="kha.graphics4.Program"/>
	<c path="kha.graphics4.Program"/>
</f></set_program>
		<setBlendingMode public="1" set="method" line="139"><f a="source:destination">
	<e path="kha.graphics4.BlendingOperation"/>
	<e path="kha.graphics4.BlendingOperation"/>
	<x path="Void"/>
</f></setBlendingMode>
		<transformations><c path="Array"><c path="kha.math.Matrix3"/></c></transformations>
		<opacities><c path="Array"><x path="Float"/></c></opacities>
		<setTransformation set="method" line="158"><f a="transformation">
	<c path="kha.math.Matrix3"/>
	<x path="Void"/>
</f></setTransformation>
		<setOpacity set="method" line="162"><f a="opacity">
	<x path="Float"/>
	<x path="Void"/>
</f></setOpacity>
		<setProgram set="method" line="166"><f a="program">
	<c path="kha.graphics4.Program"/>
	<x path="Void"/>
</f></setProgram>
		<new public="1" set="method" line="146"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="kha.graphics2.Graphics1" params="" file="Kha/Sources/kha/graphics2/Graphics1.hx">
		<implements path="kha.graphics1.Graphics"/>
		<canvas><c path="kha.Canvas"/></canvas>
		<texture><c path="kha.Image"/></texture>
		<pixels><c path="haxe.io.Bytes"/></pixels>
		<begin public="1" set="method" line="17"><f a=""><x path="Void"/></f></begin>
		<end public="1" set="method" line="24"><f a=""><x path="Void"/></f></end>
		<setPixel public="1" set="method" line="31"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></setPixel>
		<new public="1" set="method" line="13"><f a="canvas">
	<c path="kha.Canvas"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.graphics4.BlendingOperation" params="" file="Kha/Sources/kha/graphics4/BlendingOperation.hx">
		<Undefined/>
		<BlendOne/>
		<BlendZero/>
		<SourceAlpha/>
		<DestinationAlpha/>
		<InverseSourceAlpha/>
		<InverseDestinationAlpha/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="kha.graphics4.CompareMode" params="" file="Kha/Sources/kha/graphics4/CompareMode.hx">
		<Always/>
		<Never/>
		<Equal/>
		<NotEqual/>
		<Less/>
		<LessEqual/>
		<Greater/>
		<GreaterEqual/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="kha.graphics4.ConstantLocation" params="" file="Kha/Sources/kha/graphics4/ConstantLocation.hx" interface="1"/>
	<class path="kha.graphics4.CubeMap" params="" file="Kha/Sources/kha/graphics4/CubeMap.hx" interface="1">
		<get_size public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_size>
		<size public="1" get="accessor" set="null"><x path="Int"/></size>
		<lock public="1" set="method"><f a=""><c path="haxe.io.Bytes"/></f></lock>
		<unlock public="1" set="method"><f a=""><x path="Void"/></f></unlock>
	</class>
	<enum path="kha.graphics4.CullMode" params="" file="Kha/Sources/kha/graphics4/CullMode.hx">
		<Clockwise/>
		<CounterClockwise/>
		<None/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="kha.graphics4.FragmentShader" params="" file="Kha/Backends/HTML5/kha/graphics4/FragmentShader.hx">
		<source public="1"><c path="String"/></source>
		<type public="1"><d/></type>
		<shader public="1"><d/></shader>
		<new public="1" set="method" line="8"><f a="source">
	<c path="kha.Blob"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.Graphics" params="" file="Kha/Sources/kha/graphics4/Graphics.hx" interface="1">
		<begin public="1" set="method"><f a=""><x path="Void"/></f></begin>
		<end public="1" set="method"><f a=""><x path="Void"/></f></end>
		<vsynced public="1" set="method"><f a=""><x path="Bool"/></f></vsynced>
		<refreshRate public="1" set="method"><f a=""><x path="Int"/></f></refreshRate>
		<clear public="1" set="method"><f a="?color:?depth:?stencil">
	<x path="kha.Color"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<setCullMode public="1" set="method"><f a="mode">
	<e path="kha.graphics4.CullMode"/>
	<x path="Void"/>
</f></setCullMode>
		<setDepthMode public="1" set="method"><f a="write:mode">
	<x path="Bool"/>
	<e path="kha.graphics4.CompareMode"/>
	<x path="Void"/>
</f></setDepthMode>
		<setBlendingMode public="1" set="method"><f a="source:destination">
	<e path="kha.graphics4.BlendingOperation"/>
	<e path="kha.graphics4.BlendingOperation"/>
	<x path="Void"/>
</f></setBlendingMode>
		<setStencilParameters public="1" set="method"><f a="compareMode:bothPass:depthFail:stencilFail:referenceValue:?readMask:?writeMask">
	<e path="kha.graphics4.CompareMode"/>
	<e path="kha.graphics4.StencilAction"/>
	<e path="kha.graphics4.StencilAction"/>
	<e path="kha.graphics4.StencilAction"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setStencilParameters>
		<setScissor public="1" set="method"><f a="rect">
	<c path="kha.Rectangle"/>
	<x path="Void"/>
</f></setScissor>
		<setVertexBuffer public="1" set="method"><f a="vertexBuffer">
	<c path="kha.graphics4.VertexBuffer"/>
	<x path="Void"/>
</f></setVertexBuffer>
		<setIndexBuffer public="1" set="method"><f a="indexBuffer">
	<c path="kha.graphics4.IndexBuffer"/>
	<x path="Void"/>
</f></setIndexBuffer>
		<setTexture public="1" set="method"><f a="unit:texture">
	<c path="kha.graphics4.TextureUnit"/>
	<c path="kha.Image"/>
	<x path="Void"/>
</f></setTexture>
		<setTextureParameters public="1" set="method"><f a="texunit:uAddressing:vAddressing:minificationFilter:magnificationFilter:mipmapFilter">
	<c path="kha.graphics4.TextureUnit"/>
	<e path="kha.graphics4.TextureAddressing"/>
	<e path="kha.graphics4.TextureAddressing"/>
	<e path="kha.graphics4.TextureFilter"/>
	<e path="kha.graphics4.TextureFilter"/>
	<e path="kha.graphics4.MipMapFilter"/>
	<x path="Void"/>
</f></setTextureParameters>
		<createCubeMap public="1" set="method"><f a="size:format:usage:?canRead">
	<x path="Int"/>
	<e path="kha.graphics4.TextureFormat"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Bool"/>
	<c path="kha.graphics4.CubeMap"/>
</f></createCubeMap>
		<renderTargetsInvertedY public="1" set="method"><f a=""><x path="Bool"/></f></renderTargetsInvertedY>
		<setProgram public="1" set="method"><f a="program">
	<c path="kha.graphics4.Program"/>
	<x path="Void"/>
</f></setProgram>
		<setBool public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setBool>
		<setInt public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setFloat public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setFloat2 public="1" set="method"><f a="location:value1:value2">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat2>
		<setFloat3 public="1" set="method"><f a="location:value1:value2:value3">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat3>
		<setFloat4 public="1" set="method"><f a="location:value1:value2:value3:value4">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat4>
		<setFloats public="1" set="method"><f a="location:floats">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setFloats>
		<setVector2 public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector2"/>
	<x path="Void"/>
</f></setVector2>
		<setVector3 public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector3"/>
	<x path="Void"/>
</f></setVector3>
		<setVector4 public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector4"/>
	<x path="Void"/>
</f></setVector4>
		<setMatrix public="1" set="method"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Matrix4"/>
	<x path="Void"/>
</f></setMatrix>
		<drawIndexedVertices public="1" set="method"><f a="?start:?count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawIndexedVertices>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
	</class>
	<class path="kha.graphics4.ImageShaderPainter" params="" file="Kha/Sources/kha/graphics4/Graphics2.hx" module="kha.graphics4.Graphics2">
		<bufferSize line="31" static="1"><x path="Int"/></bufferSize>
		<vertexSize line="32" static="1"><x path="Int"/></vertexSize>
		<projectionMatrix><c path="kha.math.Matrix4"/></projectionMatrix>
		<shaderProgram><c path="kha.graphics4.Program"/></shaderProgram>
		<structure><c path="kha.graphics4.VertexStructure"/></structure>
		<projectionLocation><c path="kha.graphics4.ConstantLocation"/></projectionLocation>
		<textureLocation><c path="kha.graphics4.TextureUnit"/></textureLocation>
		<bufferIndex><x path="Int"/></bufferIndex>
		<rectVertexBuffer><c path="kha.graphics4.VertexBuffer"/></rectVertexBuffer>
		<rectVertices><x path="haxe.io.Float32Array"/></rectVertices>
		<indexBuffer><c path="kha.graphics4.IndexBuffer"/></indexBuffer>
		<lastTexture><c path="kha.Image"/></lastTexture>
		<bilinear><x path="Bool"/></bilinear>
		<g><c path="kha.graphics4.Graphics"/></g>
		<myProgram><c path="kha.graphics4.Program"/></myProgram>
		<program public="1" get="accessor" set="accessor"><c path="kha.graphics4.Program"/></program>
		<sourceBlend public="1"><e path="kha.graphics4.BlendingOperation"/></sourceBlend>
		<destinationBlend public="1"><e path="kha.graphics4.BlendingOperation"/></destinationBlend>
		<get_program set="method" line="55"><f a=""><c path="kha.graphics4.Program"/></f></get_program>
		<set_program set="method" line="59"><f a="prog">
	<c path="kha.graphics4.Program"/>
	<c path="kha.graphics4.Program"/>
</f></set_program>
		<setProjection public="1" set="method" line="71"><f a="projectionMatrix">
	<c path="kha.math.Matrix4"/>
	<x path="Void"/>
</f></setProjection>
		<initShaders set="method" line="75"><f a=""><x path="Void"/></f></initShaders>
		<initBuffers set="method" line="91"><f a=""><x path="Void"/></f></initBuffers>
		<setRectVertices set="method" line="108"><f a="bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectVertices>
		<setRectTexCoords set="method" line="131"><f a="left:top:right:bottom">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectTexCoords>
		<setRectColor set="method" line="146"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectColor>
		<drawBuffer set="method" line="169"><f a=""><x path="Void"/></f></drawBuffer>
		<setBilinearFilter public="1" set="method" line="190"><f a="bilinear">
	<x path="Bool"/>
	<x path="Void"/>
</f></setBilinearFilter>
		<drawImage public="1" set="method" line="195"><f a="img:bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty:opacity:color">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></drawImage>
		<drawImage2 public="1" set="method" line="212"><f a="img:sx:sy:sw:sh:bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty:opacity:color">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></drawImage2>
		<drawImageScale public="1" set="method" line="229"><f a="img:sx:sy:sw:sh:left:top:right:bottom:opacity:color">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></drawImageScale>
		<end public="1" set="method" line="241"><f a=""><x path="Void"/></f></end>
		<new public="1" set="method" line="46"><f a="g4">
	<c path="kha.graphics4.Graphics"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.ColoredShaderPainter" params="" file="Kha/Sources/kha/graphics4/Graphics2.hx" module="kha.graphics4.Graphics2">
		<bufferSize line="253" static="1"><x path="Int"/></bufferSize>
		<triangleBufferSize line="259" static="1"><x path="Int"/></triangleBufferSize>
		<projectionMatrix><c path="kha.math.Matrix4"/></projectionMatrix>
		<shaderProgram><c path="kha.graphics4.Program"/></shaderProgram>
		<structure><c path="kha.graphics4.VertexStructure"/></structure>
		<projectionLocation><c path="kha.graphics4.ConstantLocation"/></projectionLocation>
		<bufferIndex><x path="Int"/></bufferIndex>
		<rectVertexBuffer><c path="kha.graphics4.VertexBuffer"/></rectVertexBuffer>
		<rectVertices><x path="haxe.io.Float32Array"/></rectVertices>
		<indexBuffer><c path="kha.graphics4.IndexBuffer"/></indexBuffer>
		<triangleBufferIndex><x path="Int"/></triangleBufferIndex>
		<triangleVertexBuffer><c path="kha.graphics4.VertexBuffer"/></triangleVertexBuffer>
		<triangleVertices><x path="haxe.io.Float32Array"/></triangleVertices>
		<triangleIndexBuffer><c path="kha.graphics4.IndexBuffer"/></triangleIndexBuffer>
		<g><c path="kha.graphics4.Graphics"/></g>
		<myProgram><c path="kha.graphics4.Program"/></myProgram>
		<program public="1" get="accessor" set="accessor"><c path="kha.graphics4.Program"/></program>
		<sourceBlend public="1"><e path="kha.graphics4.BlendingOperation"/></sourceBlend>
		<destinationBlend public="1"><e path="kha.graphics4.BlendingOperation"/></destinationBlend>
		<get_program set="method" line="281"><f a=""><c path="kha.graphics4.Program"/></f></get_program>
		<set_program set="method" line="285"><f a="prog">
	<c path="kha.graphics4.Program"/>
	<c path="kha.graphics4.Program"/>
</f></set_program>
		<setProjection public="1" set="method" line="295"><f a="projectionMatrix">
	<c path="kha.math.Matrix4"/>
	<x path="Void"/>
</f></setProjection>
		<initShaders set="method" line="299"><f a=""><x path="Void"/></f></initShaders>
		<initBuffers set="method" line="314"><f a=""><x path="Void"/></f></initBuffers>
		<setRectVertices public="1" set="method" line="343"><f a="bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectVertices>
		<setRectColors public="1" set="method" line="366"><f a="color">
	<x path="kha.Color"/>
	<x path="Void"/>
</f></setRectColors>
		<setTriVertices set="method" line="389"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTriVertices>
		<setTriColors set="method" line="404"><f a="color">
	<x path="kha.Color"/>
	<x path="Void"/>
</f></setTriColors>
		<drawBuffer set="method" line="422"><f a="trisDone">
	<x path="Bool"/>
	<x path="Void"/>
</f></drawBuffer>
		<drawTriBuffer set="method" line="442"><f a="rectsDone">
	<x path="Bool"/>
	<x path="Void"/>
</f></drawTriBuffer>
		<fillRect public="1" set="method" line="462"><f a="color:bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty">
	<x path="kha.Color"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<fillTriangle public="1" set="method" line="474"><f a="color:x1:y1:x2:y2:x3:y3">
	<x path="kha.Color"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillTriangle>
		<endTris public="1" set="method" line="482"><f a="rectsDone">
	<x path="Bool"/>
	<x path="Void"/>
</f></endTris>
		<endRects public="1" set="method" line="486"><f a="trisDone">
	<x path="Bool"/>
	<x path="Void"/>
</f></endRects>
		<end public="1" set="method" line="490"><f a=""><x path="Void"/></f></end>
		<new public="1" set="method" line="272"><f a="g4">
	<c path="kha.graphics4.Graphics"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.TextShaderPainter" params="" file="Kha/Sources/kha/graphics4/Graphics2.hx" module="kha.graphics4.Graphics2">
		<bufferSize line="505" static="1"><x path="Int"/></bufferSize>
		<projectionMatrix><c path="kha.math.Matrix4"/></projectionMatrix>
		<shaderProgram><c path="kha.graphics4.Program"/></shaderProgram>
		<structure><c path="kha.graphics4.VertexStructure"/></structure>
		<projectionLocation><c path="kha.graphics4.ConstantLocation"/></projectionLocation>
		<textureLocation><c path="kha.graphics4.TextureUnit"/></textureLocation>
		<bufferIndex><x path="Int"/></bufferIndex>
		<rectVertexBuffer><c path="kha.graphics4.VertexBuffer"/></rectVertexBuffer>
		<rectVertices><x path="haxe.io.Float32Array"/></rectVertices>
		<indexBuffer><c path="kha.graphics4.IndexBuffer"/></indexBuffer>
		<font><c path="kha.Kravur"/></font>
		<lastTexture><c path="kha.Image"/></lastTexture>
		<g><c path="kha.graphics4.Graphics"/></g>
		<myProgram><c path="kha.graphics4.Program"/></myProgram>
		<program public="1" get="accessor" set="accessor"><c path="kha.graphics4.Program"/></program>
		<sourceBlend public="1"><e path="kha.graphics4.BlendingOperation"/></sourceBlend>
		<destinationBlend public="1"><e path="kha.graphics4.BlendingOperation"/></destinationBlend>
		<get_program set="method" line="528"><f a=""><c path="kha.graphics4.Program"/></f></get_program>
		<set_program set="method" line="532"><f a="prog">
	<c path="kha.graphics4.Program"/>
	<c path="kha.graphics4.Program"/>
</f></set_program>
		<setProjection public="1" set="method" line="544"><f a="projectionMatrix">
	<c path="kha.math.Matrix4"/>
	<x path="Void"/>
</f></setProjection>
		<initShaders set="method" line="548"><f a=""><x path="Void"/></f></initShaders>
		<initBuffers set="method" line="564"><f a=""><x path="Void"/></f></initBuffers>
		<setRectVertices set="method" line="581"><f a="bottomleftx:bottomlefty:topleftx:toplefty:toprightx:toprighty:bottomrightx:bottomrighty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectVertices>
		<setRectTexCoords set="method" line="604"><f a="left:top:right:bottom">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRectTexCoords>
		<setRectColors set="method" line="619"><f a="color">
	<x path="kha.Color"/>
	<x path="Void"/>
</f></setRectColors>
		<drawBuffer set="method" line="642"><f a=""><x path="Void"/></f></drawBuffer>
		<setFont public="1" set="method" line="662"><f a="font">
	<c path="kha.Font"/>
	<x path="Void"/>
</f></setFont>
		<text><c path="String"/></text>
		<startString set="method" line="673"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></startString>
		<charCodeAt set="method" line="682"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></charCodeAt>
		<stringLength set="method" line="691"><f a=""><x path="Int"/></f></stringLength>
		<endString set="method" line="700"><f a=""><x path="Void"/></f></endString>
		<drawString public="1" set="method" line="704"><f a="text:color:x:y:transformation">
	<c path="String"/>
	<x path="kha.Color"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
	<x path="Void"/>
</f></drawString>
		<end public="1" set="method" line="730"><f a=""><x path="Void"/></f></end>
		<new public="1" set="method" line="519"><f a="g4">
	<c path="kha.graphics4.Graphics"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.Graphics2" params="" file="Kha/Sources/kha/graphics4/Graphics2.hx">
		<extends path="kha.graphics2.Graphics"/>
		<upperPowerOfTwo set="method" line="772" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></upperPowerOfTwo>
		<myColor><x path="kha.Color"/></myColor>
		<myFont><c path="kha.Font"/></myFont>
		<projectionMatrix><c path="kha.math.Matrix4"/></projectionMatrix>
		<imagePainter public="1"><c path="kha.graphics4.ImageShaderPainter"/></imagePainter>
		<coloredPainter><c path="kha.graphics4.ColoredShaderPainter"/></coloredPainter>
		<textPainter><c path="kha.graphics4.TextShaderPainter"/></textPainter>
		<videoProgram><c path="kha.graphics4.Program"/></videoProgram>
		<canvas><c path="kha.Canvas"/></canvas>
		<g><c path="kha.graphics4.Graphics"/></g>
		<setProjection set="method" line="783"><f a=""><x path="Void"/></f></setProjection>
		<drawImage public="1" set="method" line="804" override="1"><f a="img:x:y">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawImage>
		<drawScaledSubImage public="1" set="method" line="814" override="1"><f a="img:sx:sy:sw:sh:dx:dy:dw:dh">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawScaledSubImage>
		<get_color public="1" set="method" line="824" override="1"><f a=""><x path="kha.Color"/></f></get_color>
		<set_color public="1" set="method" line="828" override="1"><f a="color">
	<x path="kha.Color"/>
	<x path="kha.Color"/>
</f></set_color>
		<drawRect public="1" set="method" line="832" override="1"><f a="x:y:width:height:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<fillRect public="1" set="method" line="859" override="1"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<drawString public="1" set="method" line="870" override="1"><f a="text:x:y">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawString>
		<get_font public="1" set="method" line="877" override="1"><f a=""><c path="kha.Font"/></f></get_font>
		<set_font public="1" set="method" line="881" override="1"><f a="font">
	<c path="kha.Font"/>
	<c path="kha.Font"/>
</f></set_font>
		<drawLine public="1" set="method" line="886" override="1"><f a="x1:y1:x2:y2:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawLine>
		<fillTriangle public="1" set="method" line="908" override="1"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillTriangle>
		<setBilinearFiltering public="1" set="method" line="918"><f a="bilinear">
	<x path="Bool"/>
	<x path="Void"/>
</f></setBilinearFiltering>
		<setProgram set="method" line="922" override="1"><f a="program">
	<c path="kha.graphics4.Program"/>
	<x path="Void"/>
</f></setProgram>
		<setBlendingMode public="1" set="method" line="930" override="1"><f a="source:destination">
	<e path="kha.graphics4.BlendingOperation"/>
	<e path="kha.graphics4.BlendingOperation"/>
	<x path="Void"/>
</f></setBlendingMode>
		<begin public="1" set="method" line="940" override="1"><f a="?clear:?clearColor">
	<x path="Bool"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></begin>
		<clear public="1" set="method" line="946" override="1"><f a="?color">
	<x path="kha.Color"/>
	<x path="Void"/>
</f></clear>
		<endDrawing set="method" line="950"><f a=""><x path="Void"/></f></endDrawing>
		<end public="1" set="method" line="956" override="1"><f a=""><x path="Void"/></f></end>
		<drawVideoInternal set="method" line="961"><f a="video:x:y:width:height">
	<c path="kha.Video"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawVideoInternal>
		<drawVideo public="1" set="method" line="965" override="1"><f a="video:x:y:width:height">
	<c path="kha.Video"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawVideo>
		<new public="1" set="method" line="747"><f a="canvas">
	<c path="kha.Canvas"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.IndexBuffer" params="" file="Kha/Backends/HTML5/kha/graphics4/IndexBuffer.hx">
		<buffer><d/></buffer>
		<data><c path="Array"><x path="Int"/></c></data>
		<mySize><x path="Int"/></mySize>
		<usage><e path="kha.graphics4.Usage"/></usage>
		<lock public="1" set="method" line="19"><f a=""><c path="Array"><x path="Int"/></c></f></lock>
		<unlock public="1" set="method" line="23"><f a=""><x path="Void"/></f></unlock>
		<set public="1" set="method" line="28"><f a=""><x path="Void"/></f></set>
		<count public="1" set="method" line="32"><f a=""><x path="Int"/></f></count>
		<new public="1" set="method" line="11"><f a="indexCount:usage:?canRead">
	<x path="Int"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.graphics4.MipMapFilter" params="" file="Kha/Sources/kha/graphics4/MipMapFilter.hx">
		<NoMipFilter/>
		<PointMipFilter/>
		<LinearMipFilter/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.graphics4.Program" params="" file="Kha/Backends/HTML5/kha/graphics4/Program.hx">
		<program><d/></program>
		<vertexShader><c path="kha.graphics4.VertexShader"/></vertexShader>
		<fragmentShader><c path="kha.graphics4.FragmentShader"/></fragmentShader>
		<textures><c path="Array"><c path="String"/></c></textures>
		<textureValues><c path="Array"><d/></c></textureValues>
		<setVertexShader public="1" set="method" line="21"><f a="vertexShader">
	<c path="kha.graphics4.VertexShader"/>
	<x path="Void"/>
</f></setVertexShader>
		<setFragmentShader public="1" set="method" line="25"><f a="fragmentShader">
	<c path="kha.graphics4.FragmentShader"/>
	<x path="Void"/>
</f></setFragmentShader>
		<link public="1" set="method" line="29"><f a="structure">
	<c path="kha.graphics4.VertexStructure"/>
	<x path="Void"/>
</f></link>
		<set public="1" set="method" line="47"><f a=""><x path="Void"/></f></set>
		<compileShader set="method" line="52"><f a="shader">
	<d/>
	<x path="Void"/>
</f></compileShader>
		<getConstantLocation public="1" set="method" line="63"><f a="name">
	<c path="String"/>
	<c path="kha.graphics4.ConstantLocation"/>
</f></getConstantLocation>
		<getTextureUnit public="1" set="method" line="67"><f a="name">
	<c path="String"/>
	<c path="kha.graphics4.TextureUnit"/>
</f></getTextureUnit>
		<findTexture set="method" line="78"><f a="name">
	<c path="String"/>
	<x path="Int"/>
</f></findTexture>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.graphics4.StencilAction" params="" file="Kha/Sources/kha/graphics4/StencilAction.hx">
		<Keep/>
		<Zero/>
		<Replace/>
		<Increment/>
		<IncrementWrap/>
		<Decrement/>
		<DecrementWrap/>
		<Invert/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="kha.graphics4.TexDir" params="" file="Kha/Sources/kha/graphics4/TexDir.hx">
		<U/>
		<V/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="kha.graphics4.TextureAddressing" params="" file="Kha/Sources/kha/graphics4/TextureAddressing.hx">
		<Repeat/>
		<Mirror/>
		<Clamp/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="kha.graphics4.TextureFilter" params="" file="Kha/Sources/kha/graphics4/TextureFilter.hx">
		<PointFilter/>
		<LinearFilter/>
		<AnisotropicFilter/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="kha.graphics4.TextureFormat" params="" file="Kha/Sources/kha/graphics4/TextureFormat.hx">
		<RGBA32/>
		<L8/>
		<RGBA128/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.graphics4.TextureUnit" params="" file="Kha/Sources/kha/graphics4/TextureUnit.hx" interface="1"/>
	<enum path="kha.graphics4.Usage" params="" file="Kha/Sources/kha/graphics4/Usage.hx">
		<StaticUsage/>
		<DynamicUsage/>
		<ReadableUsage/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.graphics4.VertexBuffer" params="" file="Kha/Backends/HTML5/kha/graphics4/VertexBuffer.hx">
		<buffer><d/></buffer>
		<data><x path="haxe.io.Float32Array"/></data>
		<mySize><x path="Int"/></mySize>
		<myStride><x path="Int"/></myStride>
		<sizes><c path="Array"><x path="Int"/></c></sizes>
		<offsets><c path="Array"><x path="Int"/></c></offsets>
		<usage><e path="kha.graphics4.Usage"/></usage>
		<lock public="1" set="method" line="72"><f a="?start:?count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.io.Float32Array"/>
</f></lock>
		<unlock public="1" set="method" line="76"><f a=""><x path="Void"/></f></unlock>
		<stride public="1" set="method" line="81"><f a=""><x path="Int"/></f></stride>
		<count public="1" set="method" line="85"><f a=""><x path="Int"/></f></count>
		<set public="1" set="method" line="89"><f a=""><x path="Void"/></f></set>
		<new public="1" set="method" line="17"><f a="vertexCount:structure:usage:?canRead">
	<x path="Int"/>
	<c path="kha.graphics4.VertexStructure"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kha.graphics4.VertexData" params="" file="Kha/Sources/kha/graphics4/VertexData.hx">
		<Float1/>
		<Float2/>
		<Float3/>
		<Float4/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kha.graphics4.VertexElement" params="" file="Kha/Sources/kha/graphics4/VertexElement.hx">
		<name public="1"><c path="String"/></name>
		<data public="1"><e path="kha.graphics4.VertexData"/></data>
		<new public="1" set="method" line="7"><f a="name:data">
	<c path="String"/>
	<e path="kha.graphics4.VertexData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.VertexShader" params="" file="Kha/Backends/HTML5/kha/graphics4/VertexShader.hx">
		<source public="1"><c path="String"/></source>
		<type public="1"><d/></type>
		<shader public="1"><d/></shader>
		<new public="1" set="method" line="10"><f a="source">
	<c path="kha.Blob"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.graphics4.VertexStructure" params="" file="Kha/Sources/kha/graphics4/VertexStructure.hx">
		<elements public="1"><c path="Array"><c path="kha.graphics4.VertexElement"/></c></elements>
		<add public="1" set="method" line="10"><f a="name:data">
	<c path="String"/>
	<e path="kha.graphics4.VertexData"/>
	<x path="Void"/>
</f></add>
		<size public="1" set="method" line="14"><f a=""><x path="Int"/></f></size>
		<get public="1" set="method" line="18"><f a="index">
	<x path="Int"/>
	<c path="kha.graphics4.VertexElement"/>
</f></get>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.input.Gamepad" params="" file="Kha/Sources/kha/input/Gamepad.hx">
		<get public="1" set="method" line="6" static="1"><f a="?num">
	<x path="Int"/>
	<c path="kha.input.Gamepad"/>
</f></get>
		<instance static="1"><c path="kha.input.Gamepad"/></instance>
		<notify public="1" set="method" line="11"><f a="axisListener:buttonListener">
	<f a=":">
		<x path="Int"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<x path="Int"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></notify>
		<remove public="1" set="method" line="16"><f a="axisListener:buttonListener">
	<f a=":">
		<x path="Int"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<x path="Int"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></remove>
		<axisListeners><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></axisListeners>
		<buttonListeners><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></buttonListeners>
		<sendAxisEvent set="method" line="31"><f a="axis:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></sendAxisEvent>
		<sendButtonEvent set="method" line="37"><f a="button:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></sendButtonEvent>
		<new set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>kha.Starter</e></m>
			<m n=":expose"/>
		</meta>
	</class>
	<class path="kha.input.Keyboard" params="" file="Kha/Sources/kha/input/Keyboard.hx">
		<get public="1" set="method" line="13" static="1"><f a="?num">
	<x path="Int"/>
	<c path="kha.input.Keyboard"/>
</f></get>
		<instance static="1"><c path="kha.input.Keyboard"/></instance>
		<notify public="1" set="method" line="18"><f a="downListener:upListener">
	<f a=":">
		<e path="kha.Key"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<e path="kha.Key"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></notify>
		<remove public="1" set="method" line="23"><f a="downListener:upListener">
	<f a=":">
		<e path="kha.Key"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<e path="kha.Key"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></remove>
		<downListeners><c path="Array"><f a=":">
	<e path="kha.Key"/>
	<c path="String"/>
	<x path="Void"/>
</f></c></downListeners>
		<upListeners><c path="Array"><f a=":">
	<e path="kha.Key"/>
	<c path="String"/>
	<x path="Void"/>
</f></c></upListeners>
		<sendDownEvent set="method" line="39">
			<f a="key:char">
				<e path="kha.Key"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n="input"/></meta>
		</sendDownEvent>
		<sendUpEvent set="method" line="49">
			<f a="key:char">
				<e path="kha.Key"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n="input"/></meta>
		</sendUpEvent>
		<new set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>kha.Starter</e></m>
			<m n=":expose"/>
		</meta>
	</class>
	<class path="kha.input.Mouse" params="" file="Kha/Sources/kha/input/Mouse.hx">
		<get public="1" set="method" line="6" static="1"><f a="?num">
	<x path="Int"/>
	<c path="kha.input.Mouse"/>
</f></get>
		<instance static="1"><c path="kha.input.Mouse"/></instance>
		<notify public="1" set="method" line="11"><f a="downListener:upListener:moveListener:wheelListener">
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></notify>
		<remove public="1" set="method" line="18"><f a="downListener:upListener:moveListener:wheelListener">
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="::">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a=":">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></remove>
		<downListeners><c path="Array"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></downListeners>
		<upListeners><c path="Array"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></upListeners>
		<moveListeners><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></moveListeners>
		<wheelListeners><c path="Array"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c></wheelListeners>
		<sendDownEvent set="method" line="39"><f a="button:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sendDownEvent>
		<sendUpEvent set="method" line="45"><f a="button:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sendUpEvent>
		<sendMoveEvent set="method" line="51"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sendMoveEvent>
		<sendWheelEvent set="method" line="57"><f a="delta">
	<x path="Int"/>
	<x path="Void"/>
</f></sendWheelEvent>
		<new set="method" line="31"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>kha.Starter</e></m>
			<m n=":expose"/>
		</meta>
	</class>
	<class path="kha.js.AudioElementAudio" params="" file="Kha/Backends/HTML5/kha/js/AudioElementAudio.hx">
		<_compile public="1" set="method" line="5" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_compile>
		<playSound public="1" set="method" line="7" static="1"><f a="sound">
	<c path="kha.js.Sound"/>
	<t path="kha.audio1.SoundChannel"/>
</f></playSound>
		<playMusic public="1" set="method" line="11" static="1"><f a="music:?loop">
	<c path="kha.js.Music"/>
	<x path="Bool"/>
	<t path="kha.audio1.MusicChannel"/>
</f></playMusic>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.CanvasGraphics" params="" file="Kha/Backends/HTML5/kha/js/CanvasGraphics.hx">
		<extends path="kha.graphics2.Graphics"/>
		<instance static="1"><c path="kha.js.CanvasGraphics"/></instance>
		<stringWidth public="1" set="method" line="30" static="1"><f a="font:text">
	<c path="kha.Font"/>
	<c path="String"/>
	<x path="Float"/>
</f></stringWidth>
		<canvas><d/></canvas>
		<webfont><c path="kha.js.Font"/></webfont>
		<width><x path="Int"/></width>
		<height><x path="Int"/></height>
		<myColor><x path="kha.Color"/></myColor>
		<begin public="1" set="method" line="38" override="1"><f a="?clear:?clearColor">
	<x path="Bool"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></begin>
		<clear public="1" set="method" line="42" override="1"><f a="?color">
	<x path="kha.Color"/>
	<x path="Void"/>
</f></clear>
		<end public="1" set="method" line="50" override="1"><f a=""><x path="Void"/></f></end>
		<drawImage public="1" set="method" line="59" override="1"><f a="img:x:y">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawImage>
		<drawScaledSubImage public="1" set="method" line="65" override="1"><f a="image:sx:sy:sw:sh:dx:dy:dw:dh">
	<c path="kha.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawScaledSubImage>
		<set_color public="1" set="method" line="94" override="1"><f a="color">
	<x path="kha.Color"/>
	<x path="kha.Color"/>
</f></set_color>
		<get_color public="1" set="method" line="101" override="1"><f a=""><x path="kha.Color"/></f></get_color>
		<drawRect public="1" set="method" line="105" override="1"><f a="x:y:width:height:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<fillRect public="1" set="method" line="114" override="1"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<drawString public="1" set="method" line="120" override="1"><f a="text:x:y">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawString>
		<set_font public="1" set="method" line="140" override="1"><f a="font">
	<c path="kha.Font"/>
	<c path="kha.Font"/>
</f></set_font>
		<get_font public="1" set="method" line="146" override="1"><f a=""><c path="kha.Font"/></f></get_font>
		<drawLine public="1" set="method" line="150" override="1"><f a="x1:y1:x2:y2:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawLine>
		<fillTriangle public="1" set="method" line="161" override="1"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillTriangle>
		<drawVideo public="1" set="method" line="168" override="1"><f a="video:x:y:width:height">
	<c path="kha.Video"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawVideo>
		<setTransformation public="1" set="method" line="172" override="1"><f a="transformation">
	<c path="kha.math.Matrix3"/>
	<x path="Void"/>
</f></setTransformation>
		<new public="1" set="method" line="19"><f a="canvas:width:height">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.URLParser" params="" file="Kha/Backends/HTML5/kha/js/EnvironmentVariables.hx" module="kha.js.EnvironmentVariables">
		<parse public="1" set="method" line="61" static="1"><f a="url">
	<c path="String"/>
	<c path="kha.js.URLParser"/>
</f></parse>
		<url public="1"><c path="String"/></url>
		<source public="1"><c path="String"/></source>
		<protocol public="1"><c path="String"/></protocol>
		<authority public="1"><c path="String"/></authority>
		<userInfo public="1"><c path="String"/></userInfo>
		<user public="1"><c path="String"/></user>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<port public="1"><c path="String"/></port>
		<relative public="1"><c path="String"/></relative>
		<path public="1"><c path="String"/></path>
		<directory public="1"><c path="String"/></directory>
		<file public="1"><c path="String"/></file>
		<query public="1"><c path="String"/></query>
		<anchor public="1"><c path="String"/></anchor>
		<_parts><c path="Array"><c path="String"/></c></_parts>
		<toString public="1" set="method" line="51"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.EnvironmentVariables" params="" file="Kha/Backends/HTML5/kha/js/EnvironmentVariables.hx">
		<extends path="kha.EnvironmentVariables"/>
		<getVariable public="1" set="method" line="74" override="1"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getVariable>
		<new public="1" set="method" line="70"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.Font" params="" file="Kha/Backends/HTML5/kha/js/Font.hx">
		<implements path="kha.Font"/>
		<myName public="1"><c path="String"/></myName>
		<myStyle public="1"><c path="kha.FontStyle"/></myStyle>
		<mySize public="1"><x path="Float"/></mySize>
		<kravur public="1"><c path="kha.Kravur"/></kravur>
		<images><x path="Map">
	<x path="Int"/>
	<c path="js.html.ImageElement"/>
</x></images>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<style public="1" get="accessor" set="null"><c path="kha.FontStyle"/></style>
		<size public="1" get="accessor" set="null"><x path="Float"/></size>
		<get_name public="1" set="method" line="28"><f a=""><c path="String"/></f></get_name>
		<get_style public="1" set="method" line="32"><f a=""><c path="kha.FontStyle"/></f></get_style>
		<get_size public="1" set="method" line="36"><f a=""><x path="Float"/></f></get_size>
		<getHeight public="1" set="method" line="40"><f a=""><x path="Float"/></f></getHeight>
		<charWidth public="1" set="method" line="44"><f a="ch">
	<c path="String"/>
	<x path="Float"/>
</f></charWidth>
		<charsWidth public="1" set="method" line="48"><f a="ch:offset:length">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></charsWidth>
		<stringWidth public="1" set="method" line="52"><f a="str">
	<c path="String"/>
	<x path="Float"/>
</f></stringWidth>
		<getBaselinePosition public="1" set="method" line="56"><f a=""><x path="Float"/></f></getBaselinePosition>
		<getImage public="1" set="method" line="60"><f a="color">
	<x path="kha.Color"/>
	<c path="js.html.ImageElement"/>
</f></getImage>
		<new public="1" set="method" line="16"><f a="name:style:size">
	<c path="String"/>
	<c path="kha.FontStyle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.Loader" params="" file="Kha/Backends/HTML5/kha/js/Loader.hx">
		<extends path="kha.Loader"/>
		<loadMusic public="1" set="method" line="21" override="1"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Music"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadMusic>
		<loadSound public="1" set="method" line="26" override="1"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadSound>
		<loadImage public="1" set="method" line="31" override="1"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Image"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadImage>
		<loadVideo public="1" set="method" line="40" override="1"><f a="desc:done">
	<d/>
	<f a="">
		<c path="kha.Video"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadVideo>
		<loadBlob public="1" set="method" line="44" override="1">
			<f a="desc:done">
				<d/>
				<f a="">
					<c path="kha.Blob"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</loadBlob>
		<loadFont public="1" set="method" line="72" override="1"><f a="name:style:size">
	<c path="String"/>
	<c path="kha.FontStyle"/>
	<x path="Float"/>
	<c path="kha.Font"/>
</f></loadFont>
		<loadURL public="1" set="method" line="77" override="1"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></loadURL>
		<setNormalCursor public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></setNormalCursor>
		<setHandCursor public="1" set="method" line="90" override="1"><f a=""><x path="Void"/></f></setHandCursor>
		<quit public="1" set="method" line="95" override="1"><f a=""><x path="Void"/></f></quit>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.Mouse" params="" file="Kha/Backends/HTML5/kha/js/Mouse.hx">
		<extends path="kha.Mouse"/>
		<SystemCursor public="1" line="9" static="1"><c path="String"/></SystemCursor>
		<UpdateSystemCursor public="1" set="method" line="12" static="1"><f a=""><x path="Void"/></f></UpdateSystemCursor>
		<hideSystemCursor set="method" line="21" override="1"><f a=""><x path="Void"/></f></hideSystemCursor>
		<showSystemCursor set="method" line="24" override="1"><f a=""><x path="Void"/></f></showSystemCursor>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.Music" params="" file="Kha/Backends/HTML5/kha/js/Music.hx">
		<extends path="kha.Music"/>
		<extensions line="13" static="1"><c path="Array"><c path="String"/></c></extensions>
		<loading line="14" static="1"><c path="List"><c path="kha.js.Music"/></c></loading>
		<extractName set="method" line="96" static="1"><f a="filename">
	<c path="String"/>
	<c path="String"/>
</f></extractName>
		<concatExtensions set="method" line="100" static="1"><f a=""><c path="String"/></f></concatExtensions>
		<done><f a="">
	<c path="kha.Music"/>
	<x path="Void"/>
</f></done>
		<element public="1"><c path="js.html.AudioElement"/></element>
		<play public="1" set="method" line="40" override="1"><f a="?loop">
	<x path="Bool"/>
	<x path="Void"/>
</f></play>
		<pause public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="55" override="1"><f a=""><x path="Void"/></f></stop>
		<getCurrentPos public="1" set="method" line="66" override="1"><f a=""><x path="Int"/></f></getCurrentPos>
		<getLength public="1" set="method" line="70" override="1"><f a=""><x path="Int"/></f></getLength>
		<errorListener set="method" line="79"><f a="eventInfo">
	<c path="js.html.ErrorEvent"/>
	<x path="Void"/>
</f></errorListener>
		<canPlayThroughListener set="method" line="106"><f a="eventInfo">
	<c path="js.html.Event"/>
	<x path="Void"/>
</f></canPlayThroughListener>
		<finishAsset set="method" line="110"><f a=""><x path="Void"/></f></finishAsset>
		<new public="1" set="method" line="18"><f a="filename:done">
	<c path="String"/>
	<f a="">
		<c path="kha.Music"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.SoundChannel" params="" file="Kha/Backends/HTML5/kha/js/Sound.hx" module="kha.js.Sound">
		<extends path="kha.SoundChannel"/>
		<element><d/></element>
		<play public="1" set="method" line="20" override="1"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method" line="25" override="1"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></stop>
		<getCurrentPos public="1" set="method" line="45" override="1"><f a=""><x path="Int"/></f></getCurrentPos>
		<getLength public="1" set="method" line="49" override="1"><f a=""><x path="Int"/></f></getLength>
		<new public="1" set="method" line="15"><f a="element">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.Sound" params="" file="Kha/Backends/HTML5/kha/js/Sound.hx">
		<extends path="kha.Sound"/>
		<extensions line="60" static="1"><c path="Array"><c path="String"/></c></extensions>
		<loading line="61" static="1"><c path="List"><c path="kha.js.Sound"/></c></loading>
		<extractName set="method" line="114" static="1"><f a="filename">
	<c path="String"/>
	<c path="String"/>
</f></extractName>
		<concatExtensions set="method" line="118" static="1"><f a=""><c path="String"/></f></concatExtensions>
		<done><f a="">
	<c path="kha.Sound"/>
	<x path="Void"/>
</f></done>
		<element public="1"><c path="js.html.AudioElement"/></element>
		<play public="1" set="method" line="87" override="1"><f a=""><c path="kha.SoundChannel"/></f></play>
		<errorListener set="method" line="97"><f a="eventInfo">
	<c path="js.html.ErrorEvent"/>
	<x path="Void"/>
</f></errorListener>
		<canPlayThroughListener set="method" line="124"><f a="eventInfo">
	<c path="js.html.Event"/>
	<x path="Void"/>
</f></canPlayThroughListener>
		<finishAsset set="method" line="128"><f a=""><x path="Void"/></f></finishAsset>
		<new public="1" set="method" line="65"><f a="filename:done">
	<c path="String"/>
	<f a="">
		<c path="kha.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.Video" params="" file="Kha/Backends/HTML5/kha/js/Video.hx">
		<extends path="kha.Video"/>
		<extensions line="12" static="1"><c path="Array"><c path="String"/></c></extensions>
		<loading line="13" static="1"><c path="List"><c path="kha.js.Video"/></c></loading>
		<element public="1"><c path="js.html.VideoElement"/></element>
		<done><f a="">
	<c path="kha.Video"/>
	<x path="Void"/>
</f></done>
		<texture public="1"><c path="kha.Image"/></texture>
		<play public="1" set="method" line="43" override="1"><f a="?loop">
	<x path="Bool"/>
	<x path="Void"/>
</f></play>
		<pause public="1" set="method" line="52" override="1"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="60" override="1"><f a=""><x path="Void"/></f></stop>
		<getCurrentPos public="1" set="method" line="69" override="1"><f a=""><x path="Int"/></f></getCurrentPos>
		<getLength public="1" set="method" line="73" override="1"><f a=""><x path="Int"/></f></getLength>
		<errorListener set="method" line="81"><f a="eventInfo">
	<c path="js.html.ErrorEvent"/>
	<x path="Void"/>
</f></errorListener>
		<canPlayThroughListener set="method" line="106"><f a="eventInfo">
	<c path="js.html.Event"/>
	<x path="Void"/>
</f></canPlayThroughListener>
		<finishAsset set="method" line="110"><f a=""><x path="Void"/></f></finishAsset>
		<new public="1" set="method" line="18"><f a="filename:done">
	<c path="String"/>
	<f a="">
		<c path="kha.Video"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.WebAudioMusic" params="" file="Kha/Backends/HTML5/kha/js/WebAudioMusic.hx">
		<extends path="kha.Music"/>
		<new public="1" set="method" line="8">
			<f a="filename:done">
				<c path="String"/>
				<f a="">
					<c path="kha.Music"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.WebAudioChannel" params="" file="Kha/Backends/HTML5/kha/js/WebAudioSound.hx" module="kha.js.WebAudioSound">
		<extends path="kha.SoundChannel"/>
		<buffer><d/></buffer>
		<startTime><x path="Float"/></startTime>
		<offset><x path="Float"/></offset>
		<source><d/></source>
		<play public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method" line="36" override="1"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="43" override="1"><f a=""><x path="Void"/></f></stop>
		<getCurrentPos public="1" set="method" line="51" override="1"><f a=""><x path="Int"/></f></getCurrentPos>
		<getLength public="1" set="method" line="56" override="1"><f a=""><x path="Int"/></f></getLength>
		<new public="1" set="method" line="18"><f a="buffer">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.WebAudioSound" params="" file="Kha/Backends/HTML5/kha/js/WebAudioSound.hx">
		<extends path="kha.Sound"/>
		<initialized line="64" static="1"><x path="Bool"/></initialized>
		<playsOgg line="65" static="1"><x path="Bool"/></playsOgg>
		<init set="method" line="67" static="1"><f a=""><x path="Void"/></f></init>
		<done><f a="">
	<c path="kha.Sound"/>
	<x path="Void"/>
</f></done>
		<buffer><c path="js.html.audio.AudioBuffer"/></buffer>
		<play public="1" set="method" line="114" override="1"><f a=""><c path="kha.SoundChannel"/></f></play>
		<new public="1" set="method" line="74">
			<f a="filename:done">
				<c path="String"/>
				<f a="">
					<c path="kha.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.graphics4.ConstantLocation" params="" file="Kha/Backends/HTML5/kha/js/graphics4/ConstantLocation.hx">
		<implements path="kha.graphics4.ConstantLocation"/>
		<value public="1"><d/></value>
		<new public="1" set="method" line="6"><f a="value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.graphics4.Graphics" params="" file="Kha/Backends/HTML5/kha/js/graphics4/Graphics.hx">
		<implements path="kha.graphics4.Graphics"/>
		<framebuffer><d/></framebuffer>
		<indicesCount><x path="Int"/></indicesCount>
		<renderTarget><c path="kha.WebGLImage"/></renderTarget>
		<begin public="1" set="method" line="43"><f a=""><x path="Void"/></f></begin>
		<end public="1" set="method" line="54"><f a=""><x path="Void"/></f></end>
		<flush public="1" set="method" line="58"><f a=""><x path="Void"/></f></flush>
		<vsynced public="1" set="method" line="62"><f a=""><x path="Bool"/></f></vsynced>
		<refreshRate public="1" set="method" line="66"><f a=""><x path="Int"/></f></refreshRate>
		<clear public="1" set="method" line="70"><f a="?color:?depth:?stencil">
	<x path="kha.Color"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<setDepthMode public="1" set="method" line="86"><f a="write:mode">
	<x path="Bool"/>
	<e path="kha.graphics4.CompareMode"/>
	<x path="Void"/>
</f></setDepthMode>
		<getBlendFunc set="method" line="116"><f a="op">
	<e path="kha.graphics4.BlendingOperation"/>
	<x path="Int"/>
</f></getBlendFunc>
		<setBlendingMode public="1" set="method" line="133"><f a="source:destination">
	<e path="kha.graphics4.BlendingOperation"/>
	<e path="kha.graphics4.BlendingOperation"/>
	<x path="Void"/>
</f></setBlendingMode>
		<createVertexBuffer public="1" set="method" line="143"><f a="vertexCount:structure:usage:?canRead">
	<x path="Int"/>
	<c path="kha.graphics4.VertexStructure"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Bool"/>
	<c path="kha.graphics4.VertexBuffer"/>
</f></createVertexBuffer>
		<setVertexBuffer public="1" set="method" line="147"><f a="vertexBuffer">
	<c path="kha.graphics4.VertexBuffer"/>
	<x path="Void"/>
</f></setVertexBuffer>
		<createIndexBuffer public="1" set="method" line="151"><f a="indexCount:usage:?canRead">
	<x path="Int"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Bool"/>
	<c path="kha.graphics4.IndexBuffer"/>
</f></createIndexBuffer>
		<setIndexBuffer public="1" set="method" line="155"><f a="indexBuffer">
	<c path="kha.graphics4.IndexBuffer"/>
	<x path="Void"/>
</f></setIndexBuffer>
		<createCubeMap public="1" set="method" line="168"><f a="size:format:usage:?canRead">
	<x path="Int"/>
	<e path="kha.graphics4.TextureFormat"/>
	<e path="kha.graphics4.Usage"/>
	<x path="Bool"/>
	<c path="kha.graphics4.CubeMap"/>
</f></createCubeMap>
		<setTexture public="1" set="method" line="172"><f a="stage:texture">
	<c path="kha.graphics4.TextureUnit"/>
	<c path="kha.Image"/>
	<x path="Void"/>
</f></setTexture>
		<setTextureParameters public="1" set="method" line="182"><f a="texunit:uAddressing:vAddressing:minificationFilter:magnificationFilter:mipmapFilter">
	<c path="kha.graphics4.TextureUnit"/>
	<e path="kha.graphics4.TextureAddressing"/>
	<e path="kha.graphics4.TextureAddressing"/>
	<e path="kha.graphics4.TextureFilter"/>
	<e path="kha.graphics4.TextureFilter"/>
	<e path="kha.graphics4.MipMapFilter"/>
	<x path="Void"/>
</f></setTextureParameters>
		<setCullMode public="1" set="method" line="232"><f a="mode">
	<e path="kha.graphics4.CullMode"/>
	<x path="Void"/>
</f></setCullMode>
		<setProgram public="1" set="method" line="245"><f a="program">
	<c path="kha.graphics4.Program"/>
	<x path="Void"/>
</f></setProgram>
		<setBool public="1" set="method" line="249"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setBool>
		<setInt public="1" set="method" line="253"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setFloat public="1" set="method" line="257"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setFloat2 public="1" set="method" line="261"><f a="location:value1:value2">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat2>
		<setFloat3 public="1" set="method" line="265"><f a="location:value1:value2:value3">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat3>
		<setFloat4 public="1" set="method" line="269"><f a="location:value1:value2:value3:value4">
	<c path="kha.graphics4.ConstantLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat4>
		<setFloats public="1" set="method" line="273"><f a="location:values">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setFloats>
		<setVector2 public="1" set="method" line="277"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector2"/>
	<x path="Void"/>
</f></setVector2>
		<setVector3 public="1" set="method" line="281"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector3"/>
	<x path="Void"/>
</f></setVector3>
		<setVector4 public="1" set="method" line="285"><f a="location:value">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Vector4"/>
	<x path="Void"/>
</f></setVector4>
		<matrixCache><x path="haxe.ds.Vector"><x path="Float"/></x></matrixCache>
		<setMatrix public="1" get="inline" set="null" line="291"><f a="location:matrix">
	<c path="kha.graphics4.ConstantLocation"/>
	<c path="kha.math.Matrix4"/>
	<x path="Void"/>
</f></setMatrix>
		<drawIndexedVertices public="1" set="method" line="299"><f a="?start:?count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawIndexedVertices>
		<setStencilParameters public="1" set="method" line="303"><f a="compareMode:bothPass:depthFail:stencilFail:referenceValue:?readMask:?writeMask">
	<e path="kha.graphics4.CompareMode"/>
	<e path="kha.graphics4.StencilAction"/>
	<e path="kha.graphics4.StencilAction"/>
	<e path="kha.graphics4.StencilAction"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setStencilParameters>
		<setScissor public="1" set="method" line="307"><f a="rect">
	<c path="kha.Rectangle"/>
	<x path="Void"/>
</f></setScissor>
		<renderTargetsInvertedY public="1" set="method" line="311"><f a=""><x path="Bool"/></f></renderTargetsInvertedY>
		<new public="1" set="method" line="34"><f a="webgl:?renderTarget">
	<x path="Bool"/>
	<c path="kha.WebGLImage"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.graphics4.Graphics2" params="" file="Kha/Backends/HTML5/kha/js/graphics4/Graphics2.hx">
		<extends path="kha.graphics4.Graphics2"/>
		<drawVideoInternal public="1" set="method" line="10" override="1"><f a="video:x:y:width:height">
	<c path="kha.Video"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawVideoInternal>
		<begin public="1" set="method" line="15" override="1"><f a="?clear:?clearColor">
	<x path="Bool"/>
	<x path="kha.Color"/>
	<x path="Void"/>
</f></begin>
		<new public="1" set="method" line="6"><f a="canvas">
	<c path="kha.Canvas"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.js.graphics4.TextureUnit" params="" file="Kha/Backends/HTML5/kha/js/graphics4/TextureUnit.hx">
		<implements path="kha.graphics4.TextureUnit"/>
		<value public="1"><x path="Int"/></value>
		<new public="1" set="method" line="6"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.loader.Room" params="" file="Kha/Sources/kha/loader/Room.hx">
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of the group.</haxe_doc>
		</name>
		<assets public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* The group of asset objects.</haxe_doc>
		</assets>
		<parent public="1">
			<c path="kha.loader.Room"/>
			<haxe_doc>* The parent group.</haxe_doc>
		</parent>
		<new public="1" set="method" line="25">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new group.
	 *
	 * @param name		The group name.</haxe_doc>
		</new>
		<haxe_doc>* A group of resources that can be loaded.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.math.Matrix3" params="" file="Kha/Sources/kha/math/Matrix3.hx">
		<width get="inline" set="null" line="4" static="1"><x path="Int"/></width>
		<height get="inline" set="null" line="5" static="1"><x path="Int"/></height>
		<translation public="1" get="inline" set="null" line="32" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></translation>
		<empty public="1" get="inline" set="null" line="40" static="1"><f a=""><c path="kha.math.Matrix3"/></f></empty>
		<identity public="1" get="inline" set="null" line="48" static="1"><f a=""><c path="kha.math.Matrix3"/></f></identity>
		<scale public="1" get="inline" set="null" line="56" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></scale>
		<rotation public="1" set="method" line="64" static="1"><f a="alpha">
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></rotation>
		<_00 public="1"><x path="Float"/></_00>
		<_10 public="1"><x path="Float"/></_10>
		<_20 public="1"><x path="Float"/></_20>
		<_01 public="1"><x path="Float"/></_01>
		<_11 public="1"><x path="Float"/></_11>
		<_21 public="1"><x path="Float"/></_21>
		<_02 public="1"><x path="Float"/></_02>
		<_12 public="1"><x path="Float"/></_12>
		<_22 public="1"><x path="Float"/></_22>
		<add public="1" get="inline" set="null" line="72"><f a="m">
	<c path="kha.math.Matrix3"/>
	<c path="kha.math.Matrix3"/>
</f></add>
		<sub public="1" get="inline" set="null" line="80"><f a="m">
	<c path="kha.math.Matrix3"/>
	<c path="kha.math.Matrix3"/>
</f></sub>
		<mult public="1" get="inline" set="null" line="88"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Matrix3"/>
</f></mult>
		<transpose public="1" get="inline" set="null" line="96"><f a=""><c path="kha.math.Matrix3"/></f></transpose>
		<trace public="1" get="inline" set="null" line="104"><f a=""><x path="Float"/></f></trace>
		<multmat public="1" get="inline" set="null" line="108"><f a="m">
	<c path="kha.math.Matrix3"/>
	<c path="kha.math.Matrix3"/>
</f></multmat>
		<multvec public="1" get="inline" set="null" line="116"><f a="value">
	<c path="kha.math.Vector2"/>
	<c path="kha.math.Vector2"/>
</f></multvec>
		<new public="1" get="inline" set="null" line="11"><f a="_00:_10:_20:_01:_11:_21:_02:_12:_22">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.math.Matrix4" params="" file="Kha/Sources/kha/math/Matrix4.hx">
		<width get="inline" set="null" line="4" static="1"><x path="Int"/></width>
		<height get="inline" set="null" line="5" static="1"><x path="Int"/></height>
		<translation public="1" get="inline" set="null" line="22" static="1"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></translation>
		<empty public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="kha.math.Matrix4"/></f></empty>
		<identity public="1" get="inline" set="null" line="40" static="1"><f a=""><c path="kha.math.Matrix4"/></f></identity>
		<scale public="1" get="inline" set="null" line="49" static="1"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></scale>
		<rotationX public="1" get="inline" set="null" line="58" static="1"><f a="alpha">
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></rotationX>
		<rotationY public="1" get="inline" set="null" line="69" static="1"><f a="alpha">
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></rotationY>
		<rotationZ public="1" get="inline" set="null" line="80" static="1"><f a="alpha">
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></rotationZ>
		<rotation public="1" get="inline" set="null" line="91" static="1"><f a="yaw:pitch:roll">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></rotation>
		<orthogonalProjection public="1" set="method" line="107" static="1"><f a="left:right:bottom:top:zn:zf">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></orthogonalProjection>
		<perspectiveProjection public="1" set="method" line="119" static="1"><f a="fovY:aspect:zn:zf">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></perspectiveProjection>
		<lookAt public="1" set="method" line="130" static="1"><f a="eye:at:up">
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Matrix4"/>
</f></lookAt>
		<_00 public="1"><x path="Float"/></_00>
		<_10 public="1"><x path="Float"/></_10>
		<_20 public="1"><x path="Float"/></_20>
		<_30 public="1"><x path="Float"/></_30>
		<_01 public="1"><x path="Float"/></_01>
		<_11 public="1"><x path="Float"/></_11>
		<_21 public="1"><x path="Float"/></_21>
		<_31 public="1"><x path="Float"/></_31>
		<_02 public="1"><x path="Float"/></_02>
		<_12 public="1"><x path="Float"/></_12>
		<_22 public="1"><x path="Float"/></_22>
		<_32 public="1"><x path="Float"/></_32>
		<_03 public="1"><x path="Float"/></_03>
		<_13 public="1"><x path="Float"/></_13>
		<_23 public="1"><x path="Float"/></_23>
		<_33 public="1"><x path="Float"/></_33>
		<add public="1" set="method" line="144"><f a="m">
	<c path="kha.math.Matrix4"/>
	<c path="kha.math.Matrix4"/>
</f></add>
		<sub public="1" set="method" line="153"><f a="m">
	<c path="kha.math.Matrix4"/>
	<c path="kha.math.Matrix4"/>
</f></sub>
		<mult public="1" set="method" line="162"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Matrix4"/>
</f></mult>
		<transpose public="1" set="method" line="171"><f a=""><c path="kha.math.Matrix4"/></f></transpose>
		<transpose3x3 public="1" set="method" line="180"><f a=""><c path="kha.math.Matrix4"/></f></transpose3x3>
		<trace public="1" set="method" line="189"><f a=""><x path="Float"/></f></trace>
		<multmat public="1" get="inline" set="null" line="193"><f a="m">
	<c path="kha.math.Matrix4"/>
	<c path="kha.math.Matrix4"/>
</f></multmat>
		<multvec public="1" get="inline" set="null" line="202"><f a="value">
	<c path="kha.math.Vector4"/>
	<c path="kha.math.Vector4"/>
</f></multvec>
		<determinant public="1" get="inline" set="null" line="211"><f a=""><x path="Float"/></f></determinant>
		<new public="1" get="inline" set="null" line="12"><f a="_00:_10:_20:_30:_01:_11:_21:_31:_02:_12:_22:_32:_03:_13:_23:_33">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.math.Vector2" params="" file="Kha/Sources/kha/math/Vector2.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<length public="1" get="accessor" set="accessor"><x path="Float"/></length>
		<get_length set="method" line="13"><f a=""><x path="Float"/></f></get_length>
		<set_length set="method" line="17"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<add public="1" set="method" line="25"><f a="vec">
	<c path="kha.math.Vector2"/>
	<c path="kha.math.Vector2"/>
</f></add>
		<sub public="1" set="method" line="29"><f a="vec">
	<c path="kha.math.Vector2"/>
	<c path="kha.math.Vector2"/>
</f></sub>
		<mult public="1" set="method" line="33"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Vector2"/>
</f></mult>
		<div public="1" set="method" line="37"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Vector2"/>
</f></div>
		<dot public="1" set="method" line="41"><f a="v">
	<c path="kha.math.Vector2"/>
	<x path="Float"/>
</f></dot>
		<normalize public="1" set="method" line="45"><f a=""><x path="Void"/></f></normalize>
		<new public="1" get="inline" set="null" line="4"><f a="?x:?y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.math.Vector3" params="" file="Kha/Sources/kha/math/Vector3.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<length public="1" get="accessor" set="accessor"><x path="Float"/></length>
		<get_length set="method" line="15"><f a=""><x path="Float"/></f></get_length>
		<set_length set="method" line="19"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<add public="1" set="method" line="28"><f a="vec">
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Vector3"/>
</f></add>
		<sub public="1" set="method" line="32"><f a="vec">
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Vector3"/>
</f></sub>
		<mult public="1" set="method" line="36"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Vector3"/>
</f></mult>
		<dot public="1" set="method" line="40"><f a="v">
	<c path="kha.math.Vector3"/>
	<x path="Float"/>
</f></dot>
		<cross public="1" set="method" line="44"><f a="v">
	<c path="kha.math.Vector3"/>
	<c path="kha.math.Vector3"/>
</f></cross>
		<normalize public="1" set="method" line="51"><f a=""><x path="Void"/></f></normalize>
		<new public="1" set="method" line="4"><f a="?x:?y:?z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.math.Vector4" params="" file="Kha/Sources/kha/math/Vector4.hx">
		<values><c path="Array"><x path="Float"/></c></values>
		<get public="1" set="method" line="14"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<set public="1" set="method" line="18"><f a="index:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<z public="1" get="accessor" set="accessor"><x path="Float"/></z>
		<w public="1" get="accessor" set="accessor"><x path="Float"/></w>
		<length public="1" get="accessor" set="accessor"><x path="Float"/></length>
		<get_x public="1" set="method" line="28"><f a=""><x path="Float"/></f></get_x>
		<set_x public="1" set="method" line="32"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_y public="1" set="method" line="36"><f a=""><x path="Float"/></f></get_y>
		<set_y public="1" set="method" line="40"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_z public="1" set="method" line="44"><f a=""><x path="Float"/></f></get_z>
		<set_z public="1" set="method" line="48"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<get_w public="1" set="method" line="52"><f a=""><x path="Float"/></f></get_w>
		<set_w public="1" set="method" line="56"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_w>
		<get_length set="method" line="60"><f a=""><x path="Float"/></f></get_length>
		<set_length set="method" line="64"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<add public="1" set="method" line="73"><f a="vec">
	<c path="kha.math.Vector4"/>
	<c path="kha.math.Vector4"/>
</f></add>
		<sub public="1" set="method" line="77"><f a="vec">
	<c path="kha.math.Vector4"/>
	<c path="kha.math.Vector4"/>
</f></sub>
		<mult public="1" set="method" line="81"><f a="value">
	<x path="Float"/>
	<c path="kha.math.Vector4"/>
</f></mult>
		<new public="1" set="method" line="6"><f a="?x:?y:?z:?w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kha.networking.Controller" params="" file="Kha/Sources/kha/networking/Controller.hx" interface="1">
		<_id public="1" set="method"><f a=""><x path="Int"/></f></_id>
		<_receive public="1" set="method"><f a="offset:bytes">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></_receive>
		<meta><m n=":autoBuild"><e>kha.networking.ControllerBuilder.build()</e></m></meta>
	</class>
	<class path="spiller.util.interfaces.ISpiDestroyable" params="" file="Libs/spiller/util/interfaces/ISpiDestroyable.hx" interface="1">
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Call this method to destroy the object and all it's content.</haxe_doc>
		</destroy>
		<haxe_doc><![CDATA[* Generic inferface for a destroyable object.
 * 
 * v1.0 Initial version<br>
 * <br>
 * @version 1.0 - 18/04/2015
 * @author ratalaika / ratalaikaGames]]></haxe_doc>
	</class>
	<class path="spiller.SpiBasic" params="" file="Libs/spiller/SpiBasic.hx">
		<implements path="spiller.util.interfaces.ISpiDestroyable"/>
		<ACTIVECOUNT public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Number of active SpiBasics in the game.</haxe_doc>
		</ACTIVECOUNT>
		<VISIBLECOUNT public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Number of visible SpiBasics in the game.</haxe_doc>
		</VISIBLECOUNT>
		<ID public="1">
			<x path="Int"/>
			<haxe_doc>* IDs seem like they could be pretty useful, huh?
	 * They're not actually used for anything yet though.</haxe_doc>
		</ID>
		<exists public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>update():Void</code> and <code>draw():Void</code> are automatically called by SpiState/SpiGroup.]]></haxe_doc>
		</exists>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>update():Void</code> is automatically called by SpiState/SpiGroup.]]></haxe_doc>
		</active>
		<visible public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>draw():Void</code> is automatically called by SpiState/SpiGroup.]]></haxe_doc>
		</visible>
		<alive public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Useful state for many game objects - "dead" (!alive) vs alive.
	 * <code>kill():Void</code> and <code>revive():Void</code> both flip this switch (along with exists, but you can override that).]]></haxe_doc>
		</alive>
		<cameras public="1">
			<c path="Array"><c path="spiller.SpiCamera"/></c>
			<haxe_doc><![CDATA[* An array of camera objects that this object will use during <code>draw():Void</code>.
	 * This value will initialize itself during the first draw to automatically
	 * point at the main camera list out in <code>SpiG</code> unless you already set it.
	 * You can also change it afterward too, very flexible!]]></haxe_doc>
		</cameras>
		<ignoreDrawDebug public="1">
			<x path="Bool"/>
			<haxe_doc>* Setting this to true will prevent the object from appearing
	 * when the visual debug mode in the debugger overlay is toggled on.</haxe_doc>
		</ignoreDrawDebug>
		<autoClear public="1">
			<x path="Bool"/>
			<haxe_doc>* If the Tweener should clear on removal. For Entities, this is when they are
	 * removed from a World, and for World this is when the active World is switched.</haxe_doc>
		</autoClear>
		<_tween>
			<c path="spiller.plugin.tweens.SpiTween"/>
			<haxe_doc>* The SpiTween reference.</haxe_doc>
		</_tween>
		<destroy public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Override this function to null out variables or manually call
	 * <code>destroy():Void</code> on class members if necessary.
	 * Don't forget to call <code>super.destroy():Void</code>!]]></haxe_doc>
		</destroy>
		<preUpdate public="1" set="method" line="104">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Pre-update is called right before <code>update():Void</code> on each object in the game loop.]]></haxe_doc>
		</preUpdate>
		<update public="1" set="method" line="113">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this function to update your class's position and appearance.
	 * This is where most of your game rules and behavioral code will go.</haxe_doc>
		</update>
		<postUpdate public="1" set="method" line="121">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Post-update is called right after <code>update():Void</code> on each object in the game loop.]]></haxe_doc>
		</postUpdate>
		<draw public="1" set="method" line="130">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Override this function to control how the object is drawn.
	 * Overriding <code>draw():Void</code> is rarely necessary, but can be very useful.]]></haxe_doc>
		</draw>
		<drawDebug public="1" set="method" line="150">
			<f a="?Camera">
				<c path="spiller.SpiCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this function to draw custom "debug mode" graphics to the
	 * specified camera while the debugger's visual mode is toggled on.
	 * 
	 * @param	Camera	Which camera to draw the debug visuals to.</haxe_doc>
		</drawDebug>
		<kill public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Handy function for "killing" game objects.
	 * Default behavior is to flag them as nonexistent AND dead.
	 * However, if you want the "corpse" to remain in the game,
	 * like to animate an effect or whatever, you should override this,
	 * setting only alive to false, and leaving exists true.</haxe_doc>
		</kill>
		<revive public="1" set="method" line="172">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Handy function for bringing game objects "back to life". Just sets alive and exists back to true.
	 * In practice, this function is most often called by <code>SpiObject.reset():Void</code>.]]></haxe_doc>
		</revive>
		<toString public="1" set="method" line="181">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name.  Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<addTween public="1" set="method" line="197">
			<f a="t:start">
				<c path="spiller.plugin.tweens.SpiTween"/>
				<x path="Bool"/>
				<c path="spiller.plugin.tweens.SpiTween"/>
			</f>
			<haxe_doc>* Add a new SpiTween instance to this object.
	 * 
	 * @param t			The SpiTween instance.
	 * @param start		True if it should start.
	 * @return			The t instance.</haxe_doc>
		</addTween>
		<removeTween public="1" set="method" line="224">
			<f a="t:?destroy">
				<c path="spiller.plugin.tweens.SpiTween"/>
				<x path="Bool"/>
				<c path="spiller.plugin.tweens.SpiTween"/>
			</f>
			<haxe_doc>* Remove a new SpiTween instance to this object.
	 * 
	 * @param t			The SpiTween instance.
	 * @param destroy	True if it should be destroyed.
	 * @return			The t instance.</haxe_doc>
		</removeTween>
		<clearTweens public="1" set="method" line="251">
			<f a="?destroy">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Clear all the game tweens.
	 * 
	 * @param destroy		True if they should be destroyed.</haxe_doc>
		</clearTweens>
		<updateTweens public="1" set="method" line="266">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update the SpiBasic tweens.</haxe_doc>
		</updateTweens>
		<hasTween public="1" set="method" line="288">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Return true if the SpiBasic has a tween.
	 * 
	 * @return		True if the SpiBasic has a tween.</haxe_doc>
		</hasTween>
		<new public="1" set="method" line="75">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiate the basic spiller object.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is a useful "generic" spiller object.
 * Both <code>SpiObject</code> and <code>SpiGroup</code> extend this class,
 * as do the plugins.  Has no size, position or graphical data.
 * 
 * v1.0 Initial version
 * 
 * @version 1.0 - 27/03/2013
 * @author ratalaika / ratalaikaGames
 * @author Ka Wing Chin]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.SpiCamera" params="" file="Libs/spiller/SpiCamera.hx">
		<extends path="spiller.SpiBasic"/>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* The camera class is used to display the game's visuals in the Flash player.<br>
 * By default one camera is created automatically, that is the same size as the Flash player.<br>
 * You can add more cameras or even replace the main camera using utilities in <code>SpiG</code>.<br>
 * <br>
 * v1.0 Initial version
 * 
 * @version 1.0 - 17/07/2013
 * @author ratalaika / ratalaikaGames
 * @author Ka Wing Chin]]></haxe_doc>
	</class>
	<class path="spiller.SpiG" params="" file="Libs/spiller/SpiG.hx">
		<elapsed public="1" static="1">
			<x path="Float"/>
			<haxe_doc>* Represents the amount of time in seconds that passed since last frame.</haxe_doc>
		</elapsed>
		<visualDebug public="1" static="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to show visual debug displays or not.
	 * Default = false.</haxe_doc>
		</visualDebug>
		<cameras public="1" static="1">
			<c path="Array"><c path="spiller.SpiCamera"/></c>
			<haxe_doc><![CDATA[* An array of <code>SpiCamera</code> objects that are used to draw stuff.
	 * By default spiller creates one camera the size of the screen.]]></haxe_doc>
		</cameras>
		<displayList public="1" static="1">
			<c path="Array"><c path="spiller.SpiCamera"/></c>
			<haxe_doc>* Internal, keeps track of all the cameras that would have been added
	 * to the stage in Flash.</haxe_doc>
		</displayList>
		<camera public="1" static="1">
			<c path="spiller.SpiCamera"/>
			<haxe_doc>* By default this just refers to the first entry in the cameras array
	 * declared above, but you can do what you like with it.</haxe_doc>
		</camera>
		<activeCamera static="1">
			<c path="spiller.SpiCamera"/>
			<haxe_doc>* The camera currently being drawn.</haxe_doc>
		</activeCamera>
		<log public="1" set="method" line="471" static="1">
			<f a="?tag:?data:?showThreadName">
				<c path="String"/>
				<a><toString set="null"><f a=""><c path="String"/></f></toString></a>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Log data to the debugger.
	 * 
	 * @param tag					The tag you want to show in the console or cat log.
	 * @param data					Anything you want to log to the console.
	 * @param showThreadName		If the log prints the Thread name or not.</haxe_doc>
		</log>
		<getActiveCamera public="1" set="method" line="1835" static="1">
			<f a=""><c path="spiller.SpiCamera"/></f>
			<haxe_doc>* Read-only: gets the current SpiCamera.</haxe_doc>
		</getActiveCamera>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>spiller</e></m>
		</meta>
	</class>
	<class path="spiller.util.interfaces.ISpiPoolable" params="" file="Libs/spiller/util/interfaces/ISpiPoolable.hx" interface="1">
		<extends path="spiller.util.interfaces.ISpiDestroyable"/>
		<put public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Put the object on a pool.</haxe_doc>
		</put>
		<haxe_doc><![CDATA[* Generic interface for poolable objects.
 * 
 * v1.0 Initial version<br>
 * <br>
 * @version 1.0 - 18/04/2015
 * @author ratalaika / ratalaikaGames]]></haxe_doc>
	</class>
	<class path="spiller.util.SpiPool" params="T" file="Libs/spiller/util/SpiPool.hx">
		<_pool>
			<c path="Array"><c path="spiller.util.SpiPool.T"/></c>
			<haxe_doc>* Internal, stores the pooled objects.</haxe_doc>
		</_pool>
		<dispose public="1" set="method" line="43">
			<f a="obj">
				<c path="spiller.util.SpiPool.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Put an object back in the pool.
	 * 
	 * @param Object	The object to pool.</haxe_doc>
		</dispose>
		<remove public="1" set="method" line="53">
			<f a="obj">
				<c path="spiller.util.SpiPool.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove an object from the pool.
	 * 
	 * @param Object	The object to remove.</haxe_doc>
		</remove>
		<getNew public="1" set="method" line="64">
			<f a=""><c path="spiller.util.SpiPool.T"/></f>
			<haxe_doc>* Gets an object from the pool. If the pool is empty, returns
	 * a new object.
	 * 
	 * @return	A new object.</haxe_doc>
		</getNew>
		<create set="method" line="79">
			<f a=""><c path="spiller.util.SpiPool.T"/></f>
			<haxe_doc>* Instantiates a new object.
	 * 
	 * @return A new object.</haxe_doc>
		</create>
		<get public="1" set="method" line="89">
			<f a="index">
				<x path="Int"/>
				<c path="spiller.util.SpiPool.T"/>
			</f>
			<haxe_doc><![CDATA[* Get a specific element from the pool array.<br>
	 * Use this only in really specific situations.]]></haxe_doc>
		</get>
		<size public="1" set="method" line="97">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the total amount of elements in the pool.</haxe_doc>
		</size>
		<new public="1" set="method" line="28">
			<f a="?StartSize">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * 
	 * @param StartSize		How many objects to initially create. Optional.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A very basic object pool. Used by <code>SpiQuadTree</code> and<br>
 * <code>SpiList</code> to avoid costly instantiations every frame.<br>
 * <br>
 * @param <T>	The type of object to store in this pool.<br>
 * <br>
 * v1.0 Initial version<br>
 * 
 * @version 1.0 - 25/04/2013
 * @author ratalaika / ratalaikaGames
 * @author Thomas Weston]]></haxe_doc>
	</class>
	<class path="spiller.math.SpiPointPool" params="" file="Libs/spiller/math/SpiPoint.hx" module="spiller.math.SpiPoint">
		<extends path="spiller.util.SpiPool"><c path="spiller.math.SpiPoint"/></extends>
		<create public="1" set="method" line="607" override="1"><f a=""><c path="spiller.math.SpiPoint"/></f></create>
		<new public="1" set="method" line="604"><f a="?StartSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>spiller.math.SpiPoint.new</e></m>
		</meta>
	</class>
	<class path="spiller.math.SpiPoint" params="" file="Libs/spiller/math/SpiPoint.hx">
		<implements path="spiller.util.interfaces.ISpiPoolable"/>
		<TO_RADIANS public="1" line="25" static="1">
			<x path="Float"/>
			<haxe_doc>* Constant to convert degree angles into radial angles.</haxe_doc>
		</TO_RADIANS>
		<TO_DEGREES public="1" line="29" static="1">
			<x path="Float"/>
			<haxe_doc>* Constant to convert radial angles into degree angles.</haxe_doc>
		</TO_DEGREES>
		<_pool line="33" static="1">
			<c path="spiller.math.SpiPointPool"/>
			<haxe_doc>* The pool.</haxe_doc>
		</_pool>
		<get public="1" set="method" line="43" static="1">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Recycle or create a new SpiPoint. 
	 * Be sure to put() them back into the pool after you're done with them!
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @return	This point.</haxe_doc>
		</get>
		<weak public="1" set="method" line="58" static="1">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Recycle or create a new SpiPoint which will automatically be released 
	 * to the pool when passed into a spiller function.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @return	This point.</haxe_doc>
		</weak>
		<poolStatus public="1" set="method" line="594" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Return the pool status.</haxe_doc>
		</poolStatus>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X coordinate of the point.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y coordinate of the point.</haxe_doc>
		</y>
		<_weak>
			<x path="Bool"/>
			<haxe_doc>* If the point is a weak reference.</haxe_doc>
		</_weak>
		<_inPool>
			<x path="Bool"/>
			<haxe_doc>* If the point is on the pool.</haxe_doc>
		</_inPool>
		<put public="1" set="method" line="97">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this SpiPoint to the recycling pool.</haxe_doc>
		</put>
		<putWeak public="1" set="method" line="109">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this SpiPoint to the recycling pool if it's a weak reference (allocated via weak()).</haxe_doc>
		</putWeak>
		<make public="1" set="method" line="122">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Instantiate a new point object.
	 * 
	 * @param X The X-coordinate of the point in space.
	 * @param Y The Y-coordinate of the point in space.</haxe_doc>
		</make>
		<copyFrom public="1" set="method" line="136">
			<f a="point">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified point.
	 * 
	 * @param Point Any <code>SpiPoint</code>.
	 * 
	 * @return A reference to itself.]]></haxe_doc>
		</copyFrom>
		<copyTo public="1" set="method" line="152">
			<f a="point">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this point to the specified point.
	 * 
	 * @param Point Any <code>SpiPoint</code>.
	 * 
	 * @return A reference to the altered point parameter.]]></haxe_doc>
		</copyTo>
		<copyFromFlash public="1" set="method" line="170">
			<f a="FlashPoint">
				<c path="kha.math.Vector2"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified libgdx vector.
	 * 
	 * @param Point Any <code>Point</code>.
	 * 
	 * @return A reference to itself.]]></haxe_doc>
		</copyFromFlash>
		<copyToFlash public="1" set="method" line="184">
			<f a="FlashPoint">
				<c path="kha.math.Vector2"/>
				<c path="kha.math.Vector2"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this point to the specified libgdx vector.
	 * 
	 * @param Point Any <code>Point</code>.
	 * 
	 * @return A reference to the altered point parameter.]]></haxe_doc>
		</copyToFlash>
		<add public="1" set="method" line="198">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method add to its coordinates the X and Y values passed.
	 * 
	 * @param x The X coordinate.
	 * @param y The Y coordinate.
	 * @return The vector itself.</haxe_doc>
		</add>
		<addPoint public="1" set="method" line="211">
			<f a="other">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method add to its coordinates the vector passed coordinates.
	 * 
	 * @param other The vector to add with.
	 * @return The vector itself.</haxe_doc>
		</addPoint>
		<subtract public="1" set="method" line="226">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method sub to its coordinates the X and Y values passed.
	 * 
	 * @param x The X coordinate.
	 * @param y The Y coordinate.
	 * @return The vector itself.</haxe_doc>
		</subtract>
		<subtractPoint public="1" set="method" line="239">
			<f a="other">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method sub to its coordinates the vector passed coordinates.
	 * 
	 * @param other The vector to sub with.
	 * @return The vector itself.</haxe_doc>
		</subtractPoint>
		<mul public="1" set="method" line="253">
			<f a="scalar">
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method multiply a vector for a scalar value.
	 * 
	 * @param scalar The scalar number we want to multiply with.
	 * @return The vector itself.</haxe_doc>
		</mul>
		<length public="1" set="method" line="265">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* This method calculates the length of the vector.
	 * 
	 * @return The length of the vector.</haxe_doc>
		</length>
		<lengthSquared public="1" set="method" line="275">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* This method calculates the length of the vector squared.
	 * 
	 * @return The length of the vector.</haxe_doc>
		</lengthSquared>
		<normalize public="1" set="method" line="285">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* This method normalizes the vector to unit length.
	 * 
	 * @return The vector itself.</haxe_doc>
		</normalize>
		<normalizeWithScale public="1" set="method" line="301">
			<f a="scale">
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method normalizes the vector to unit length.
	 * 
	 * @param length The length to normalize with.
	 * @return The vector itself.</haxe_doc>
		</normalizeWithScale>
		<angle public="1" set="method" line="318">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* This method calculates the angle between the X and Y coordinates.
	 * 
	 * @return The angle between X and Y.</haxe_doc>
		</angle>
		<anglePoint public="1" set="method" line="331">
			<f a="other">
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This method calculates the angle between the vector and the given vector.
	 * 
	 * @return The angle between X and Y.</haxe_doc>
		</anglePoint>
		<rotateX public="1" set="method" line="344">
			<f a="angle">
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method rotates the vector X coordinate by a given amount of angles.
	 * 
	 * @param angle The amount we want to rotate the angle.
	 * @return The vector itself.</haxe_doc>
		</rotateX>
		<rotateY public="1" set="method" line="360">
			<f a="angle">
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method rotates the vector Y coordinate by a given amount of angles.
	 * 
	 * @param angle The amount we want to rotate the angle.
	 * @return The vector itself.</haxe_doc>
		</rotateY>
		<rotate public="1" set="method" line="376">
			<f a="angle">
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* This method rotates the vector by a given amount of angles.
	 * 
	 * @param angle The amount we want to rotate the angle.
	 * @return The vector itself.</haxe_doc>
		</rotate>
		<distToPoint public="1" set="method" line="391">
			<f a="other">
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This method calculates the distance between the vector and the given vector.
	 * 
	 * @param other The vector to calculate the distance with.
	 * @return The distance.</haxe_doc>
		</distToPoint>
		<distToZero public="1" set="method" line="404">
			<f a=""><x path="Float"/></f>
			<meta><m n=":access"><e>spiller.SpiObject</e></m></meta>
			<haxe_doc>* This method calculates the distance between the vector and (0, 0).
	 * 
	 * @return The distance.</haxe_doc>
		</distToZero>
		<dist public="1" set="method" line="416">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This method calculates the distance between the vector and the given coordinates.
	 * 
	 * @param x The X coordinate.
	 * @param y The Y coordinate.
	 * @return The distance.</haxe_doc>
		</dist>
		<distSquaredToPoint public="1" set="method" line="429">
			<f a="other">
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This method calculates the distance between the vector and other vector. This method returns the distance Squared.
	 * 
	 * @param other The vector to calculate the distance with.
	 * @return The distance squared.</haxe_doc>
		</distSquaredToPoint>
		<distSquared public="1" set="method" line="443">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This method calculates the distance between the vector and the given X and Y coordinates. This method returns the distance Squared.
	 * 
	 * @param x The X coordinate.
	 * @param y The Y coordinate.
	 * @return The distance squared.</haxe_doc>
		</distSquared>
		<setFromPoint public="1" set="method" line="453">
			<f a="localPoint">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Handy method to redirect the set to the copy method.</haxe_doc>
		</setFromPoint>
		<set public="1" set="method" line="461">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Handy method to redirect the set to the make method.</haxe_doc>
		</set>
		<inCoords public="1" set="method" line="475">
			<f a="RectX:RectY:RectWidth:RectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this point is within the given rectangular block
	 * 
	 * @param	RectX		The X value of the region to test within
	 * @param	RectY		The Y value of the region to test within
	 * @param	RectWidth	The width of the region to test within
	 * @param	RectHeight	The height of the region to test within
	 * @return	True if the point is within the region, otherwise false</haxe_doc>
		</inCoords>
		<inSpiRect public="1" set="method" line="486">
			<f a="Rect">
				<c path="spiller.math.SpiRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this point is within the given rectangular block
	 * 
	 * @param	Rect	The SpiRect to test within
	 * @return	True if pointX/pointY is within the SpiRect, otherwise false</haxe_doc>
		</inSpiRect>
		<distanceTo public="1" set="method" line="497">
			<f a="AnotherPoint">
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate the distance to another point.
	 * 
	 * @param 	AnotherPoint	A SpiPoint object to calculate the distance to.
	 * @return	The distance between the two points as a Float.</haxe_doc>
		</distanceTo>
		<floor public="1" set="method" line="505">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* Rounds x and y using Math.floor()</haxe_doc>
		</floor>
		<ceil public="1" set="method" line="515">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* Rounds x and y using Math.ceil()</haxe_doc>
		</ceil>
		<round public="1" set="method" line="525">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* Rounds x and y using Math.round()</haxe_doc>
		</round>
		<print public="1" set="method" line="537">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the values in a printable format.
	 * 
	 * @return</haxe_doc>
		</print>
		<toString public="1" set="method" line="547">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the values in a printable format.
	 * 
	 * @return</haxe_doc>
		</toString>
		<equalsToPoint public="1" set="method" line="555">
			<f a="point">
				<c path="spiller.math.SpiPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Equals method for points.</haxe_doc>
		</equalsToPoint>
		<equals public="1" set="method" line="563">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Equals method for points.</haxe_doc>
		</equals>
		<lerp public="1" set="method" line="575">
			<f a="target:alpha">
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Linear interpolation.
	 * 
	 * @param target		Target point.
	 * @param alpha			The alpha value.
	 * @return				This point.</haxe_doc>
		</lerp>
		<destroy public="1" set="method" line="586">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* {@inheritDoc}</haxe_doc>
		</destroy>
		<new set="method" line="88">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new point object.
	 * 
	 * @param X The X-coordinate of the point in space.
	 * @param Y The Y-coordinate of the point in space.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Stores a 2D floating point coordinate.<br>
 * <br>
 * v1.2 Added new equals methods<br>
 * v1.1 Fixed the point ration<br>
 * v1.0 Initial version<br>
 * <br>
 * @version 1.2 - 28/03/2013
 * @author ratalaika / ratalaikaGames
 * @author Ka Wing Chin]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.SpiObject" params="" file="Libs/spiller/SpiObject.hx">
		<extends path="spiller.SpiBasic"/>
		<LEFT public="1" get="inline" set="null" line="30" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "left" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" line="34" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "right" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</RIGHT>
		<UP public="1" get="inline" set="null" line="38" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "up" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</UP>
		<DOWN public="1" get="inline" set="null" line="42" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "down" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</DOWN>
		<NONE public="1" get="inline" set="null" line="46" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case const meaning no collisions, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</NONE>
		<CEILING public="1" get="inline" set="null" line="50" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case const meaning up, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</CEILING>
		<FLOOR public="1" get="inline" set="null" line="54" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case const meaning down, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</FLOOR>
		<WALL public="1" get="inline" set="null" line="58" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case const meaning only the left and right sides, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</WALL>
		<ANY public="1" get="inline" set="null" line="62" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case const meaning any direction, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</ANY>
		<OVERLAP_BIAS public="1" line="69" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The number of pixels the overlap can have before it won't count.<br>
	 * Default value is 4, should be enough for normal games 16x16 or so<br>
	 * for bigger game you may need to increase this to avoid entering on the map.<br>
	 * (Used in <code>separateX()</code> and <code>separateY()</code>).]]></haxe_doc>
		</OVERLAP_BIAS>
		<PREVENT_OVERLAP public="1" line="74" static="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If we want to prevent overlapping of colliding objects.<br>
	 * This is useful to prevent that one objects move inside another a few pixels.]]></haxe_doc>
		</PREVENT_OVERLAP>
		<PATH_FORWARD public="1" get="inline" set="null" line="78" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then stop.</haxe_doc>
		</PATH_FORWARD>
		<PATH_BACKWARD public="1" get="inline" set="null" line="82" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then stop.</haxe_doc>
		</PATH_BACKWARD>
		<PATH_LOOP_FORWARD public="1" get="inline" set="null" line="86" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then directly back to the start, and start over.</haxe_doc>
		</PATH_LOOP_FORWARD>
		<PATH_LOOP_BACKWARD public="1" get="inline" set="null" line="90" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then directly back to the end, and start over.</haxe_doc>
		</PATH_LOOP_BACKWARD>
		<PATH_YOYO public="1" get="inline" set="null" line="94" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then turn around and go back to the start, over and over.</haxe_doc>
		</PATH_YOYO>
		<PATH_HORIZONTAL_ONLY public="1" get="inline" set="null" line="98" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: ignores any vertical component to the path data, only follows side to side.</haxe_doc>
		</PATH_HORIZONTAL_ONLY>
		<PATH_VERTICAL_ONLY public="1" get="inline" set="null" line="102" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: ignores any horizontal component to the path data, only follows up and down.</haxe_doc>
		</PATH_VERTICAL_ONLY>
		<_pZero set="null" line="189" static="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc><![CDATA[* Should always represent (0,0) - useful for different things, for avoiding unnecessary <code>new</code> calls.]]></haxe_doc>
		</_pZero>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* X position of the upper left corner of this object in world space.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* Y position of the upper left corner of this object in world space.</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of this object.</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of this object.</haxe_doc>
		</height>
		<immovable public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether an object will move/alter position after a collision.</haxe_doc>
		</immovable>
		<immovableX public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether an object will move/alter position after a collision in the X.</haxe_doc>
		</immovableX>
		<immovableY public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether an object will move/alter position after a collision in the Y axis.</haxe_doc>
		</immovableY>
		<velocity public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* The basic speed of this object.</haxe_doc>
		</velocity>
		<mass public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The virtual mass of the object. Default value is 1.
	 * Currently only used with <code>elasticity</code> during collision resolution.
	 * Change at your own risk; effects seem crazy unpredictable so far!]]></haxe_doc>
		</mass>
		<elasticity public="1">
			<x path="Float"/>
			<haxe_doc>* The bounciness of this object.  Only affects collisions.  Default value is 0, or "not bouncy at all."</haxe_doc>
		</elasticity>
		<acceleration public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* How fast the speed of this object is changing.
	 * Useful for smooth movement and gravity.</haxe_doc>
		</acceleration>
		<drag public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* This isn't drag exactly, more like deceleration that is only applied
	 * when acceleration is not affecting the sprite.</haxe_doc>
		</drag>
		<maxVelocity public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc><![CDATA[* If you are using <code>acceleration</code>, you can use <code>maxVelocity</code> with it
	 * to cap the speed automatically (very useful!).]]></haxe_doc>
		</maxVelocity>
		<angle public="1">
			<x path="Float"/>
			<haxe_doc>* Set the angle of a sprite to rotate it.
	 * WARNING: rotating sprites decreases rendering
	 * performance for this sprite by a factor of 10x!</haxe_doc>
		</angle>
		<angularVelocity public="1">
			<x path="Float"/>
			<haxe_doc>* This is how fast you want this sprite to spin.</haxe_doc>
		</angularVelocity>
		<angularAcceleration public="1">
			<x path="Float"/>
			<haxe_doc>* How fast the spin speed should change.</haxe_doc>
		</angularAcceleration>
		<angularDrag public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Like <code>drag</code> but for spinning.]]></haxe_doc>
		</angularDrag>
		<maxAngular public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Use in conjunction with <code>angularAcceleration</code> for fluid spin speed control.]]></haxe_doc>
		</maxAngular>
		<scrollFactor public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* A point that can store numbers from 0 to 1 (for X and Y independently)
	 * that governs how much this object is affected by the camera subsystem.
	 * 0 means it never moves, like a HUD element or far background graphic.
	 * 1 means it scrolls along a the same speed as the foreground layer.
	 * scrollFactor is initialized as (1,1) by default.</haxe_doc>
		</scrollFactor>
		<_flicker>
			<x path="Bool"/>
			<haxe_doc>* Internal helper used for retro-style flickering.</haxe_doc>
		</_flicker>
		<_flickerTimer>
			<x path="Float"/>
			<haxe_doc>* Internal helper used for retro-style flickering.</haxe_doc>
		</_flickerTimer>
		<health public="1">
			<x path="Float"/>
			<haxe_doc>* Handy for storing health percentage or armor points or whatever.</haxe_doc>
		</health>
		<_point>
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* This is just a pre-allocated x-y point container to be used however you like</haxe_doc>
		</_point>
		<_rect>
			<c path="spiller.math.SpiRect"/>
			<haxe_doc>* This is just a pre-allocated rectangle container to be used however you like</haxe_doc>
		</_rect>
		<moves public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Set this to false if you want to skip the automatic motion/movement stuff (see <code>updateMotion()</code>).
	 * SpiObject and SpiSprite default to true.
	 * SpiText, SpiTileblock and SpiTilemap default to false.]]></haxe_doc>
		</moves>
		<touching public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts.
	 * Use bitwise operators to check the values stored here, or use touching(), justStartedTouching(), etc.
	 * You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</touching>
		<wasTouching public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts from the previous game loop step.
	 * Use bitwise operators to check the values stored here, or use touching(), justStartedTouching(), etc.
	 * You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</wasTouching>
		<allowCollisions public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating collision directions.
	 * Use bitwise operators to check the values stored here.
	 * Useful for things like one-way platforms (e.g. allowCollisions = UP;)
	 * The accessor "solid" just flips this variable between NONE and ANY.</haxe_doc>
		</allowCollisions>
		<last public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc><![CDATA[* Important variable for collision processing.
	 * By default this value is set automatically during <code>preUpdate()</code>.]]></haxe_doc>
		</last>
		<path public="1">
			<c path="spiller.util.SpiPath"/>
			<haxe_doc><![CDATA[* A reference to a path object.  Null by default, assigned by <code>followPath()</code>.]]></haxe_doc>
		</path>
		<pathSpeed public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The speed at which the object is moving on the path.
	 * When an object completes a non-looping path circuit,
	 * the pathSpeed will be zeroed out, but the <code>path</code> reference
	 * will NOT be nulled out.  So <code>pathSpeed</code> is a good way
	 * to check if this object is currently following a path or not.]]></haxe_doc>
		</pathSpeed>
		<pathAngle public="1">
			<x path="Float"/>
			<haxe_doc>* The angle in degrees between this object and the next node, where 0 is directly upward, and 90 is to the right.</haxe_doc>
		</pathAngle>
		<_pathNodeIndex>
			<x path="Int"/>
			<haxe_doc>* Internal helper, tracks which node of the path this object is moving toward.</haxe_doc>
		</_pathNodeIndex>
		<_pathMode>
			<x path="Int"/>
			<haxe_doc>* Internal tracker for path behavior flags (like looping, horizontal only, etc).</haxe_doc>
		</_pathMode>
		<_pathInc>
			<x path="Int"/>
			<haxe_doc>* Internal helper for node navigation, specifically yo-yo and backwards movement.</haxe_doc>
		</_pathInc>
		<_pathRotate>
			<x path="Bool"/>
			<haxe_doc>* Internal flag for whether the object's angle should be adjusted to the path angle during path follow behavior.</haxe_doc>
		</_pathRotate>
		<_seeked>
			<c path="spiller.SpiObject"/>
			<haxe_doc>* The object you are seeking.</haxe_doc>
		</_seeked>
		<steerForce>
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* The force of the seeker.</haxe_doc>
		</steerForce>
		<categoryBits public="1">
			<x path="Int"/>
			<haxe_doc>* The collision categoryBits.</haxe_doc>
		</categoryBits>
		<maskBits public="1">
			<x path="Int"/>
			<haxe_doc>* The collision maskBits.</haxe_doc>
		</maskBits>
		<groupIndex public="1">
			<x path="Int"/>
			<haxe_doc>* The ground index for collisions.</haxe_doc>
		</groupIndex>
		<_lastTouching>
			<x path="Int"/>
			<haxe_doc><![CDATA[* The information about the last collision.<br>
	 * You can use it on the postCollision method.]]></haxe_doc>
		</_lastTouching>
		<destroy public="1" set="method" line="368" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this method to null out variables or
	 * manually call destroy() on class members if necessary.
	 * Don't forget to call super.destroy()!</haxe_doc>
		</destroy>
		<new public="1" set="method" line="314">
			<f a="?X:?Y:?Width:?Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Instantiates a <code>SpiObject</code>.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is the base class for most of the display objects<br>
 * (<code>SpiSprite</code>, <code>SpiText</code>, etc).<br>
 * It includes some basic attributes about game objects,<br>
 * including retro-style flickering, basic state information,<br>
 * sizes, scrolling, and basic physics and motion.<br>
 * <br>
 * v1.0 Initial version
 * 
 * @version 1.0 - 17/07/2013
 * @author ratalaika / ratalaikaGames
 * @author Ka Wing Chin
 * @author Thomas Weston]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.math.SpiMath" params="" file="Libs/spiller/math/SpiMath.hx">
		<roundDecimal public="1" set="method" line="58" static="1">
			<f a="num:dec">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Round to the closes number with the number of decimals given. E.g round(2.954165, 2) == 2.95
	 * 
	 * @param num	The number to round.
	 * @param dec 	The number of decimals wanted.
	 * @return The rounded value of that number.</haxe_doc>
		</roundDecimal>
		<bound public="1" get="inline" set="null" line="76" static="1">
			<f a="Value:?Min:?Max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Bound a number by a minimum and maximum. Ensures that this number is 
	 * no smaller than the minimum, and no larger than the maximum.
	 * Leaving a bound null means that side is unbounded.
	 * 
	 * @param	Value	Any number.
	 * @param	Min		Any number.
	 * @param	Max		Any number.
	 * @return	The bounded value of the number.</haxe_doc>
		</bound>
		<pointInCoordinates public="1" set="method" line="94" static="1">
			<f a="pointX:pointY:rectX:rectY:rectWidth:rectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the given rectangular block
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rectX		The X value of the region to test within
	 * @param	rectY		The Y value of the region to test within
	 * @param	rectWidth	The width of the region to test within
	 * @param	rectHeight	The height of the region to test within
	 * 
	 * @return	true if pointX/pointY is within the region, otherwise false</haxe_doc>
		</pointInCoordinates>
		<pointInSpiRect public="1" set="method" line="113" static="1">
			<f a="pointX:pointY:rect">
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the given rectangular block
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rect		The SpiRect to test within
	 * @return	true if pointX/pointY is within the SpiRect, otherwise false</haxe_doc>
		</pointInSpiRect>
		<wrapValue public="1" set="method" line="600" static="1">
			<f a="value:amount:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Adds value to amount and ensures that the result always stays between 0 and max, by wrapping the value around.
	 * <p>Values must be positive integers, and are passed through Math.abs</p>
	 * 
	 * @param value The value to add the amount to
	 * @param amount The amount to add to the value
	 * @param max The maximum the value is allowed to be
	 * @return The wrapped value]]></haxe_doc>
		</wrapValue>
		<vectorLength public="1" set="method" line="621" static="1">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Finds the length of the given vector
	 * 
	 * @param	dx
	 * @param	dy
	 * 
	 * @return</haxe_doc>
		</vectorLength>
		<getDistance public="1" set="method" line="879" static="1">
			<f a="Point1:Point2">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate the distance between two points.
	 * 
	 * @param 	Point1		A SpiPoint object referring to the first location.
	 * @param 	Point2		A SpiPoint object referring to the second location.
	 * @return	The distance between the two points as a floating point Number object.</haxe_doc>
		</getDistance>
		<haxe_doc>* Adds a set of fast Math functions and extends a few commonly used ones.
 * 
 * v1.1 Updated some references and commented 
 * v1.0 Initial version
 * 
 * @version 1.1 - 27/02/2013
 * @author ratalaika / ratalaikaGames
 * @author Richard Davey / Photon Storm</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.math.SpiRect" params="" file="Libs/spiller/math/SpiRect.hx">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X coordinate of the point.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y coordinate of the point.</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the rectangle.</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the rectangle.</haxe_doc>
		</height>
		<getLeft public="1" set="method" line="52">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The X coordinate of the left side of the rectangle.  Read-only.</haxe_doc>
		</getLeft>
		<getRight public="1" set="method" line="60">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The X coordinate of the right side of the rectangle.  Read-only.</haxe_doc>
		</getRight>
		<getTop public="1" set="method" line="68">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The Y coordinate of the top of the rectangle.  Read-only.</haxe_doc>
		</getTop>
		<getBottom public="1" set="method" line="76">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The Y coordinate of the bottom of the rectangle.  Read-only.</haxe_doc>
		</getBottom>
		<make public="1" set="method" line="91">
			<f a="?X:?Y:?Width:?Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="spiller.math.SpiRect"/>
			</f>
			<haxe_doc>* Instantiate a new rectangle.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.
	 * 
	 * @return	A reference to itself.</haxe_doc>
		</make>
		<copyFrom public="1" set="method" line="107">
			<f a="Rect">
				<c path="spiller.math.SpiRect"/>
				<c path="spiller.math.SpiRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified rectangle.
	 * 
	 * @param	Rect	Any <code>SpiRect</code>.
	 * 
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFrom>
		<copyTo public="1" set="method" line="123">
			<f a="Rect">
				<c path="spiller.math.SpiRect"/>
				<c path="spiller.math.SpiRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this rectangle to the specified rectangle.
	 * 
	 * @param	Point	Any <code>SpiRect</code>.
	 * 
	 * @return	A reference to the altered rectangle parameter.]]></haxe_doc>
		</copyTo>
		<copyFromFlash public="1" set="method" line="139">
			<f a="FlashRect">
				<c path="kha.Rectangle"/>
				<c path="spiller.math.SpiRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified libgdx rectangle.
	 * 
	 * @param	FlashRect	Any <code>Rectangle</code>.
	 * 
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFromFlash>
		<copyToFlash public="1" set="method" line="155">
			<f a="FlashRect">
				<c path="kha.Rectangle"/>
				<c path="kha.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this rectangle to the specified libgdx rectangle.
	 * 
	 * @param	Point	Any <code>Rectangle</code>.
	 * 
	 * @return	A reference to the altered rectangle parameter.]]></haxe_doc>
		</copyToFlash>
		<overlaps public="1" set="method" line="171">
			<f a="Rect">
				<c path="spiller.math.SpiRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if some <code>SpiRect</code> object overlaps this <code>SpiRect</code> object.
	 * 
	 * @param	Rect	The rectangle being tested.
	 * 
	 * @return	Whether or not the two rectangles overlap.]]></haxe_doc>
		</overlaps>
		<contains public="1" set="method" line="185">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the given coordinates are contained in the rectangle.
	 * 
	 * @param x			The X coordinate.
	 * @param y			The Y coordinate.</haxe_doc>
		</contains>
		<containsPoint public="1" set="method" line="195">
			<f a="point">
				<c path="spiller.math.SpiPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the given coordinates are contained in the rectangle.
	 * 
	 * @param point			The point with the coordinates.</haxe_doc>
		</containsPoint>
		<containsRect public="1" set="method" line="205">
			<f a="rect">
				<c path="spiller.math.SpiRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the given rectangle is contained in the rectangle.
	 * 
	 * @param rect			The rectangle.</haxe_doc>
		</containsRect>
		<intersection public="1" set="method" line="216">
			<f a="toIntersect">
				<c path="spiller.math.SpiRect"/>
				<c path="spiller.math.SpiRect"/>
			</f>
			<haxe_doc>* Returns the intersection of two rectangles.
	 * 
	 * @param toIntersect
	 * @return</haxe_doc>
		</intersection>
		<intersects public="1" set="method" line="238">
			<f a="toIntersect">
				<c path="spiller.math.SpiRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if two rectangles intersect.
	 * 
	 * @param toIntersect
	 * @return</haxe_doc>
		</intersects>
		<isEmpty public="1" set="method" line="247">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if the rectangle is empty.
	 * @return</haxe_doc>
		</isEmpty>
		<print public="1" set="method" line="256">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the values in a printable format.
	 * @return</haxe_doc>
		</print>
		<offset public="1" set="method" line="267">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adjusts the location of the rectangle object.
	 * 
	 * @param dx
	 * @param dy</haxe_doc>
		</offset>
		<new public="1" set="method" line="41">
			<f a="?X:?Y:?Width:?Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new rectangle.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Stores a rectangle.<br>
 * <br>
 * v1.0 Initial version
 * 
 * @version 1.0 - 17/07/2013
 * @author ratalaika / ratalaikaGames
 * @author	Ka Wing Chin]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.plugin.tweens.SpiTween" params="" file="Libs/spiller/plugin/tweens/SpiTween.hx">
		<implements path="spiller.util.interfaces.ISpiDestroyable"/>
		<PERSIST public="1" get="inline" set="null" line="21" static="1">
			<x path="Int"/>
			<haxe_doc>* Persistent Tween type, will stop when it finishes.</haxe_doc>
		</PERSIST>
		<LOOPING public="1" get="inline" set="null" line="25" static="1">
			<x path="Int"/>
			<haxe_doc>* Looping Tween type, will restart immediately when it finishes.</haxe_doc>
		</LOOPING>
		<PINGPONG public="1" get="inline" set="null" line="29" static="1">
			<x path="Int"/>
			<haxe_doc>* "To and from" Tween type, will play tween hither and thither</haxe_doc>
		</PINGPONG>
		<ONESHOT public="1" get="inline" set="null" line="33" static="1">
			<x path="Int"/>
			<haxe_doc>* Oneshot Tween type, will stop and remove itself from its core container when it finishes.</haxe_doc>
		</ONESHOT>
		<BACKWARD public="1" get="inline" set="null" line="37" static="1">
			<x path="Int"/>
			<haxe_doc>* Backward Tween type, will play tween in reverse direction</haxe_doc>
		</BACKWARD>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc>* True if the tweening is active.</haxe_doc>
		</active>
		<complete public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This method will be called when the tween complete.</haxe_doc>
		</complete>
		<percent public="1">
			<x path="Float"/>
			<haxe_doc>* The period of time that tween has completed.</haxe_doc>
		</percent>
		<scale public="1">
			<x path="Float"/>
			<haxe_doc>* The scale of time.</haxe_doc>
		</scale>
		<_type>
			<x path="Int"/>
			<haxe_doc>* The type of tween.</haxe_doc>
		</_type>
		<_ease>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* The easer method to apply to the Tweened value.</haxe_doc>
		</_ease>
		<_t>
			<x path="Float"/>
			<haxe_doc>* The percent of completed tween.</haxe_doc>
		</_t>
		<_time>
			<x path="Float"/>
			<haxe_doc>* The time that has passed since the tween started.</haxe_doc>
		</_time>
		<_target>
			<x path="Float"/>
			<haxe_doc>* Duration of the tween (in seconds or frames).</haxe_doc>
		</_target>
		<isFinished public="1">
			<x path="Bool"/>
			<haxe_doc>* True if the tweening has finished.</haxe_doc>
		</isFinished>
		<parent public="1">
			<c path="spiller.SpiBasic"/>
			<haxe_doc>* The parent object.</haxe_doc>
		</parent>
		<prev public="1">
			<c path="spiller.plugin.tweens.SpiTween"/>
			<haxe_doc>* The previous tween.</haxe_doc>
		</prev>
		<next public="1">
			<c path="spiller.plugin.tweens.SpiTween"/>
			<haxe_doc>* The next tween.</haxe_doc>
		</next>
		<_backward>
			<x path="Bool"/>
			<haxe_doc>* If the tween has to be played in a reverse direction.</haxe_doc>
		</_backward>
		<destroy public="1" set="method" line="120">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroy method.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="130">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the Tween, called by World.</haxe_doc>
		</update>
		<start public="1" set="method" line="155">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Starts the Tween, or restarts it if it's currently running.</haxe_doc>
		</start>
		<cancel public="1" set="method" line="168">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Immediately stops the Tween and removes it from its Tweener without calling the complete callback.</haxe_doc>
		</cancel>
		<finish public="1" set="method" line="179">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the Tween completes.</haxe_doc>
		</finish>
		<getPercent public="1" set="method" line="215">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Get the percent of completed tween.
	 * 
	 * @return</haxe_doc>
		</getPercent>
		<setPercent public="1" set="method" line="226">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Set the percent.
	 * 
	 * @param value		The percent value.
	 * @return</haxe_doc>
		</setPercent>
		<getScale public="1" set="method" line="235">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Return the time scale.</haxe_doc>
		</getScale>
		<new public="1" set="method" line="102">
			<f a="duration:?type:?complete:?ease">
				<x path="Float"/>
				<x path="Int"/>
				<f a=""><x path="Void"/></f>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor. Specify basic information about the Tween.
	 * @param	duration		Duration of the tween (in seconds or frames).
	 * @param	type			Tween type, one of Tween.PERSIST (default), Tween.LOOPING, or Tween.ONESHOT.
	 * @param	complete		Optional callback for when the Tween completes.
	 * @param	ease			Optional easer method to apply to the Tweened value.</haxe_doc>
		</new>
		<haxe_doc>* The global tween class.
 * 
 * v1.1 Ported to Java
 * v1.0 Initial version (?)
 * 
 * @version 1.1 - January 24th 2013
 * @author ratalaika / ratalaikaGames</haxe_doc>
	</class>
	<class path="spiller.system.macros.SpiMacroUtil" params="" file="Libs/spiller/system/macros/SpiMacroUtil.hx"/>
	<abstract path="spiller.util.SpiColor" params="" file="Libs/spiller/util/SpiColor.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<haxe_doc>* Class representing a color, based on Int. Provides a variety of methods for creating and converting colors.
 * 
 * SpiColor's can be written as Ints. This means you can pass a hex value such as
 * 0xff123456 to a function expecting a SpiColor, and it will automatically become a SpiColor object.
 * Similarly, SpiColors may be treated as Ints.
 * 
 * Note that when using properties of a SpiColor other than ARGB, the values are ultimately stored as
 * ARGB values, so repeatedly manipulating HSB/HSL/CMYK values may result in a gradual loss of precision.
 * 
 * @author Joe Williamson (JoeCreates)</haxe_doc>
		<impl><class path="spiller.util._SpiColor.SpiColor_Impl_" params="" file="Libs/spiller/util/SpiColor.hx" private="1" module="spiller.util.SpiColor">
	<TRANSPARENT public="1" get="inline" set="null" line="20" static="1"><x path="spiller.util.SpiColor"/></TRANSPARENT>
	<WHITE public="1" get="inline" set="null" line="21" static="1"><x path="spiller.util.SpiColor"/></WHITE>
	<GRAY public="1" get="inline" set="null" line="22" static="1"><x path="spiller.util.SpiColor"/></GRAY>
	<BLACK public="1" get="inline" set="null" line="23" static="1"><x path="spiller.util.SpiColor"/></BLACK>
	<GREEN public="1" get="inline" set="null" line="25" static="1"><x path="spiller.util.SpiColor"/></GREEN>
	<LIME public="1" get="inline" set="null" line="26" static="1"><x path="spiller.util.SpiColor"/></LIME>
	<YELLOW public="1" get="inline" set="null" line="27" static="1"><x path="spiller.util.SpiColor"/></YELLOW>
	<ORANGE public="1" get="inline" set="null" line="28" static="1"><x path="spiller.util.SpiColor"/></ORANGE>
	<RED public="1" get="inline" set="null" line="29" static="1"><x path="spiller.util.SpiColor"/></RED>
	<PURPLE public="1" get="inline" set="null" line="30" static="1"><x path="spiller.util.SpiColor"/></PURPLE>
	<BLUE public="1" get="inline" set="null" line="31" static="1"><x path="spiller.util.SpiColor"/></BLUE>
	<BROWN public="1" get="inline" set="null" line="32" static="1"><x path="spiller.util.SpiColor"/></BROWN>
	<PINK public="1" get="inline" set="null" line="33" static="1"><x path="spiller.util.SpiColor"/></PINK>
	<MAGENTA public="1" get="inline" set="null" line="34" static="1"><x path="spiller.util.SpiColor"/></MAGENTA>
	<CYAN public="1" get="inline" set="null" line="35" static="1"><x path="spiller.util.SpiColor"/></CYAN>
	<colorLookup public="1" set="null" line="52" static="1">
		<x path="Map">
			<c path="String"/>
			<x path="Int"/>
		</x>
		<haxe_doc><![CDATA[* A Map<String, Int> which values are the static colors of SpiColor.
	 * You can add more colors for SpiColor.fromString(String) if you need.]]></haxe_doc>
	</colorLookup>
	<red public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</red>
	<blue public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</blue>
	<green public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</green>
	<alpha public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</alpha>
	<redFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redFloat>
	<blueFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueFloat>
	<greenFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenFloat>
	<alphaFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaFloat>
	<cyan public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cyan>
	<magenta public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</magenta>
	<yellow public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</yellow>
	<black public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</black>
	<hue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hue>
	<saturation public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
	</saturation>
	<brightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
	</brightness>
	<lightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
	</lightness>
	<COLOR_REGEX line="76" static="1"><c path="EReg"/></COLOR_REGEX>
	<fromInt public="1" get="inline" set="null" line="84" static="1">
		<f a="Value">
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Create a color from the lest significant four bytes of an Int
	 * 
	 * @param	Value And Int with bytes in the format 0xAARRGGBB
	 * @return	The color as a SpiColor</haxe_doc>
	</fromInt>
	<fromRGB public="1" get="inline" set="null" line="98" static="1">
		<f a="Red:Green:Blue:?Alpha">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Generate a color from integer RGB values (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return The color as a SpiColor</haxe_doc>
	</fromRGB>
	<fromRGBFloat public="1" get="inline" set="null" line="113" static="1">
		<f a="Red:Green:Blue:?Alpha">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Generate a color from float RGB values (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return The color as a SpiColor</haxe_doc>
	</fromRGBFloat>
	<fromCMYK public="1" get="inline" set="null" line="129" static="1">
		<f a="Cyan:Magenta:Yellow:Black:?Alpha">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Generate a color from CMYK values (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return The color as a SpiColor</haxe_doc>
	</fromCMYK>
	<fromHSB public="1" set="method" line="144" static="1">
		<f a="Hue:Saturation:Brightness:?Alpha">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Generate a color from HSB (aka HSV) components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a SpiColor</haxe_doc>
	</fromHSB>
	<fromHSL public="1" get="inline" set="null" line="159" static="1">
		<f a="Hue:Saturation:Lightness:?Alpha">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Generate a color from HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a SpiColor</haxe_doc>
	</fromHSL>
	<fromString public="1" set="method" line="177" static="1">
		<f a="str">
			<c path="String"/>
			<t path="Null"><x path="spiller.util.SpiColor"/></t>
		</f>
		<haxe_doc><![CDATA[* Parses a String and returns a SpiColor or null if the String couldn't be parsed.
	 * Examples (input -> output in hex):
	 * 0x00FF00    -> 0xFF00FF00
	 * 0xAA4578C2  -> 0xAA4578C2
	 * #0000FF     -> 0xFF0000FF
	 * #3F000011   -> 0x3F000011
	 * GRAY        -> 0xFF808080
	 * blue        -> 0xFF0000FF
	 * @param	str 	The string to be parsed
	 * @return	A SpiColor or null if the String couldn't be parsed]]></haxe_doc>
	</fromString>
	<getHSBColorWheel public="1" set="method" line="213" static="1">
		<f a="?Alpha">
			<x path="Int"/>
			<c path="Array"><x path="spiller.util.SpiColor"/></c>
		</f>
		<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
	 * 
	 * @param	Alpha Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque)
	 * @return	HSB color wheel as Array of SpiColors</haxe_doc>
	</getHSBColorWheel>
	<interpolate public="1" get="inline" set="null" line="233" static="1">
		<f a="Color1:Color2:?Factor">
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<haxe_doc>* Get an interpolated color based on two different colors.
	 * 
	 * @param 	Color1 The first color
	 * @param 	Color2 The second color
	 * @param 	Factor Value from 0 to 1 representing how much to shift Color1 toward Color2
	 * @return	The interpolated color</haxe_doc>
	</interpolate>
	<gradient public="1" set="method" line="252" static="1">
		<f a="Color1:Color2:Steps:?Ease">
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
			<x path="Int"/>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<c path="Array"><x path="spiller.util.SpiColor"/></c>
		</f>
		<haxe_doc>* Create a gradient from one color to another
	 * 
	 * @param Color1 The color to shift from
	 * @param Color2 The color to shift to
	 * @param Steps How many colors the gradient should have
	 * @param Ease An optional easing function, such as those provided in SpiEase
	 * @return An array of colors of length Steps, shifting from Color1 to Color2</haxe_doc>
	</gradient>
	<multiply public="1" get="inline" set="null" line="276" static="1">
		<f a="lhs:rhs">
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":op"><e>A*B</e></m></meta>
		<haxe_doc>* Multiply the RGB channels of two SpiColors</haxe_doc>
	</multiply>
	<add public="1" get="inline" set="null" line="285" static="1">
		<f a="lhs:rhs">
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":op"><e>A+B</e></m></meta>
		<haxe_doc>* Add the RGB channels of two SpiColors</haxe_doc>
	</add>
	<subtract public="1" get="inline" set="null" line="294" static="1">
		<f a="lhs:rhs">
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":op"><e>A-B</e></m></meta>
		<haxe_doc>* Subtract the RGB channels of one SpiColor from another</haxe_doc>
	</subtract>
	<getComplementHarmony public="1" get="inline" set="null" line="305" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns a Complementary Color Harmony of this color.
	 * A complementary hue is one directly opposite the color given on the color wheel
	 * 
	 * @return	The complimentary color</haxe_doc>
	</getComplementHarmony>
	<getAnalogousHarmony public="1" get="inline" set="null" line="317" static="1">
		<f a="this:?Threshold">
			<x path="Int"/>
			<x path="Int"/>
			<t path="spiller.util.Harmony"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns an Analogous Color Harmony for the given color.
	 * An Analogous harmony are hues adjacent to each other on the color wheel
	 * 
	 * @param	Threshold Control how adjacent the colors will be (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
	</getAnalogousHarmony>
	<getSplitComplementHarmony public="1" get="inline" set="null" line="332" static="1">
		<f a="this:?Threshold">
			<x path="Int"/>
			<x path="Int"/>
			<t path="spiller.util.Harmony"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns an Split Complement Color Harmony for this color.
	 * A Split Complement harmony are the two hues on either side of the color's Complement
	 * 
	 * @param	Threshold Control how adjacent the colors will be to the Complement (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
	</getSplitComplementHarmony>
	<getTriadicHarmony public="1" get="inline" set="null" line="347" static="1">
		<f a="this">
			<x path="Int"/>
			<t path="spiller.util.TriadicHarmony"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns a Triadic Color Harmony for this color. A Triadic harmony are 3 hues equidistant 
	 * from each other on the color wheel.
	 * 
	 * @return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
	</getTriadicHarmony>
	<to24Bit public="1" get="inline" set="null" line="360" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Return a 24 bit version of this color (i.e. without an alpha value)
	 * 
	 * @return A 24 bit version of this color</haxe_doc>
	</to24Bit>
	<toHexString public="1" get="inline" set="null" line="372" static="1">
		<f a="this:?Alpha:?Prefix">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Return a String representation of the color in the format
	 * 
	 * @param Alpha Whether to include the alpha value in the hes string
	 * @param Prefix Whether to include "0x" prefix at start of string
	 * @return	A string of length 10 in the format 0xAARRGGBB</haxe_doc>
	</toHexString>
	<toWebString public="1" get="inline" set="null" line="383" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Return a String representation of the color in the format #RRGGBB
	 * 
	 * @return	A string of length 7 in the format #RRGGBB</haxe_doc>
	</toWebString>
	<getColorInfo public="1" set="method" line="393" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Get a string of color information about this color
	 * 
	 * @return A string containing information about this color</haxe_doc>
	</getColorInfo>
	<getDarkened public="1" set="method" line="414" static="1">
		<f a="this:?Factor">
			<x path="Int"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Get a darkened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward black.
	 * @return 	A darkened version of this color</haxe_doc>
	</getDarkened>
	<getLightened public="1" get="inline" set="null" line="428" static="1">
		<f a="this:?Factor">
			<x path="Int"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Get a lightened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward white.
	 * @return 	A lightened version of this color</haxe_doc>
	</getLightened>
	<getInverted public="1" get="inline" set="null" line="441" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Get the inversion of this color
	 * 
	 * @return The inversion of this color</haxe_doc>
	</getInverted>
	<setRGB public="1" get="inline" set="null" line="458" static="1">
		<f a="this:Red:Green:Blue:?Alpha">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set RGB values as integers (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return This color</haxe_doc>
	</setRGB>
	<setRGBFloat public="1" get="inline" set="null" line="476" static="1">
		<f a="this:Red:Green:Blue:?Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set RGB values as floats (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
	</setRGBFloat>
	<setCMYK public="1" get="inline" set="null" line="495" static="1">
		<f a="this:Cyan:Magenta:Yellow:Black:?Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set CMYK values as floats (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
	</setCMYK>
	<setHSB public="1" get="inline" set="null" line="513" static="1">
		<f a="this:Hue:Saturation:Brightness:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set HSB (aka HSV) components
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	This color</haxe_doc>
	</setHSB>
	<setHSL public="1" get="inline" set="null" line="529" static="1">
		<f a="this:Hue:Saturation:Lightness:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255
	 * @return	This color</haxe_doc>
	</setHSL>
	<setHSChromaMatch get="inline" set="null" line="539" static="1">
		<f a="this:Hue:Saturation:Chroma:Match:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
	</setHSChromaMatch>
	<_new public="1" set="method" line="559" static="1">
		<f a="?Value">
			<x path="Int"/>
			<x path="spiller.util.SpiColor"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<get_red get="inline" set="null" line="564" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_red>
	<get_green get="inline" set="null" line="569" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_green>
	<get_blue get="inline" set="null" line="574" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blue>
	<get_alpha get="inline" set="null" line="579" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alpha>
	<get_redFloat get="inline" set="null" line="584" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redFloat>
	<get_greenFloat get="inline" set="null" line="589" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenFloat>
	<get_blueFloat get="inline" set="null" line="594" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueFloat>
	<get_alphaFloat get="inline" set="null" line="599" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaFloat>
	<set_red get="inline" set="null" line="604" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_red>
	<set_green get="inline" set="null" line="611" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_green>
	<set_blue get="inline" set="null" line="618" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blue>
	<set_alpha get="inline" set="null" line="625" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alpha>
	<set_redFloat get="inline" set="null" line="632" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redFloat>
	<set_greenFloat get="inline" set="null" line="638" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenFloat>
	<set_blueFloat get="inline" set="null" line="644" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueFloat>
	<set_alphaFloat get="inline" set="null" line="650" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaFloat>
	<get_cyan get="inline" set="null" line="656" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cyan>
	<get_magenta get="inline" set="null" line="661" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_magenta>
	<get_yellow get="inline" set="null" line="666" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_yellow>
	<get_black get="inline" set="null" line="671" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_black>
	<set_cyan get="inline" set="null" line="676" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cyan>
	<set_magenta get="inline" set="null" line="682" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_magenta>
	<set_yellow get="inline" set="null" line="688" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_yellow>
	<set_black get="inline" set="null" line="694" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_black>
	<get_hue set="method" line="700" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_hue>
	<get_brightness get="inline" set="null" line="712" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_brightness>
	<get_saturation get="inline" set="null" line="717" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_saturation>
	<get_lightness get="inline" set="null" line="722" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_lightness>
	<set_hue get="inline" set="null" line="727" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_hue>
	<set_saturation get="inline" set="null" line="733" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_saturation>
	<set_brightness get="inline" set="null" line="739" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_brightness>
	<set_lightness get="inline" set="null" line="745" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_lightness>
	<maxColor get="inline" set="null" line="751" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</maxColor>
	<minColor get="inline" set="null" line="756" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</minColor>
	<boundChannel get="inline" set="null" line="761" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</boundChannel>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="spiller.util._SpiColor.SpiColor_Impl_" params="" file="Libs/spiller/util/SpiColor.hx" private="1" module="spiller.util.SpiColor">
		<TRANSPARENT public="1" get="inline" set="null" line="20" static="1"><x path="spiller.util.SpiColor"/></TRANSPARENT>
		<WHITE public="1" get="inline" set="null" line="21" static="1"><x path="spiller.util.SpiColor"/></WHITE>
		<GRAY public="1" get="inline" set="null" line="22" static="1"><x path="spiller.util.SpiColor"/></GRAY>
		<BLACK public="1" get="inline" set="null" line="23" static="1"><x path="spiller.util.SpiColor"/></BLACK>
		<GREEN public="1" get="inline" set="null" line="25" static="1"><x path="spiller.util.SpiColor"/></GREEN>
		<LIME public="1" get="inline" set="null" line="26" static="1"><x path="spiller.util.SpiColor"/></LIME>
		<YELLOW public="1" get="inline" set="null" line="27" static="1"><x path="spiller.util.SpiColor"/></YELLOW>
		<ORANGE public="1" get="inline" set="null" line="28" static="1"><x path="spiller.util.SpiColor"/></ORANGE>
		<RED public="1" get="inline" set="null" line="29" static="1"><x path="spiller.util.SpiColor"/></RED>
		<PURPLE public="1" get="inline" set="null" line="30" static="1"><x path="spiller.util.SpiColor"/></PURPLE>
		<BLUE public="1" get="inline" set="null" line="31" static="1"><x path="spiller.util.SpiColor"/></BLUE>
		<BROWN public="1" get="inline" set="null" line="32" static="1"><x path="spiller.util.SpiColor"/></BROWN>
		<PINK public="1" get="inline" set="null" line="33" static="1"><x path="spiller.util.SpiColor"/></PINK>
		<MAGENTA public="1" get="inline" set="null" line="34" static="1"><x path="spiller.util.SpiColor"/></MAGENTA>
		<CYAN public="1" get="inline" set="null" line="35" static="1"><x path="spiller.util.SpiColor"/></CYAN>
		<colorLookup public="1" set="null" line="52" static="1">
			<x path="Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<haxe_doc><![CDATA[* A Map<String, Int> which values are the static colors of SpiColor.
	 * You can add more colors for SpiColor.fromString(String) if you need.]]></haxe_doc>
		</colorLookup>
		<red public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</red>
		<blue public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</blue>
		<green public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</green>
		<alpha public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</alpha>
		<redFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redFloat>
		<blueFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueFloat>
		<greenFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenFloat>
		<alphaFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaFloat>
		<cyan public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cyan>
		<magenta public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</magenta>
		<yellow public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</yellow>
		<black public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</black>
		<hue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hue>
		<saturation public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
		</saturation>
		<brightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
		</brightness>
		<lightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
		</lightness>
		<COLOR_REGEX line="76" static="1"><c path="EReg"/></COLOR_REGEX>
		<fromInt public="1" get="inline" set="null" line="84" static="1">
			<f a="Value">
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Create a color from the lest significant four bytes of an Int
	 * 
	 * @param	Value And Int with bytes in the format 0xAARRGGBB
	 * @return	The color as a SpiColor</haxe_doc>
		</fromInt>
		<fromRGB public="1" get="inline" set="null" line="98" static="1">
			<f a="Red:Green:Blue:?Alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Generate a color from integer RGB values (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return The color as a SpiColor</haxe_doc>
		</fromRGB>
		<fromRGBFloat public="1" get="inline" set="null" line="113" static="1">
			<f a="Red:Green:Blue:?Alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Generate a color from float RGB values (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return The color as a SpiColor</haxe_doc>
		</fromRGBFloat>
		<fromCMYK public="1" get="inline" set="null" line="129" static="1">
			<f a="Cyan:Magenta:Yellow:Black:?Alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Generate a color from CMYK values (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return The color as a SpiColor</haxe_doc>
		</fromCMYK>
		<fromHSB public="1" set="method" line="144" static="1">
			<f a="Hue:Saturation:Brightness:?Alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Generate a color from HSB (aka HSV) components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a SpiColor</haxe_doc>
		</fromHSB>
		<fromHSL public="1" get="inline" set="null" line="159" static="1">
			<f a="Hue:Saturation:Lightness:?Alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Generate a color from HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a SpiColor</haxe_doc>
		</fromHSL>
		<fromString public="1" set="method" line="177" static="1">
			<f a="str">
				<c path="String"/>
				<t path="Null"><x path="spiller.util.SpiColor"/></t>
			</f>
			<haxe_doc><![CDATA[* Parses a String and returns a SpiColor or null if the String couldn't be parsed.
	 * Examples (input -> output in hex):
	 * 0x00FF00    -> 0xFF00FF00
	 * 0xAA4578C2  -> 0xAA4578C2
	 * #0000FF     -> 0xFF0000FF
	 * #3F000011   -> 0x3F000011
	 * GRAY        -> 0xFF808080
	 * blue        -> 0xFF0000FF
	 * @param	str 	The string to be parsed
	 * @return	A SpiColor or null if the String couldn't be parsed]]></haxe_doc>
		</fromString>
		<getHSBColorWheel public="1" set="method" line="213" static="1">
			<f a="?Alpha">
				<x path="Int"/>
				<c path="Array"><x path="spiller.util.SpiColor"/></c>
			</f>
			<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
	 * 
	 * @param	Alpha Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque)
	 * @return	HSB color wheel as Array of SpiColors</haxe_doc>
		</getHSBColorWheel>
		<interpolate public="1" get="inline" set="null" line="233" static="1">
			<f a="Color1:Color2:?Factor">
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<haxe_doc>* Get an interpolated color based on two different colors.
	 * 
	 * @param 	Color1 The first color
	 * @param 	Color2 The second color
	 * @param 	Factor Value from 0 to 1 representing how much to shift Color1 toward Color2
	 * @return	The interpolated color</haxe_doc>
		</interpolate>
		<gradient public="1" set="method" line="252" static="1">
			<f a="Color1:Color2:Steps:?Ease">
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<c path="Array"><x path="spiller.util.SpiColor"/></c>
			</f>
			<haxe_doc>* Create a gradient from one color to another
	 * 
	 * @param Color1 The color to shift from
	 * @param Color2 The color to shift to
	 * @param Steps How many colors the gradient should have
	 * @param Ease An optional easing function, such as those provided in SpiEase
	 * @return An array of colors of length Steps, shifting from Color1 to Color2</haxe_doc>
		</gradient>
		<multiply public="1" get="inline" set="null" line="276" static="1">
			<f a="lhs:rhs">
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":op"><e>A*B</e></m></meta>
			<haxe_doc>* Multiply the RGB channels of two SpiColors</haxe_doc>
		</multiply>
		<add public="1" get="inline" set="null" line="285" static="1">
			<f a="lhs:rhs">
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":op"><e>A+B</e></m></meta>
			<haxe_doc>* Add the RGB channels of two SpiColors</haxe_doc>
		</add>
		<subtract public="1" get="inline" set="null" line="294" static="1">
			<f a="lhs:rhs">
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":op"><e>A-B</e></m></meta>
			<haxe_doc>* Subtract the RGB channels of one SpiColor from another</haxe_doc>
		</subtract>
		<getComplementHarmony public="1" get="inline" set="null" line="305" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns a Complementary Color Harmony of this color.
	 * A complementary hue is one directly opposite the color given on the color wheel
	 * 
	 * @return	The complimentary color</haxe_doc>
		</getComplementHarmony>
		<getAnalogousHarmony public="1" get="inline" set="null" line="317" static="1">
			<f a="this:?Threshold">
				<x path="Int"/>
				<x path="Int"/>
				<t path="spiller.util.Harmony"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns an Analogous Color Harmony for the given color.
	 * An Analogous harmony are hues adjacent to each other on the color wheel
	 * 
	 * @param	Threshold Control how adjacent the colors will be (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
		</getAnalogousHarmony>
		<getSplitComplementHarmony public="1" get="inline" set="null" line="332" static="1">
			<f a="this:?Threshold">
				<x path="Int"/>
				<x path="Int"/>
				<t path="spiller.util.Harmony"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns an Split Complement Color Harmony for this color.
	 * A Split Complement harmony are the two hues on either side of the color's Complement
	 * 
	 * @param	Threshold Control how adjacent the colors will be to the Complement (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
		</getSplitComplementHarmony>
		<getTriadicHarmony public="1" get="inline" set="null" line="347" static="1">
			<f a="this">
				<x path="Int"/>
				<t path="spiller.util.TriadicHarmony"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns a Triadic Color Harmony for this color. A Triadic harmony are 3 hues equidistant 
	 * from each other on the color wheel.
	 * 
	 * @return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
		</getTriadicHarmony>
		<to24Bit public="1" get="inline" set="null" line="360" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Return a 24 bit version of this color (i.e. without an alpha value)
	 * 
	 * @return A 24 bit version of this color</haxe_doc>
		</to24Bit>
		<toHexString public="1" get="inline" set="null" line="372" static="1">
			<f a="this:?Alpha:?Prefix">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Return a String representation of the color in the format
	 * 
	 * @param Alpha Whether to include the alpha value in the hes string
	 * @param Prefix Whether to include "0x" prefix at start of string
	 * @return	A string of length 10 in the format 0xAARRGGBB</haxe_doc>
		</toHexString>
		<toWebString public="1" get="inline" set="null" line="383" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Return a String representation of the color in the format #RRGGBB
	 * 
	 * @return	A string of length 7 in the format #RRGGBB</haxe_doc>
		</toWebString>
		<getColorInfo public="1" set="method" line="393" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Get a string of color information about this color
	 * 
	 * @return A string containing information about this color</haxe_doc>
		</getColorInfo>
		<getDarkened public="1" set="method" line="414" static="1">
			<f a="this:?Factor">
				<x path="Int"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Get a darkened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward black.
	 * @return 	A darkened version of this color</haxe_doc>
		</getDarkened>
		<getLightened public="1" get="inline" set="null" line="428" static="1">
			<f a="this:?Factor">
				<x path="Int"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Get a lightened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward white.
	 * @return 	A lightened version of this color</haxe_doc>
		</getLightened>
		<getInverted public="1" get="inline" set="null" line="441" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Get the inversion of this color
	 * 
	 * @return The inversion of this color</haxe_doc>
		</getInverted>
		<setRGB public="1" get="inline" set="null" line="458" static="1">
			<f a="this:Red:Green:Blue:?Alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set RGB values as integers (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return This color</haxe_doc>
		</setRGB>
		<setRGBFloat public="1" get="inline" set="null" line="476" static="1">
			<f a="this:Red:Green:Blue:?Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set RGB values as floats (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
		</setRGBFloat>
		<setCMYK public="1" get="inline" set="null" line="495" static="1">
			<f a="this:Cyan:Magenta:Yellow:Black:?Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set CMYK values as floats (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
		</setCMYK>
		<setHSB public="1" get="inline" set="null" line="513" static="1">
			<f a="this:Hue:Saturation:Brightness:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set HSB (aka HSV) components
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	This color</haxe_doc>
		</setHSB>
		<setHSL public="1" get="inline" set="null" line="529" static="1">
			<f a="this:Hue:Saturation:Lightness:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255
	 * @return	This color</haxe_doc>
		</setHSL>
		<setHSChromaMatch get="inline" set="null" line="539" static="1">
			<f a="this:Hue:Saturation:Chroma:Match:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
		</setHSChromaMatch>
		<_new public="1" set="method" line="559" static="1">
			<f a="?Value">
				<x path="Int"/>
				<x path="spiller.util.SpiColor"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<get_red get="inline" set="null" line="564" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_red>
		<get_green get="inline" set="null" line="569" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_green>
		<get_blue get="inline" set="null" line="574" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blue>
		<get_alpha get="inline" set="null" line="579" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alpha>
		<get_redFloat get="inline" set="null" line="584" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redFloat>
		<get_greenFloat get="inline" set="null" line="589" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenFloat>
		<get_blueFloat get="inline" set="null" line="594" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueFloat>
		<get_alphaFloat get="inline" set="null" line="599" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaFloat>
		<set_red get="inline" set="null" line="604" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_red>
		<set_green get="inline" set="null" line="611" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_green>
		<set_blue get="inline" set="null" line="618" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blue>
		<set_alpha get="inline" set="null" line="625" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alpha>
		<set_redFloat get="inline" set="null" line="632" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redFloat>
		<set_greenFloat get="inline" set="null" line="638" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenFloat>
		<set_blueFloat get="inline" set="null" line="644" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueFloat>
		<set_alphaFloat get="inline" set="null" line="650" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaFloat>
		<get_cyan get="inline" set="null" line="656" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cyan>
		<get_magenta get="inline" set="null" line="661" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_magenta>
		<get_yellow get="inline" set="null" line="666" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_yellow>
		<get_black get="inline" set="null" line="671" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_black>
		<set_cyan get="inline" set="null" line="676" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cyan>
		<set_magenta get="inline" set="null" line="682" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_magenta>
		<set_yellow get="inline" set="null" line="688" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_yellow>
		<set_black get="inline" set="null" line="694" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_black>
		<get_hue set="method" line="700" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_hue>
		<get_brightness get="inline" set="null" line="712" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_brightness>
		<get_saturation get="inline" set="null" line="717" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_saturation>
		<get_lightness get="inline" set="null" line="722" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_lightness>
		<set_hue get="inline" set="null" line="727" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_hue>
		<set_saturation get="inline" set="null" line="733" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_saturation>
		<set_brightness get="inline" set="null" line="739" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_brightness>
		<set_lightness get="inline" set="null" line="745" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_lightness>
		<maxColor get="inline" set="null" line="751" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</maxColor>
		<minColor get="inline" set="null" line="756" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</minColor>
		<boundChannel get="inline" set="null" line="761" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</boundChannel>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="spiller.util.Harmony" params="" file="Libs/spiller/util/SpiColor.hx" module="spiller.util.SpiColor"><a>
	<warmer><x path="spiller.util.SpiColor"/></warmer>
	<original><x path="spiller.util.SpiColor"/></original>
	<colder><x path="spiller.util.SpiColor"/></colder>
</a></typedef>
	<typedef path="spiller.util.TriadicHarmony" params="" file="Libs/spiller/util/SpiColor.hx" module="spiller.util.SpiColor"><a>
	<color3><x path="spiller.util.SpiColor"/></color3>
	<color2><x path="spiller.util.SpiColor"/></color2>
	<color1><x path="spiller.util.SpiColor"/></color1>
</a></typedef>
	<class path="spiller.util.SpiDestroyUtil" params="" file="Libs/spiller/util/SpiDestroyUtil.hx">
		<destroy public="1" params="T" set="method" line="21" static="1">
			<f a="object">
				<c path="destroy.T"/>
				<c path="destroy.T"/>
			</f>
			<haxe_doc>* Checks if an object is not null before calling destroy(), always returns null.
	 * 
	 * @param	object	An ISpiDestroyable object that will be destroyed if it's not null.</haxe_doc>
		</destroy>
		<destroyArray public="1" params="T" set="method" line="35" static="1">
			<f a="array">
				<c path="Array"><c path="destroyArray.T"/></c>
				<c path="Array"><c path="destroyArray.T"/></c>
			</f>
			<haxe_doc>* Destroy every element of an array of ISpiDestroyables
	 *
	 * @param	array	An Array of ISpiDestroyable objects</haxe_doc>
		</destroyArray>
		<put public="1" params="T" set="method" line="51" static="1">
			<f a="object">
				<c path="put.T"/>
				<c path="put.T"/>
			</f>
			<haxe_doc>* Checks if an object is not null before putting it back into the pool, always returns null.
	 * 
	 * @param	object	An ISpiPoolable object that will be put back into the pool if it's not null</haxe_doc>
		</put>
		<putArray public="1" params="T" set="method" line="67" static="1">
			<f a="array">
				<c path="Array"><c path="putArray.T"/></c>
				<c path="Array"><c path="putArray.T"/></c>
			</f>
			<haxe_doc>* Puts all objects in an Array of ISpiPoolable objects back into 
	 * the pool by calling SpiDestroyUtil.put() on them
	 *
	 * @param	array	An Array of ISpiPoolable objects
	 * @return	null</haxe_doc>
		</putArray>
		<haxe_doc><![CDATA[* Handy manager for pooling and destroying objects.
 * 
 * v1.0 Initial version<br>
 * <br>
 * @version 1.0 - 18/04/2015
 * @author ratalaika / ratalaikaGames]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.util.SpiPath" params="" file="Libs/spiller/util/SpiPath.hx">
		<nodes public="1">
			<c path="Array"><c path="spiller.math.SpiPoint"/></c>
			<haxe_doc><![CDATA[* The list of <code>SpiPoint</code>s that make up the path data.]]></haxe_doc>
		</nodes>
		<debugColor public="1">
			<x path="Int"/>
			<haxe_doc>* Specify a debug display color for the path.  Default is white.</haxe_doc>
		</debugColor>
		<debugScrollFactor public="1">
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* Specify a debug display scroll factor for the path.  Default is (1,1).
	 * NOTE: does not affect world movement!  Object scroll factors take care of that.</haxe_doc>
		</debugScrollFactor>
		<ignoreDrawDebug public="1">
			<x path="Bool"/>
			<haxe_doc>* Setting this to true will prevent the object from appearing
	 * when the visual debug mode in the debugger overlay is toggled on.
	 * @default false</haxe_doc>
		</ignoreDrawDebug>
		<_point>
			<c path="spiller.math.SpiPoint"/>
			<haxe_doc>* Internal helper for keeping new variable instantiations under control.</haxe_doc>
		</_point>
		<destroy public="1" set="method" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<add public="1" set="method" line="92">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a new node to the end of the path at the specified location.
	 * 
	 * @param	X	X position of the new path point in world coordinates.
	 * @param	Y	Y position of the new path point in world coordinates.</haxe_doc>
		</add>
		<addAt public="1" set="method" line="104">
			<f a="X:Y:Index">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a new node to the path at the specified location and index within the path.
	 * 
	 * @param	X		X position of the new path point in world coordinates.
	 * @param	Y		Y position of the new path point in world coordinates.
	 * @param	Index	Where within the list of path nodes to insert this new point.</haxe_doc>
		</addAt>
		<addPoint public="1" set="method" line="119">
			<f a="Node:?AsReference">
				<c path="spiller.math.SpiPoint"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * <code>SpiPoint</code> object to the path.  This allows you to do neat things, like dynamic paths.
	 * 
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.]]></haxe_doc>
		</addPoint>
		<addPointAt public="1" set="method" line="136">
			<f a="Node:Index:?AsReference">
				<c path="spiller.math.SpiPoint"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * <code>SpiPoint</code> object to the path.  This allows you to do neat things, like dynamic paths.
	 * 
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	Index			Where within the list of path nodes to insert this new point.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.]]></haxe_doc>
		</addPointAt>
		<remove public="1" set="method" line="154">
			<f a="Node">
				<c path="spiller.math.SpiPoint"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc><![CDATA[* Remove a node from the path.
	 * NOTE: only works with points added by reference or with references from <code>nodes</code> itself!
	 * 
	 * @param	Node	The point object you want to remove from the path.
	 * 
	 * @return	The node that was excised.  Returns null if the node was not found.]]></haxe_doc>
		</remove>
		<removeAt public="1" set="method" line="170">
			<f a="Index">
				<x path="Int"/>
				<c path="spiller.math.SpiPoint"/>
			</f>
			<haxe_doc>* Remove a node from the path using the specified position in the list of path nodes.
	 * 
	 * @param	Index	Where within the list of path nodes you want to remove a node.
	 * 
	 * @return	The node that was excised.  Returns null if there were no nodes in the path.</haxe_doc>
		</removeAt>
		<head public="1" set="method" line="184">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* Get the first node in the list.
	 * 
	 * @return	The first node in the path.</haxe_doc>
		</head>
		<tail public="1" set="method" line="196">
			<f a=""><c path="spiller.math.SpiPoint"/></f>
			<haxe_doc>* Get the last node in the list.
	 * 
	 * @return	The last node in the path.</haxe_doc>
		</tail>
		<drawDebug public="1" set="method" line="211">
			<f a="?Camera">
				<c path="spiller.SpiCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* While this doesn't override <code>SpiBasic.drawDebug()</code>, the behavior is very similar.
	 * Based on this path data, it draws a simple lines-and-boxes representation of the path
	 * if the visual debug mode was toggled in the debugger overlay.  You can use <code>debugColor</code>
	 * and <code>debugScrollFactor</code> to control the path's appearance.
	 * 
	 * @param	Camera		The camera object the path will draw to.]]></haxe_doc>
		</drawDebug>
		<new public="1" set="method" line="53">
			<f a="?Nodes">
				<c path="Array"><c path="spiller.math.SpiPoint"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new path object.
	 * 
	 * @param	Nodes	Optional, can specify all the points for the path up front if you want.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is a simple path data container.  Basically a list of points that<br>
 * a <code>SpiObject</code> can follow.  Also has code for drawing debug visuals.<br>
 * <code>SpiTilemap.findPath()</code> returns a path object, but you can<br>
 * also just make your own, using the <code>add()</code> functions below<br>
 * or by creating your own array of points.<br>
 * <br>
 * v1.0 Initial version
 * 
 * @version 1.0 - 17/07/2013
 * @author ratalaika / ratalaikaGames
 * @author	Thomas Weston
 * @author	Ka Wing Chin]]></haxe_doc>
	</class>
	<class path="spiller.util.SpiStringUtil" params="" file="Libs/spiller/util/SpiStringUtil.hx">
		<formatTicks public="1" get="inline" set="null" line="26" static="1">
			<f a="StartTicks:EndTicks">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Takes two "ticks" timestamps and formats them into the number of seconds that passed as a String.
	 * Useful for logging, debugging, the watch window, or whatever else.
	 * 
	 * @param	StartTicks	The first timestamp from the system.
	 * @param	EndTicks	The second timestamp from the system.
	 * @return	A String containing the formatted time elapsed information.</haxe_doc>
		</formatTicks>
		<formatTime public="1" get="inline" set="null" line="38" static="1">
			<f a="Seconds:?ShowMS">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Format seconds as minutes with a colon, an optionally with milliseconds too.
	 * 
	 * @param	Seconds		The number of seconds (for example, time remaining, time spent, etc).
	 * @param	ShowMS		Whether to show milliseconds after a "." as well.  Default value is false.
	 * @return	A nicely formatted String, like "1:03".</haxe_doc>
		</formatTime>
		<formatArray public="1" get="inline" set="null" line="68" static="1">
			<f a="AnyArray">
				<c path="Array"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Generate a comma-separated string from an array.
	 * Especially useful for tracing or other debug output.
	 * 
	 * @param	AnyArray	Any Array object.
	 * @return	A comma-separated String containing the .toString() output of each element in the array.</haxe_doc>
		</formatArray>
		<formatStringMap public="1" get="inline" set="null" line="90" static="1">
			<f a="AnyMap">
				<x path="Map">
					<c path="String"/>
					<d/>
				</x>
				<c path="String"/>
			</f>
			<haxe_doc>* Generate a comma-seperated string representation of the keys of a StringMap.
	 * 
	 * @param  AnyMap    A StringMap object.
	 * @return  A String formatted like this: key1, key2, ..., keyX</haxe_doc>
		</formatStringMap>
		<formatMoney public="1" get="inline" set="null" line="112" static="1">
			<f a="Amount:?ShowDecimal:?EnglishStyle">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Automatically commas and decimals in the right places for displaying money amounts.
	 * Does not include a dollar sign or anything, so doesn't really do much
	 * if you call say var results:String = SpiString.formatMoney(10,false);
	 * However, very handy for displaying large sums or decimal money values.
	 * 
	 * @param	Amount			How much moneys (in dollars, or the equivalent "main" currency - i.e. not cents).
	 * @param	ShowDecimal		Whether to show the decimals/cents component. Default value is true.
	 * @param	EnglishStyle	Major quantities (thousands, millions, etc) separated by commas, and decimal by a period.  Default value is true.
	 * @return	A nicely formatted String.  Does not include a dollar sign or anything!</haxe_doc>
		</formatMoney>
		<formatBytes public="1" set="method" line="164" static="1">
			<f a="Bytes:?Precision">
				<x path="Float"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Takes an amount of bytes and finds the fitting unit. Makes sure that the 
	 * value is below 1024. Example: formatBytes(123456789); -> 117.74MB]]></haxe_doc>
		</formatBytes>
		<filterDigits public="1" set="method" line="182" static="1">
			<f a="Input">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Takes a string and filters out everything but the digits.
	 * 
	 * @param 	Input	The input string
	 * @return 	The output string, digits-only</haxe_doc>
		</filterDigits>
		<htmlFormat public="1" set="method" line="206" static="1">
			<f a="Text:?Size:?Color:?Bold:?Italic:?Underlined">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Format a text with html tags - useful for TextField.htmlText. 
	 * Used by the log window of the debugger.
	 * 
	 * @param	Text		The text to format
	 * @param	Size		The text size, using the font-size-tag
	 * @param	Color		The text color, using font-color-tag
	 * @param	Bold		Whether the text should be bold (b-tag)
	 * @param	Italic		Whether the text should be italic (i-tag)
	 * @param	Underlined 	Whether the text should be underlined (u-tag)
	 * @return	The html-formatted text.</haxe_doc>
		</htmlFormat>
		<getDomain public="1" set="method" line="265" static="1">
			<f a="url">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns the domain of a URL.</haxe_doc>
		</getDomain>
		<sameClassName public="1" get="inline" set="null" line="285" static="1">
			<f a="Obj1:Obj2:?Simple">
				<d/>
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Helper function that uses getClassName to compare two objects' class names.
	 * 
	 * @param	Obj1	The first object
	 * @param	Obj2	The second object
	 * @param	Simple 	Only uses the class name, not the package or packages.
	 * @return	Whether they have the same class name or not</haxe_doc>
		</sameClassName>
		<toIntArray public="1" set="method" line="297" static="1">
			<f a="Data">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Split a comma-separated string into an array of ints
	 * 
	 * @param	Data 	String formatted like this: "1, 2, 5, -10, 120, 27"
	 * @return	An array of ints</haxe_doc>
		</toIntArray>
		<toFloatArray public="1" set="method" line="318" static="1">
			<f a="Data">
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Split a comma-separated string into an array of floats
	 * 
	 * @param	Data string formatted like this: "1.0,2.1,5.6,1245587.9, -0.00354"
	 * @return	An array of floats</haxe_doc>
		</toFloatArray>
		<arrayToCSV public="1" set="method" line="341" static="1">
			<f a="Data:Width:?Invert">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts a one-dimensional array of tile data to a comma-separated string.
	 * 
	 * @param	Data		An array full of integer tile references.
	 * @param	Width		The number of tiles in each row.
	 * @param	Invert		Recommended only for 1-bit arrays - changes 0s to 1s and vice versa.
	 * @return	A comma-separated string containing the level data in a SpiTilemap-friendly format.</haxe_doc>
		</arrayToCSV>
		<getDebugString public="1" set="method" line="542" static="1">
			<f a="LabelValuePairs">
				<c path="Array"><c path="spiller.util.LabelValuePair"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Helper function to create a string for toString() functions. Automatically rounds values according to SpiG.debugger.precision.
	 * Strings are formatted in the format: (x: 50 | y: 60 | visible: false)
	 * 
	 * @param	LabelValuePairs		Array with the data for the string</haxe_doc>
		</getDebugString>
		<contains public="1" get="inline" set="null" line="561" static="1"><f a="s:str">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></contains>
		<haxe_doc>* A class primarily containing functions related 
 * to formatting different data types to strings.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.util.LabelValuePairPool" params="" file="Libs/spiller/util/SpiStringUtil.hx" module="spiller.util.SpiStringUtil">
		<extends path="spiller.util.SpiPool"><c path="spiller.util.LabelValuePair"/></extends>
		<create public="1" set="method" line="606" override="1"><f a=""><c path="spiller.util.LabelValuePair"/></f></create>
		<new public="1" set="method" line="603"><f a="?StartSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="spiller.util.LabelValuePair" params="" file="Libs/spiller/util/SpiStringUtil.hx" module="spiller.util.SpiStringUtil">
		<implements path="spiller.util.interfaces.ISpiDestroyable"/>
		<_pool line="571" static="1"><c path="spiller.util.LabelValuePairPool"/></_pool>
		<weak public="1" get="inline" set="null" line="573" static="1"><f a="label:value">
	<c path="String"/>
	<d/>
	<c path="spiller.util.LabelValuePair"/>
</f></weak>
		<label public="1"><c path="String"/></label>
		<value public="1"><d/></value>
		<create public="1" get="inline" set="null" line="581"><f a="label:value">
	<c path="String"/>
	<d/>
	<c path="spiller.util.LabelValuePair"/>
</f></create>
		<put public="1" get="inline" set="null" line="588"><f a=""><x path="Void"/></f></put>
		<destroy public="1" get="inline" set="null" line="593"><f a=""><x path="Void"/></f></destroy>
		<new set="method" line="600"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>spiller.util.LabelValuePairPool</e></m>
		</meta>
	</class>
</haxe>